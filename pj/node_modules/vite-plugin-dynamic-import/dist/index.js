"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.utils = void 0;
const path_1 = __importDefault(require("path"));
const fast_glob_1 = __importDefault(require("fast-glob"));
const utils_1 = require("./utils");
const resolve_1 = require("./resolve");
const dynamic_import_to_glob_1 = require("./dynamic-import-to-glob");
__exportStar(require("./dynamic-import-to-glob"), exports);
__exportStar(require("./resolve"), exports);
exports.utils = __importStar(require("./utils"));
const PLUGIN_NAME = 'vite-plugin-dynamic-import';
function dynamicImport(options = {}) {
    const extensions = utils_1.JS_EXTENSIONS.concat(utils_1.KNOWN_SFC_EXTENSIONS);
    let globExtensions;
    let config;
    let resolve;
    return {
        name: PLUGIN_NAME,
        configResolved(_config) {
            var _a;
            config = _config;
            globExtensions = ((_a = config.resolve) === null || _a === void 0 ? void 0 : _a.extensions) || extensions;
            resolve = new resolve_1.Resolve(_config);
        },
        async transform(code, id) {
            var _a;
            const pureId = (0, utils_1.cleanUrl)(id);
            if (/node_modules\/(?!\.vite)/.test(pureId))
                return;
            if (!extensions.includes(path_1.default.extname(pureId)))
                return;
            if (!(0, utils_1.hasDynamicImport)(code))
                return;
            if (((_a = options.filter) === null || _a === void 0 ? void 0 : _a.call(options, pureId)) === false)
                return;
            const ast = this.parse(code);
            const ms = new utils_1.MagicString(code);
            let dynamicImportIndex = 0;
            const runtimeFunctions = [];
            await (0, utils_1.simpleWalk)(ast, {
                async ImportExpression(node) {
                    var _a;
                    const importStatement = code.slice(node.start, node.end);
                    const importeeRaw = code.slice(node.source.start, node.source.end);
                    // skip @vite-ignore
                    if (utils_1.viteIgnoreRE.test(importStatement))
                        return;
                    // the user explicitly ignore this import
                    if ((_a = options.viteIgnore) === null || _a === void 0 ? void 0 : _a.call(options, importeeRaw, pureId)) {
                        ms.overwrite(node.source.start, node.source.start, '/*@vite-ignore*/'); // append left
                        return;
                    }
                    if (node.source.type === 'Literal') {
                        const importee = importeeRaw.slice(1, -1);
                        // empty value
                        if (!importee)
                            return;
                        // normally importee
                        if (utils_1.normallyImporteeRE.test(importee))
                            return;
                        const rsld = await resolve.tryResolve(importee, id);
                        // alias or bare
                        if (rsld && utils_1.normallyImporteeRE.test(rsld.import.resolved)) {
                            ms.overwrite(node.start, node.end, `import("${rsld.import.resolved}")`);
                            return;
                        }
                    }
                    const globResult = await globFiles(node, code, id, resolve, globExtensions, options.depth === false ? false : true);
                    if (!globResult)
                        return;
                    let { files, resolved, normally } = globResult;
                    // skip itself
                    files = files.filter(f => path_1.default.join(path_1.default.dirname(id), f) !== id);
                    // execute the Options.onFiles
                    options.onFiles && (files = options.onFiles(files, id) || files);
                    if (normally) {
                        // normally importee (ðŸš§-â‘¢ After `expressiontoglob()` processing)
                        ms.overwrite(node.start, node.end, `import('${normally}')`);
                    }
                    else {
                        if (!(files === null || files === void 0 ? void 0 : files.length))
                            return;
                        const maps = (0, utils_1.mappingPath)(files, resolved);
                        const runtimeName = `__variableDynamicImportRuntime${dynamicImportIndex++}__`;
                        const runtimeFn = generateDynamicImportRuntime(maps, runtimeName);
                        // extension should be removed, because if the "index" file is in the directory, an error will occur
                        //
                        // e.g. 
                        // â”œâ”€â”¬ views
                        // â”‚ â”œâ”€â”¬ foo
                        // â”‚ â”‚ â””â”€â”€ index.js
                        // â”‚ â””â”€â”€ bar.js
                        //
                        // the './views/*.js' should be matched ['./views/foo/index.js', './views/bar.js'], this may not be rigorous
                        ms.overwrite(node.start, node.end, `${runtimeName}(${importeeRaw})`);
                        runtimeFunctions.push(runtimeFn);
                    }
                },
            });
            if (runtimeFunctions.length) {
                ms.append([
                    '// ---- dynamic import runtime functions --S--',
                    ...runtimeFunctions,
                    '// ---- dynamic import runtime functions --E--',
                ].join('\n'));
            }
            const str = ms.toString();
            return str === code ? null : str;
        },
    };
}
exports.default = dynamicImport;
async function globFiles(
/** ImportExpression */
node, code, importer, resolve, extensions, depth = true) {
    let files;
    let resolved;
    let normally;
    const PAHT_FILL = '####/';
    const EXT_FILL = '.extension';
    let glob;
    let globRaw;
    glob = await (0, dynamic_import_to_glob_1.dynamicImportToGlob)(node.source, code.slice(node.start, node.end), async (raw) => {
        globRaw = raw;
        resolved = await resolve.tryResolve(raw, importer);
        if (resolved) {
            raw = resolved.import.resolved;
        }
        if (!path_1.default.extname(raw)) {
            // Bypass extension restrict
            raw = raw + EXT_FILL;
        }
        if (/^\.\/\*\.\w+$/.test(raw)) {
            // Bypass ownDirectoryStarExtension (./*.ext)
            raw = raw.replace('./*', `./${PAHT_FILL}*`);
        }
        return raw;
    });
    if (!glob) {
        if (utils_1.normallyImporteeRE.test(globRaw)) {
            normally = globRaw;
            return { normally };
        }
        return;
    }
    glob = (0, utils_1.tryFixGlobSlash)(glob);
    depth !== false && (glob = (0, utils_1.toDepthGlob)(glob));
    glob.includes(PAHT_FILL) && (glob = glob.replace(PAHT_FILL, ''));
    glob.endsWith(EXT_FILL) && (glob = glob.replace(EXT_FILL, ''));
    const fileGlob = path_1.default.extname(glob)
        ? glob
        // If not ext is not specified, fill necessary extensions
        // e.g.
        //   `./foo/*` -> `./foo/*.{js,ts,vue,...}`
        : glob + `.{${extensions.map(e => e.replace(/^\./, '')).join(',')}}`;
    files = fast_glob_1.default
        .sync(fileGlob, { cwd: /* ðŸš§-â‘  */ path_1.default.dirname(importer) })
        .map(file => !file.startsWith('.') ? /* ðŸš§-â‘¡ */ `./${file}` : file);
    return { files, resolved };
}
function generateDynamicImportRuntime(maps, name) {
    const groups = Object
        .entries(maps)
        .map(([localFile, importeeList]) => importeeList
        .map(importee => `    case '${importee}':`)
        .concat(`      return import('${localFile}');`));
    return `function ${name}(path) {
  switch (path) {
${groups.flat().join('\n')}
    default: return new Promise(function(resolve, reject) {
      (typeof queueMicrotask === 'function' ? queueMicrotask : setTimeout)(
        reject.bind(null, new Error("Unknown variable dynamic import: " + path))
      );
    })
  }
}`;
}
