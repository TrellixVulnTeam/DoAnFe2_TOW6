"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mappingPath = exports.toDepthGlob = exports.tryFixGlobSlash = exports.MagicString = exports.simpleWalk = exports.hasDynamicImport = exports.cleanUrl = exports.KNOWN_SFC_EXTENSIONS = exports.JS_EXTENSIONS = exports.deepImportRE = exports.bareImportRE = exports.hashRE = exports.queryRE = exports.singlelineCommentsRE = exports.multilineCommentsRE = exports.viteIgnoreRE = exports.normallyImporteeRE = exports.dynamicImportRE = void 0;
const path_1 = __importDefault(require("path"));
// ------------------------------------------------- RegExp
exports.dynamicImportRE = /\bimport[\s\r\n]*?\(/;
// this is probably less accurate
exports.normallyImporteeRE = /^\.{1,2}\/[.-/\w]+(\.\w+)$/;
exports.viteIgnoreRE = /\/\*\s*@vite-ignore\s*\*\//;
exports.multilineCommentsRE = /\/\*(.|[\r\n])*?\*\//g;
exports.singlelineCommentsRE = /\/\/.*/g;
exports.queryRE = /\?.*$/s;
exports.hashRE = /#.*$/s;
exports.bareImportRE = /^[\w@](?!.*:\/\/)/;
exports.deepImportRE = /^([^@][^/]*)\/|^(@[^/]+\/[^/]+)\//;
// ------------------------------------------------- const
exports.JS_EXTENSIONS = [
    '.mjs',
    '.js',
    '.ts',
    '.jsx',
    '.tsx',
    '.cjs'
];
exports.KNOWN_SFC_EXTENSIONS = [
    '.vue',
    '.svelte',
];
// ------------------------------------------------- function
function cleanUrl(url) {
    return url.replace(exports.hashRE, '').replace(exports.queryRE, '');
}
exports.cleanUrl = cleanUrl;
function hasDynamicImport(code) {
    code = code
        .replace(exports.singlelineCommentsRE, '')
        .replace(exports.multilineCommentsRE, '');
    return exports.dynamicImportRE.test(code);
}
exports.hasDynamicImport = hasDynamicImport;
async function simpleWalk(ast, visitors) {
    var _a;
    if (!ast)
        return;
    if (Array.isArray(ast)) {
        for (const element of ast) {
            await simpleWalk(element, visitors);
        }
    }
    else {
        for (const key of Object.keys(ast)) {
            await (typeof ast[key] === 'object' && simpleWalk(ast[key], visitors));
        }
    }
    await ((_a = visitors[ast.type]) === null || _a === void 0 ? void 0 : _a.call(visitors, ast));
}
exports.simpleWalk = simpleWalk;
class MagicString {
    constructor(str) {
        this.str = str;
        this.starts = '';
        this.ends = '';
    }
    append(content) {
        this.ends += content;
        return this;
    }
    prepend(content) {
        this.starts = content + this.starts;
        return this;
    }
    overwrite(start, end, content) {
        if (end < start) {
            throw new Error(`"end" con't be less than "start".`);
        }
        if (!this.overwrites) {
            this.overwrites = [];
        }
        this.overwrites.push({ loc: [start, end], content });
        return this;
    }
    toString() {
        let str = this.str;
        if (this.overwrites) {
            const arr = [...this.overwrites].sort((a, b) => b.loc[0] - a.loc[0]);
            for (const { loc: [start, end], content } of arr) {
                // TODO: check start or end overlap
                str = str.slice(0, start) + content + str.slice(end);
            }
        }
        return this.starts + str + this.ends;
    }
}
exports.MagicString = MagicString;
// In some cases, glob may not be available
// e.g. (fill necessary slash)
//   `./foo*` -> `./foo/*`
//   `./foo*.js` -> `./foo/*.js`
function tryFixGlobSlash(glob) {
    return glob.replace(/(?<![\*\/])(\*)/g, '/$1');
}
exports.tryFixGlobSlash = tryFixGlobSlash;
// Match as far as possible
// e.g.
//   `./foo/*` -> `./foo/**/*`
//   `./foo/*.js` -> `./foo/**/*.js`
function toDepthGlob(glob) {
    return glob.replace(/^(.*)\/\*(?!\*)/, '$1/**/*');
}
exports.toDepthGlob = toDepthGlob;
/**
 * e.g. `src/foo/index.js` and has alias(@)
 *
 * ```
 * const maps = {
 *   './foo/index.js': [
 *     '@/foo',
 *     '@/foo/index',
 *     '@/foo/index.js',
 *   ],
 * }
 * ```
 */
function mappingPath(paths, resolved) {
    const maps = {};
    for (const p of paths) {
        let importee = p;
        if (resolved) {
            const static1 = resolved.import.importee.slice(0, resolved.import.importee.indexOf('*'));
            const static2 = resolved.import.resolved.slice(0, resolved.import.resolved.indexOf('*'));
            // Recovery alias `./views/*` -> `@/views/*`
            importee = p.replace(static2, static1);
        }
        const ext = path_1.default.extname(importee);
        maps[p] = [
            // @/foo
            importee.endsWith(`/index${ext}`) && importee.replace(`/index${ext}`, ''),
            // @/foo/index
            importee.replace(ext, ''),
            // @/foo/index.js
            importee,
        ].filter(Boolean);
    }
    return maps;
}
exports.mappingPath = mappingPath;
