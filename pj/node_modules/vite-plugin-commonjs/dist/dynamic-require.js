"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DynaimcRequire = void 0;
const path_1 = __importDefault(require("path"));
const vite_plugin_dynamic_import_1 = require("vite-plugin-dynamic-import");
const fast_glob_1 = __importDefault(require("fast-glob"));
const { normallyImporteeRE, tryFixGlobSlash, toDepthGlob, mappingPath, } = vite_plugin_dynamic_import_1.utils;
class DynaimcRequire {
    constructor(config, options, resolve = new vite_plugin_dynamic_import_1.Resolve(config)) {
        this.config = config;
        this.options = options;
        this.resolve = resolve;
    }
    async generateRuntime(analyzed) {
        var _a;
        const options = this.options;
        const id = analyzed.id;
        let counter = 0;
        const importCache = new Map( /* import-id, import-name */);
        const records = [];
        for (const req of analyzed.require) {
            const { node, dynamic } = req;
            if (dynamic !== 'dynamic')
                continue;
            const globResult = await globFiles(node, analyzed.code, analyzed.id, this.resolve, options.extensions, ((_a = options.dynamic) === null || _a === void 0 ? void 0 : _a.loose) !== false);
            if (!globResult)
                continue;
            const record = { node };
            let { files, resolved, normally } = globResult;
            // skip itself
            files = files.filter(f => path_1.default.join(path_1.default.dirname(id), f) !== id);
            // execute the Options.onFiles
            options.onFiles && (files = options.onFiles(files, id) || files);
            if (normally) {
                record.normally = normally;
                continue;
            }
            if (!(files === null || files === void 0 ? void 0 : files.length))
                continue;
            const maps = mappingPath(files, resolved);
            let counter2 = 0;
            record.dynaimc = {
                importee: [],
                runtimeName: `__matchRequireRuntime${counter}__`,
                runtimeFn: '', // to be immediately set
            };
            const cases = [];
            for (const [localFile, importeeList] of Object.entries(maps)) {
                let dynamic_require2import = importCache.get(localFile);
                if (!dynamic_require2import) {
                    importCache.set(localFile, dynamic_require2import = `__dynamic_require2import__${counter}__${counter2++}`);
                }
                record.dynaimc.importee.push(`import * as ${dynamic_require2import} from '${localFile}'`);
                cases.push(importeeList
                    .map(importee => `    case '${importee}':`)
                    .concat(`      return ${dynamic_require2import};`)
                    .join('\n'));
            }
            record.dynaimc.runtimeFn = `function ${record.dynaimc.runtimeName}(path) {
  switch(path) {
${cases.join('\n')}
    default: throw new Error("Cann't found module: " + path);
  }
}`;
            records.push(record);
        }
        return records.length ? records : null;
    }
}
exports.DynaimcRequire = DynaimcRequire;
async function globFiles(
/** ImportExpression */
node, code, importer, resolve, extensions, loose = true) {
    let files;
    let resolved;
    let normally;
    const PAHT_FILL = '####/';
    const EXT_FILL = '.extension';
    let glob;
    let globRaw;
    glob = await (0, vite_plugin_dynamic_import_1.dynamicImportToGlob)(node.arguments[0], code.slice(node.start, node.end), async (raw) => {
        globRaw = raw;
        resolved = await resolve.tryResolve(raw, importer);
        if (resolved) {
            raw = resolved.import.resolved;
        }
        if (!path_1.default.extname(raw)) {
            // Bypass extension restrict
            raw = raw + EXT_FILL;
        }
        if (/^\.\/\*\.\w+$/.test(raw)) {
            // Bypass ownDirectoryStarExtension (./*.ext)
            raw = raw.replace('./*', `./${PAHT_FILL}*`);
        }
        return raw;
    });
    if (!glob) {
        if (normallyImporteeRE.test(globRaw)) {
            normally = globRaw;
            return { normally };
        }
        return;
    }
    glob = tryFixGlobSlash(glob);
    loose !== false && (glob = toDepthGlob(glob));
    glob.includes(PAHT_FILL) && (glob = glob.replace(PAHT_FILL, ''));
    glob.endsWith(EXT_FILL) && (glob = glob.replace(EXT_FILL, ''));
    const fileGlob = path_1.default.extname(glob)
        ? glob
        // If not ext is not specified, fill necessary extensions
        // e.g.
        //   `./foo/*` -> `./foo/*.{js,ts,vue,...}`
        : glob + `.{${extensions.map(e => e.replace(/^\./, '')).join(',')}}`;
    files = fast_glob_1.default
        .sync(fileGlob, { cwd: /* ğŸš§-â‘  */ path_1.default.dirname(importer) })
        .map(file => !file.startsWith('.') ? /* ğŸš§-â‘¡ */ `./${file}` : file);
    return { files, resolved };
}
