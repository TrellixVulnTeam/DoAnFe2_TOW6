import {
  isSupported,
  logEvent,
  setAnalyticsCollectionEnabled,
  setCurrentScreen,
  setUserId,
  setUserProperties,
  settings
} from "./chunk-JF3DE4CN.js";
import {
  ActionCodeOperation,
  AuthCredential,
  AuthEventManager,
  EmailAuthProvider,
  FacebookAuthProvider,
  GithubAuthProvider,
  GoogleAuthProvider,
  OAuthCredential,
  OAuthProvider,
  PhoneAuthProvider,
  PhoneMultiFactorGenerator,
  ProviderId,
  RecaptchaVerifier,
  SAMLAuthCredential,
  SAMLAuthProvider,
  TwitterAuthProvider,
  _assert,
  _castAuth,
  _clearRedirectOutcomes,
  _createError,
  _fail,
  _generateEventId,
  _getInstance,
  _getProjectConfig,
  _getRedirectResult,
  _getRedirectUrl,
  _isAndroid,
  _isIOS,
  _isIOS7Or8,
  _overrideRedirectResult,
  _persistenceKeyName,
  applyActionCode,
  browserLocalPersistence,
  browserPopupRedirectResolver,
  browserSessionPersistence,
  checkActionCode,
  confirmPasswordReset,
  connectAuthEmulator,
  createUserWithEmailAndPassword,
  debugAssert,
  debugErrorMap,
  fetchSignInMethodsForEmail,
  getAdditionalUserInfo,
  getMultiFactorResolver,
  getRedirectResult,
  inMemoryPersistence,
  indexedDBLocalPersistence,
  isSignInWithEmailLink,
  linkWithCredential,
  linkWithPhoneNumber,
  linkWithPopup,
  linkWithRedirect,
  multiFactor,
  reauthenticateWithCredential,
  reauthenticateWithPhoneNumber,
  reauthenticateWithPopup,
  reauthenticateWithRedirect,
  sendEmailVerification,
  sendPasswordResetEmail,
  sendSignInLinkToEmail,
  signInAnonymously,
  signInWithCredential,
  signInWithCustomToken,
  signInWithEmailAndPassword,
  signInWithEmailLink,
  signInWithPhoneNumber,
  signInWithPopup,
  signInWithRedirect,
  unlink,
  updateEmail,
  updatePassword,
  updatePhoneNumber,
  updateProfile,
  verifyBeforeUpdateEmail,
  verifyPasswordResetCode
} from "./chunk-ABSNGHH2.js";
import {
  OnDisconnect,
  QueryImpl,
  QueryParams,
  ReferenceImpl,
  child,
  connectDatabaseEmulator,
  enableLogging,
  endAt,
  endBefore,
  equalTo,
  forceLongPolling,
  forceWebSockets,
  get,
  goOffline,
  goOnline,
  increment,
  limitToFirst,
  limitToLast,
  off,
  onChildAdded,
  onChildChanged,
  onChildMoved,
  onChildRemoved,
  onValue,
  orderByChild,
  orderByKey,
  orderByPriority,
  orderByValue,
  push,
  query,
  ref,
  refFromURL,
  remove,
  repoManagerDatabaseFromApp,
  runTransaction,
  serverTimestamp,
  set,
  setPriority,
  setSDKVersion,
  setWithPriority,
  startAfter,
  startAt,
  update,
  validatePathString,
  validateWritablePath
} from "./chunk-7XURHK2S.js";
import {
  Component,
  ComponentContainer,
  DEFAULT_ENTRY_NAME,
  Deferred,
  ErrorFactory,
  FirebaseError,
  LogLevel,
  Logger,
  Provider,
  SDK_VERSION,
  _addComponent,
  _addOrOverwriteComponent,
  _getProvider,
  _registerComponent,
  areCookiesEnabled,
  base64,
  calculateBackoffMillis,
  contains,
  createMockUserToken,
  createSubscribe,
  deepExtend,
  deleteApp,
  deleteDB,
  errorPrefix,
  getApp,
  getGlobal,
  getModularInstance,
  getUA,
  index_esm2017_exports,
  initializeApp,
  isBrowser,
  isBrowserExtension,
  isElectron,
  isIE,
  isIndexedDBAvailable,
  isMobileCordova,
  isNode,
  isReactNative,
  isSafari,
  isUWP,
  issuedAtTime,
  onLog,
  openDB,
  querystringDecode,
  registerVersion,
  setLogLevel,
  validateArgCount,
  validateCallback,
  validateContextObject,
  validateIndexedDBOpenable
} from "./chunk-VF6VYLHB.js";
import "./chunk-JC7OWRM7.js";

// node_modules/@firebase/app-compat/dist/esm/index.esm2017.js
var FirebaseAppImpl = class {
  constructor(_delegate, firebase2) {
    this._delegate = _delegate;
    this.firebase = firebase2;
    _addComponent(_delegate, new Component("app-compat", () => this, "PUBLIC"));
    this.container = _delegate.container;
  }
  get automaticDataCollectionEnabled() {
    return this._delegate.automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(val) {
    this._delegate.automaticDataCollectionEnabled = val;
  }
  get name() {
    return this._delegate.name;
  }
  get options() {
    return this._delegate.options;
  }
  delete() {
    return new Promise((resolve) => {
      this._delegate.checkDestroyed();
      resolve();
    }).then(() => {
      this.firebase.INTERNAL.removeApp(this.name);
      return deleteApp(this._delegate);
    });
  }
  _getService(name19, instanceIdentifier = DEFAULT_ENTRY_NAME) {
    var _a2;
    this._delegate.checkDestroyed();
    const provider = this._delegate.container.getProvider(name19);
    if (!provider.isInitialized() && ((_a2 = provider.getComponent()) === null || _a2 === void 0 ? void 0 : _a2.instantiationMode) === "EXPLICIT") {
      provider.initialize();
    }
    return provider.getImmediate({
      identifier: instanceIdentifier
    });
  }
  _removeServiceInstance(name19, instanceIdentifier = DEFAULT_ENTRY_NAME) {
    this._delegate.container.getProvider(name19).clearInstance(instanceIdentifier);
  }
  _addComponent(component) {
    _addComponent(this._delegate, component);
  }
  _addOrOverwriteComponent(component) {
    _addOrOverwriteComponent(this._delegate, component);
  }
  toJSON() {
    return {
      name: this.name,
      automaticDataCollectionEnabled: this.automaticDataCollectionEnabled,
      options: this.options
    };
  }
};
var ERRORS = {
  ["no-app"]: "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()",
  ["invalid-app-argument"]: "firebase.{$appName}() takes either no argument or a Firebase App instance."
};
var ERROR_FACTORY = new ErrorFactory("app-compat", "Firebase", ERRORS);
function createFirebaseNamespaceCore(firebaseAppImpl) {
  const apps = {};
  const namespace = {
    __esModule: true,
    initializeApp: initializeAppCompat,
    app,
    registerVersion,
    setLogLevel,
    onLog,
    apps: null,
    SDK_VERSION,
    INTERNAL: {
      registerComponent: registerComponentCompat,
      removeApp,
      useAsService,
      modularAPIs: index_esm2017_exports
    }
  };
  namespace["default"] = namespace;
  Object.defineProperty(namespace, "apps", {
    get: getApps
  });
  function removeApp(name19) {
    delete apps[name19];
  }
  function app(name19) {
    name19 = name19 || DEFAULT_ENTRY_NAME;
    if (!contains(apps, name19)) {
      throw ERROR_FACTORY.create("no-app", { appName: name19 });
    }
    return apps[name19];
  }
  app["App"] = firebaseAppImpl;
  function initializeAppCompat(options, rawConfig = {}) {
    const app2 = initializeApp(options, rawConfig);
    if (contains(apps, app2.name)) {
      return apps[app2.name];
    }
    const appCompat = new firebaseAppImpl(app2, namespace);
    apps[app2.name] = appCompat;
    return appCompat;
  }
  function getApps() {
    return Object.keys(apps).map((name19) => apps[name19]);
  }
  function registerComponentCompat(component) {
    const componentName = component.name;
    const componentNameWithoutCompat = componentName.replace("-compat", "");
    if (_registerComponent(component) && component.type === "PUBLIC") {
      const serviceNamespace = (appArg = app()) => {
        if (typeof appArg[componentNameWithoutCompat] !== "function") {
          throw ERROR_FACTORY.create("invalid-app-argument", {
            appName: componentName
          });
        }
        return appArg[componentNameWithoutCompat]();
      };
      if (component.serviceProps !== void 0) {
        deepExtend(serviceNamespace, component.serviceProps);
      }
      namespace[componentNameWithoutCompat] = serviceNamespace;
      firebaseAppImpl.prototype[componentNameWithoutCompat] = function(...args) {
        const serviceFxn = this._getService.bind(this, componentName);
        return serviceFxn.apply(this, component.multipleInstances ? args : []);
      };
    }
    return component.type === "PUBLIC" ? namespace[componentNameWithoutCompat] : null;
  }
  function useAsService(app2, name19) {
    if (name19 === "serverAuth") {
      return null;
    }
    const useService = name19;
    return useService;
  }
  return namespace;
}
function createFirebaseNamespace() {
  const namespace = createFirebaseNamespaceCore(FirebaseAppImpl);
  namespace.INTERNAL = Object.assign(Object.assign({}, namespace.INTERNAL), {
    createFirebaseNamespace,
    extendNamespace,
    createSubscribe,
    ErrorFactory,
    deepExtend
  });
  function extendNamespace(props) {
    deepExtend(namespace, props);
  }
  return namespace;
}
var firebase$1 = createFirebaseNamespace();
var logger = new Logger("@firebase/app-compat");
var name = "@firebase/app-compat";
var version = "0.1.27";
function registerCoreComponents(variant) {
  registerVersion(name, version, variant);
}
if (isBrowser() && self.firebase !== void 0) {
  logger.warn(`
    Warning: Firebase is already defined in the global scope. Please make sure
    Firebase library is only loaded once.
  `);
  const sdkVersion = self.firebase.SDK_VERSION;
  if (sdkVersion && sdkVersion.indexOf("LITE") >= 0) {
    logger.warn(`
    Warning: You are trying to load Firebase while using Firebase Performance standalone script.
    You should load Firebase Performance with this instance of Firebase to avoid loading duplicate code.
    `);
  }
}
var firebase = firebase$1;
registerCoreComponents();

// node_modules/@firebase/analytics-compat/dist/esm/index.esm2017.js
var name2 = "@firebase/analytics-compat";
var version2 = "0.1.11";
var AnalyticsService = class {
  constructor(app, _delegate) {
    this.app = app;
    this._delegate = _delegate;
  }
  logEvent(eventName, eventParams, options) {
    logEvent(this._delegate, eventName, eventParams, options);
  }
  setCurrentScreen(screenName, options) {
    setCurrentScreen(this._delegate, screenName, options);
  }
  setUserId(id2, options) {
    setUserId(this._delegate, id2, options);
  }
  setUserProperties(properties, options) {
    setUserProperties(this._delegate, properties, options);
  }
  setAnalyticsCollectionEnabled(enabled) {
    setAnalyticsCollectionEnabled(this._delegate, enabled);
  }
};
var EventName;
(function(EventName2) {
  EventName2["ADD_SHIPPING_INFO"] = "add_shipping_info";
  EventName2["ADD_PAYMENT_INFO"] = "add_payment_info";
  EventName2["ADD_TO_CART"] = "add_to_cart";
  EventName2["ADD_TO_WISHLIST"] = "add_to_wishlist";
  EventName2["BEGIN_CHECKOUT"] = "begin_checkout";
  EventName2["CHECKOUT_PROGRESS"] = "checkout_progress";
  EventName2["EXCEPTION"] = "exception";
  EventName2["GENERATE_LEAD"] = "generate_lead";
  EventName2["LOGIN"] = "login";
  EventName2["PAGE_VIEW"] = "page_view";
  EventName2["PURCHASE"] = "purchase";
  EventName2["REFUND"] = "refund";
  EventName2["REMOVE_FROM_CART"] = "remove_from_cart";
  EventName2["SCREEN_VIEW"] = "screen_view";
  EventName2["SEARCH"] = "search";
  EventName2["SELECT_CONTENT"] = "select_content";
  EventName2["SELECT_ITEM"] = "select_item";
  EventName2["SELECT_PROMOTION"] = "select_promotion";
  EventName2["SET_CHECKOUT_OPTION"] = "set_checkout_option";
  EventName2["SHARE"] = "share";
  EventName2["SIGN_UP"] = "sign_up";
  EventName2["TIMING_COMPLETE"] = "timing_complete";
  EventName2["VIEW_CART"] = "view_cart";
  EventName2["VIEW_ITEM"] = "view_item";
  EventName2["VIEW_ITEM_LIST"] = "view_item_list";
  EventName2["VIEW_PROMOTION"] = "view_promotion";
  EventName2["VIEW_SEARCH_RESULTS"] = "view_search_results";
})(EventName || (EventName = {}));
var factory = (container) => {
  const app = container.getProvider("app-compat").getImmediate();
  const analyticsServiceExp = container.getProvider("analytics").getImmediate();
  return new AnalyticsService(app, analyticsServiceExp);
};
function registerAnalytics() {
  const namespaceExports = {
    Analytics: AnalyticsService,
    settings,
    isSupported,
    EventName
  };
  firebase.INTERNAL.registerComponent(new Component("analytics-compat", factory, "PUBLIC").setServiceProps(namespaceExports).setMultipleInstances(true));
}
registerAnalytics();
firebase.registerVersion(name2, version2);

// node_modules/@firebase/app-check/dist/esm/index.esm2017.js
var APP_CHECK_STATES = /* @__PURE__ */ new Map();
var DEFAULT_STATE = {
  activated: false,
  tokenObservers: []
};
var DEBUG_STATE = {
  initialized: false,
  enabled: false
};
function getState(app) {
  return APP_CHECK_STATES.get(app) || DEFAULT_STATE;
}
function setState(app, state) {
  APP_CHECK_STATES.set(app, state);
}
function getDebugState() {
  return DEBUG_STATE;
}
var BASE_ENDPOINT = "https://content-firebaseappcheck.googleapis.com/v1";
var EXCHANGE_RECAPTCHA_TOKEN_METHOD = "exchangeRecaptchaV3Token";
var EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD = "exchangeRecaptchaEnterpriseToken";
var EXCHANGE_DEBUG_TOKEN_METHOD = "exchangeDebugToken";
var TOKEN_REFRESH_TIME = {
  OFFSET_DURATION: 5 * 60 * 1e3,
  RETRIAL_MIN_WAIT: 30 * 1e3,
  RETRIAL_MAX_WAIT: 16 * 60 * 1e3
};
var ONE_DAY = 24 * 60 * 60 * 1e3;
var Refresher = class {
  constructor(operation, retryPolicy, getWaitDuration, lowerBound, upperBound) {
    this.operation = operation;
    this.retryPolicy = retryPolicy;
    this.getWaitDuration = getWaitDuration;
    this.lowerBound = lowerBound;
    this.upperBound = upperBound;
    this.pending = null;
    this.nextErrorWaitInterval = lowerBound;
    if (lowerBound > upperBound) {
      throw new Error("Proactive refresh lower bound greater than upper bound!");
    }
  }
  start() {
    this.nextErrorWaitInterval = this.lowerBound;
    this.process(true).catch(() => {
    });
  }
  stop() {
    if (this.pending) {
      this.pending.reject("cancelled");
      this.pending = null;
    }
  }
  isRunning() {
    return !!this.pending;
  }
  async process(hasSucceeded) {
    this.stop();
    try {
      this.pending = new Deferred();
      await sleep(this.getNextRun(hasSucceeded));
      this.pending.resolve();
      await this.pending.promise;
      this.pending = new Deferred();
      await this.operation();
      this.pending.resolve();
      await this.pending.promise;
      this.process(true).catch(() => {
      });
    } catch (error) {
      if (this.retryPolicy(error)) {
        this.process(false).catch(() => {
        });
      } else {
        this.stop();
      }
    }
  }
  getNextRun(hasSucceeded) {
    if (hasSucceeded) {
      this.nextErrorWaitInterval = this.lowerBound;
      return this.getWaitDuration();
    } else {
      const currentErrorWaitInterval = this.nextErrorWaitInterval;
      this.nextErrorWaitInterval *= 2;
      if (this.nextErrorWaitInterval > this.upperBound) {
        this.nextErrorWaitInterval = this.upperBound;
      }
      return currentErrorWaitInterval;
    }
  }
};
function sleep(ms2) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms2);
  });
}
var ERRORS2 = {
  ["already-initialized"]: "You have already called initializeAppCheck() for FirebaseApp {$appName} with different options. To avoid this error, call initializeAppCheck() with the same options as when it was originally called. This will return the already initialized instance.",
  ["use-before-activation"]: "App Check is being used before initializeAppCheck() is called for FirebaseApp {$appName}. Call initializeAppCheck() before instantiating other Firebase services.",
  ["fetch-network-error"]: "Fetch failed to connect to a network. Check Internet connection. Original error: {$originalErrorMessage}.",
  ["fetch-parse-error"]: "Fetch client could not parse response. Original error: {$originalErrorMessage}.",
  ["fetch-status-error"]: "Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.",
  ["storage-open"]: "Error thrown when opening storage. Original error: {$originalErrorMessage}.",
  ["storage-get"]: "Error thrown when reading from storage. Original error: {$originalErrorMessage}.",
  ["storage-set"]: "Error thrown when writing to storage. Original error: {$originalErrorMessage}.",
  ["recaptcha-error"]: "ReCAPTCHA error.",
  ["throttled"]: `Requests throttled due to {$httpStatus} error. Attempts allowed again after {$time}`
};
var ERROR_FACTORY2 = new ErrorFactory("appCheck", "AppCheck", ERRORS2);
function getRecaptcha(isEnterprise = false) {
  var _a2;
  if (isEnterprise) {
    return (_a2 = self.grecaptcha) === null || _a2 === void 0 ? void 0 : _a2.enterprise;
  }
  return self.grecaptcha;
}
function ensureActivated(app) {
  if (!getState(app).activated) {
    throw ERROR_FACTORY2.create("use-before-activation", {
      appName: app.name
    });
  }
}
function uuidv4() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0, v2 = c === "x" ? r : r & 3 | 8;
    return v2.toString(16);
  });
}
function getDurationString(durationInMillis) {
  const totalSeconds = Math.round(durationInMillis / 1e3);
  const days = Math.floor(totalSeconds / (3600 * 24));
  const hours = Math.floor((totalSeconds - days * 3600 * 24) / 3600);
  const minutes = Math.floor((totalSeconds - days * 3600 * 24 - hours * 3600) / 60);
  const seconds = totalSeconds - days * 3600 * 24 - hours * 3600 - minutes * 60;
  let result = "";
  if (days) {
    result += pad(days) + "d:";
  }
  if (hours) {
    result += pad(hours) + "h:";
  }
  result += pad(minutes) + "m:" + pad(seconds) + "s";
  return result;
}
function pad(value) {
  if (value === 0) {
    return "00";
  }
  return value >= 10 ? value.toString() : "0" + value;
}
async function exchangeToken({ url, body }, heartbeatServiceProvider) {
  var _a2, _b;
  const headers = {
    "Content-Type": "application/json"
  };
  const heartbeatService = heartbeatServiceProvider.getImmediate({
    optional: true
  });
  if (heartbeatService) {
    const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();
    if (heartbeatsHeader) {
      headers["X-Firebase-Client"] = heartbeatsHeader;
    }
  }
  const options = {
    method: "POST",
    body: JSON.stringify(body),
    headers
  };
  let response;
  try {
    response = await fetch(url, options);
  } catch (originalError) {
    throw ERROR_FACTORY2.create("fetch-network-error", {
      originalErrorMessage: (_a2 = originalError) === null || _a2 === void 0 ? void 0 : _a2.message
    });
  }
  if (response.status !== 200) {
    throw ERROR_FACTORY2.create("fetch-status-error", {
      httpStatus: response.status
    });
  }
  let responseBody;
  try {
    responseBody = await response.json();
  } catch (originalError) {
    throw ERROR_FACTORY2.create("fetch-parse-error", {
      originalErrorMessage: (_b = originalError) === null || _b === void 0 ? void 0 : _b.message
    });
  }
  const match = responseBody.ttl.match(/^([\d.]+)(s)$/);
  if (!match || !match[2] || isNaN(Number(match[1]))) {
    throw ERROR_FACTORY2.create("fetch-parse-error", {
      originalErrorMessage: `ttl field (timeToLive) is not in standard Protobuf Duration format: ${responseBody.ttl}`
    });
  }
  const timeToLiveAsNumber = Number(match[1]) * 1e3;
  const now = Date.now();
  return {
    token: responseBody.token,
    expireTimeMillis: now + timeToLiveAsNumber,
    issuedAtTimeMillis: now
  };
}
function getExchangeRecaptchaV3TokenRequest(app, reCAPTCHAToken) {
  const { projectId, appId, apiKey } = app.options;
  return {
    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_TOKEN_METHOD}?key=${apiKey}`,
    body: {
      "recaptcha_v3_token": reCAPTCHAToken
    }
  };
}
function getExchangeRecaptchaEnterpriseTokenRequest(app, reCAPTCHAToken) {
  const { projectId, appId, apiKey } = app.options;
  return {
    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD}?key=${apiKey}`,
    body: {
      "recaptcha_enterprise_token": reCAPTCHAToken
    }
  };
}
function getExchangeDebugTokenRequest(app, debugToken) {
  const { projectId, appId, apiKey } = app.options;
  return {
    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_DEBUG_TOKEN_METHOD}?key=${apiKey}`,
    body: {
      debug_token: debugToken
    }
  };
}
var DB_NAME = "firebase-app-check-database";
var DB_VERSION = 1;
var STORE_NAME = "firebase-app-check-store";
var DEBUG_TOKEN_KEY = "debug-token";
var dbPromise = null;
function getDBPromise() {
  if (dbPromise) {
    return dbPromise;
  }
  dbPromise = new Promise((resolve, reject) => {
    var _a2;
    try {
      const request = indexedDB.open(DB_NAME, DB_VERSION);
      request.onsuccess = (event) => {
        resolve(event.target.result);
      };
      request.onerror = (event) => {
        var _a3;
        reject(ERROR_FACTORY2.create("storage-open", {
          originalErrorMessage: (_a3 = event.target.error) === null || _a3 === void 0 ? void 0 : _a3.message
        }));
      };
      request.onupgradeneeded = (event) => {
        const db2 = event.target.result;
        switch (event.oldVersion) {
          case 0:
            db2.createObjectStore(STORE_NAME, {
              keyPath: "compositeKey"
            });
        }
      };
    } catch (e) {
      reject(ERROR_FACTORY2.create("storage-open", {
        originalErrorMessage: (_a2 = e) === null || _a2 === void 0 ? void 0 : _a2.message
      }));
    }
  });
  return dbPromise;
}
function readTokenFromIndexedDB(app) {
  return read(computeKey(app));
}
function writeTokenToIndexedDB(app, token) {
  return write(computeKey(app), token);
}
function writeDebugTokenToIndexedDB(token) {
  return write(DEBUG_TOKEN_KEY, token);
}
function readDebugTokenFromIndexedDB() {
  return read(DEBUG_TOKEN_KEY);
}
async function write(key, value) {
  const db2 = await getDBPromise();
  const transaction = db2.transaction(STORE_NAME, "readwrite");
  const store = transaction.objectStore(STORE_NAME);
  const request = store.put({
    compositeKey: key,
    value
  });
  return new Promise((resolve, reject) => {
    request.onsuccess = (_event) => {
      resolve();
    };
    transaction.onerror = (event) => {
      var _a2;
      reject(ERROR_FACTORY2.create("storage-set", {
        originalErrorMessage: (_a2 = event.target.error) === null || _a2 === void 0 ? void 0 : _a2.message
      }));
    };
  });
}
async function read(key) {
  const db2 = await getDBPromise();
  const transaction = db2.transaction(STORE_NAME, "readonly");
  const store = transaction.objectStore(STORE_NAME);
  const request = store.get(key);
  return new Promise((resolve, reject) => {
    request.onsuccess = (event) => {
      const result = event.target.result;
      if (result) {
        resolve(result.value);
      } else {
        resolve(void 0);
      }
    };
    transaction.onerror = (event) => {
      var _a2;
      reject(ERROR_FACTORY2.create("storage-get", {
        originalErrorMessage: (_a2 = event.target.error) === null || _a2 === void 0 ? void 0 : _a2.message
      }));
    };
  });
}
function computeKey(app) {
  return `${app.options.appId}-${app.name}`;
}
var logger2 = new Logger("@firebase/app-check");
async function readTokenFromStorage(app) {
  if (isIndexedDBAvailable()) {
    let token = void 0;
    try {
      token = await readTokenFromIndexedDB(app);
    } catch (e) {
      logger2.warn(`Failed to read token from IndexedDB. Error: ${e}`);
    }
    return token;
  }
  return void 0;
}
function writeTokenToStorage(app, token) {
  if (isIndexedDBAvailable()) {
    return writeTokenToIndexedDB(app, token).catch((e) => {
      logger2.warn(`Failed to write token to IndexedDB. Error: ${e}`);
    });
  }
  return Promise.resolve();
}
async function readOrCreateDebugTokenFromStorage() {
  let existingDebugToken = void 0;
  try {
    existingDebugToken = await readDebugTokenFromIndexedDB();
  } catch (_e2) {
  }
  if (!existingDebugToken) {
    const newToken = uuidv4();
    writeDebugTokenToIndexedDB(newToken).catch((e) => logger2.warn(`Failed to persist debug token to IndexedDB. Error: ${e}`));
    return newToken;
  } else {
    return existingDebugToken;
  }
}
function isDebugMode() {
  const debugState = getDebugState();
  return debugState.enabled;
}
async function getDebugToken() {
  const state = getDebugState();
  if (state.enabled && state.token) {
    return state.token.promise;
  } else {
    throw Error(`
            Can't get debug token in production mode.
        `);
  }
}
function initializeDebugMode() {
  const globals = getGlobal();
  const debugState = getDebugState();
  debugState.initialized = true;
  if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== "string" && globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== true) {
    return;
  }
  debugState.enabled = true;
  const deferredToken = new Deferred();
  debugState.token = deferredToken;
  if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN === "string") {
    deferredToken.resolve(globals.FIREBASE_APPCHECK_DEBUG_TOKEN);
  } else {
    deferredToken.resolve(readOrCreateDebugTokenFromStorage());
  }
}
var defaultTokenErrorData = { error: "UNKNOWN_ERROR" };
function formatDummyToken(tokenErrorData) {
  return base64.encodeString(JSON.stringify(tokenErrorData), false);
}
async function getToken$2(appCheck, forceRefresh = false) {
  const app = appCheck.app;
  ensureActivated(app);
  const state = getState(app);
  let token = state.token;
  let error = void 0;
  if (!token) {
    const cachedToken = await state.cachedTokenPromise;
    if (cachedToken && isValid(cachedToken)) {
      token = cachedToken;
    }
  }
  if (!forceRefresh && token && isValid(token)) {
    return {
      token: token.token
    };
  }
  let shouldCallListeners = false;
  if (isDebugMode()) {
    if (!state.exchangeTokenPromise) {
      state.exchangeTokenPromise = exchangeToken(getExchangeDebugTokenRequest(app, await getDebugToken()), appCheck.heartbeatServiceProvider).then((token2) => {
        state.exchangeTokenPromise = void 0;
        return token2;
      });
      shouldCallListeners = true;
    }
    const tokenFromDebugExchange = await state.exchangeTokenPromise;
    await writeTokenToStorage(app, tokenFromDebugExchange);
    setState(app, Object.assign(Object.assign({}, state), { token: tokenFromDebugExchange }));
    return { token: tokenFromDebugExchange.token };
  }
  try {
    if (!state.exchangeTokenPromise) {
      state.exchangeTokenPromise = state.provider.getToken().then((token2) => {
        state.exchangeTokenPromise = void 0;
        return token2;
      });
      shouldCallListeners = true;
    }
    token = await state.exchangeTokenPromise;
  } catch (e) {
    if (e.code === `appCheck/${"throttled"}`) {
      logger2.warn(e.message);
    } else {
      logger2.error(e);
    }
    error = e;
  }
  let interopTokenResult;
  if (!token) {
    interopTokenResult = makeDummyTokenResult(error);
  } else {
    interopTokenResult = {
      token: token.token
    };
    setState(app, Object.assign(Object.assign({}, state), { token }));
    await writeTokenToStorage(app, token);
  }
  if (shouldCallListeners) {
    notifyTokenListeners(app, interopTokenResult);
  }
  return interopTokenResult;
}
function addTokenListener(appCheck, type, listener, onError) {
  const { app } = appCheck;
  const state = getState(app);
  const tokenObserver = {
    next: listener,
    error: onError,
    type
  };
  setState(app, Object.assign(Object.assign({}, state), { tokenObservers: [...state.tokenObservers, tokenObserver] }));
  if (state.token && isValid(state.token)) {
    const validToken = state.token;
    Promise.resolve().then(() => {
      listener({ token: validToken.token });
      initTokenRefresher(appCheck);
    }).catch(() => {
    });
  }
  void state.cachedTokenPromise.then(() => initTokenRefresher(appCheck));
}
function removeTokenListener(app, listener) {
  const state = getState(app);
  const newObservers = state.tokenObservers.filter((tokenObserver) => tokenObserver.next !== listener);
  if (newObservers.length === 0 && state.tokenRefresher && state.tokenRefresher.isRunning()) {
    state.tokenRefresher.stop();
  }
  setState(app, Object.assign(Object.assign({}, state), { tokenObservers: newObservers }));
}
function initTokenRefresher(appCheck) {
  const { app } = appCheck;
  const state = getState(app);
  let refresher = state.tokenRefresher;
  if (!refresher) {
    refresher = createTokenRefresher(appCheck);
    setState(app, Object.assign(Object.assign({}, state), { tokenRefresher: refresher }));
  }
  if (!refresher.isRunning() && state.isTokenAutoRefreshEnabled) {
    refresher.start();
  }
}
function createTokenRefresher(appCheck) {
  const { app } = appCheck;
  return new Refresher(async () => {
    const state = getState(app);
    let result;
    if (!state.token) {
      result = await getToken$2(appCheck);
    } else {
      result = await getToken$2(appCheck, true);
    }
    if (result.error) {
      throw result.error;
    }
  }, () => {
    return true;
  }, () => {
    const state = getState(app);
    if (state.token) {
      let nextRefreshTimeMillis = state.token.issuedAtTimeMillis + (state.token.expireTimeMillis - state.token.issuedAtTimeMillis) * 0.5 + 5 * 60 * 1e3;
      const latestAllowableRefresh = state.token.expireTimeMillis - 5 * 60 * 1e3;
      nextRefreshTimeMillis = Math.min(nextRefreshTimeMillis, latestAllowableRefresh);
      return Math.max(0, nextRefreshTimeMillis - Date.now());
    } else {
      return 0;
    }
  }, TOKEN_REFRESH_TIME.RETRIAL_MIN_WAIT, TOKEN_REFRESH_TIME.RETRIAL_MAX_WAIT);
}
function notifyTokenListeners(app, token) {
  const observers = getState(app).tokenObservers;
  for (const observer of observers) {
    try {
      if (observer.type === "EXTERNAL" && token.error != null) {
        observer.error(token.error);
      } else {
        observer.next(token);
      }
    } catch (e) {
    }
  }
}
function isValid(token) {
  return token.expireTimeMillis - Date.now() > 0;
}
function makeDummyTokenResult(error) {
  return {
    token: formatDummyToken(defaultTokenErrorData),
    error
  };
}
var AppCheckService = class {
  constructor(app, heartbeatServiceProvider) {
    this.app = app;
    this.heartbeatServiceProvider = heartbeatServiceProvider;
  }
  _delete() {
    const { tokenObservers } = getState(this.app);
    for (const tokenObserver of tokenObservers) {
      removeTokenListener(this.app, tokenObserver.next);
    }
    return Promise.resolve();
  }
};
function factory2(app, heartbeatServiceProvider) {
  return new AppCheckService(app, heartbeatServiceProvider);
}
function internalFactory(appCheck) {
  return {
    getToken: (forceRefresh) => getToken$2(appCheck, forceRefresh),
    addTokenListener: (listener) => addTokenListener(appCheck, "INTERNAL", listener),
    removeTokenListener: (listener) => removeTokenListener(appCheck.app, listener)
  };
}
var name3 = "@firebase/app-check";
var version3 = "0.5.9";
var RECAPTCHA_URL = "https://www.google.com/recaptcha/api.js";
var RECAPTCHA_ENTERPRISE_URL = "https://www.google.com/recaptcha/enterprise.js";
function initializeV3(app, siteKey) {
  const state = getState(app);
  const initialized = new Deferred();
  setState(app, Object.assign(Object.assign({}, state), { reCAPTCHAState: { initialized } }));
  const divId = makeDiv(app);
  const grecaptcha = getRecaptcha(false);
  if (!grecaptcha) {
    loadReCAPTCHAV3Script(() => {
      const grecaptcha2 = getRecaptcha(false);
      if (!grecaptcha2) {
        throw new Error("no recaptcha");
      }
      queueWidgetRender(app, siteKey, grecaptcha2, divId, initialized);
    });
  } else {
    queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);
  }
  return initialized.promise;
}
function initializeEnterprise(app, siteKey) {
  const state = getState(app);
  const initialized = new Deferred();
  setState(app, Object.assign(Object.assign({}, state), { reCAPTCHAState: { initialized } }));
  const divId = makeDiv(app);
  const grecaptcha = getRecaptcha(true);
  if (!grecaptcha) {
    loadReCAPTCHAEnterpriseScript(() => {
      const grecaptcha2 = getRecaptcha(true);
      if (!grecaptcha2) {
        throw new Error("no recaptcha");
      }
      queueWidgetRender(app, siteKey, grecaptcha2, divId, initialized);
    });
  } else {
    queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);
  }
  return initialized.promise;
}
function queueWidgetRender(app, siteKey, grecaptcha, container, initialized) {
  grecaptcha.ready(() => {
    renderInvisibleWidget(app, siteKey, grecaptcha, container);
    initialized.resolve(grecaptcha);
  });
}
function makeDiv(app) {
  const divId = `fire_app_check_${app.name}`;
  const invisibleDiv = document.createElement("div");
  invisibleDiv.id = divId;
  invisibleDiv.style.display = "none";
  document.body.appendChild(invisibleDiv);
  return divId;
}
async function getToken$1(app) {
  ensureActivated(app);
  const reCAPTCHAState = getState(app).reCAPTCHAState;
  const recaptcha = await reCAPTCHAState.initialized.promise;
  return new Promise((resolve, _reject) => {
    const reCAPTCHAState2 = getState(app).reCAPTCHAState;
    recaptcha.ready(() => {
      resolve(recaptcha.execute(reCAPTCHAState2.widgetId, {
        action: "fire_app_check"
      }));
    });
  });
}
function renderInvisibleWidget(app, siteKey, grecaptcha, container) {
  const widgetId = grecaptcha.render(container, {
    sitekey: siteKey,
    size: "invisible"
  });
  const state = getState(app);
  setState(app, Object.assign(Object.assign({}, state), { reCAPTCHAState: Object.assign(Object.assign({}, state.reCAPTCHAState), {
    widgetId
  }) }));
}
function loadReCAPTCHAV3Script(onload) {
  const script = document.createElement("script");
  script.src = RECAPTCHA_URL;
  script.onload = onload;
  document.head.appendChild(script);
}
function loadReCAPTCHAEnterpriseScript(onload) {
  const script = document.createElement("script");
  script.src = RECAPTCHA_ENTERPRISE_URL;
  script.onload = onload;
  document.head.appendChild(script);
}
var ReCaptchaV3Provider = class {
  constructor(_siteKey) {
    this._siteKey = _siteKey;
    this._throttleData = null;
  }
  async getToken() {
    var _a2;
    throwIfThrottled(this._throttleData);
    const attestedClaimsToken = await getToken$1(this._app).catch((_e2) => {
      throw ERROR_FACTORY2.create("recaptcha-error");
    });
    let result;
    try {
      result = await exchangeToken(getExchangeRecaptchaV3TokenRequest(this._app, attestedClaimsToken), this._heartbeatServiceProvider);
    } catch (e) {
      if (e.code === "fetch-status-error") {
        this._throttleData = setBackoff(Number((_a2 = e.customData) === null || _a2 === void 0 ? void 0 : _a2.httpStatus), this._throttleData);
        throw ERROR_FACTORY2.create("throttled", {
          time: getDurationString(this._throttleData.allowRequestsAfter - Date.now()),
          httpStatus: this._throttleData.httpStatus
        });
      } else {
        throw e;
      }
    }
    this._throttleData = null;
    return result;
  }
  initialize(app) {
    this._app = app;
    this._heartbeatServiceProvider = _getProvider(app, "heartbeat");
    initializeV3(app, this._siteKey).catch(() => {
    });
  }
  isEqual(otherProvider) {
    if (otherProvider instanceof ReCaptchaV3Provider) {
      return this._siteKey === otherProvider._siteKey;
    } else {
      return false;
    }
  }
};
var ReCaptchaEnterpriseProvider = class {
  constructor(_siteKey) {
    this._siteKey = _siteKey;
    this._throttleData = null;
  }
  async getToken() {
    var _a2;
    throwIfThrottled(this._throttleData);
    const attestedClaimsToken = await getToken$1(this._app).catch((_e2) => {
      throw ERROR_FACTORY2.create("recaptcha-error");
    });
    let result;
    try {
      result = await exchangeToken(getExchangeRecaptchaEnterpriseTokenRequest(this._app, attestedClaimsToken), this._heartbeatServiceProvider);
    } catch (e) {
      if (e.code === "fetch-status-error") {
        this._throttleData = setBackoff(Number((_a2 = e.customData) === null || _a2 === void 0 ? void 0 : _a2.httpStatus), this._throttleData);
        throw ERROR_FACTORY2.create("throttled", {
          time: getDurationString(this._throttleData.allowRequestsAfter - Date.now()),
          httpStatus: this._throttleData.httpStatus
        });
      } else {
        throw e;
      }
    }
    this._throttleData = null;
    return result;
  }
  initialize(app) {
    this._app = app;
    this._heartbeatServiceProvider = _getProvider(app, "heartbeat");
    initializeEnterprise(app, this._siteKey).catch(() => {
    });
  }
  isEqual(otherProvider) {
    if (otherProvider instanceof ReCaptchaEnterpriseProvider) {
      return this._siteKey === otherProvider._siteKey;
    } else {
      return false;
    }
  }
};
var CustomProvider = class {
  constructor(_customProviderOptions) {
    this._customProviderOptions = _customProviderOptions;
  }
  async getToken() {
    const customToken = await this._customProviderOptions.getToken();
    const issuedAtTimeSeconds = issuedAtTime(customToken.token);
    const issuedAtTimeMillis = issuedAtTimeSeconds !== null && issuedAtTimeSeconds < Date.now() && issuedAtTimeSeconds > 0 ? issuedAtTimeSeconds * 1e3 : Date.now();
    return Object.assign(Object.assign({}, customToken), { issuedAtTimeMillis });
  }
  initialize(app) {
    this._app = app;
  }
  isEqual(otherProvider) {
    if (otherProvider instanceof CustomProvider) {
      return this._customProviderOptions.getToken.toString() === otherProvider._customProviderOptions.getToken.toString();
    } else {
      return false;
    }
  }
};
function setBackoff(httpStatus, throttleData) {
  if (httpStatus === 404 || httpStatus === 403) {
    return {
      backoffCount: 1,
      allowRequestsAfter: Date.now() + ONE_DAY,
      httpStatus
    };
  } else {
    const backoffCount = throttleData ? throttleData.backoffCount : 0;
    const backoffMillis = calculateBackoffMillis(backoffCount, 1e3, 2);
    return {
      backoffCount: backoffCount + 1,
      allowRequestsAfter: Date.now() + backoffMillis,
      httpStatus
    };
  }
}
function throwIfThrottled(throttleData) {
  if (throttleData) {
    if (Date.now() - throttleData.allowRequestsAfter <= 0) {
      throw ERROR_FACTORY2.create("throttled", {
        time: getDurationString(throttleData.allowRequestsAfter - Date.now()),
        httpStatus: throttleData.httpStatus
      });
    }
  }
}
function initializeAppCheck(app = getApp(), options) {
  app = getModularInstance(app);
  const provider = _getProvider(app, "app-check");
  if (!getDebugState().initialized) {
    initializeDebugMode();
  }
  if (isDebugMode()) {
    void getDebugToken().then((token) => console.log(`App Check debug token: ${token}. You will need to add it to your app's App Check settings in the Firebase console for it to work.`));
  }
  if (provider.isInitialized()) {
    const existingInstance = provider.getImmediate();
    const initialOptions = provider.getOptions();
    if (initialOptions.isTokenAutoRefreshEnabled === options.isTokenAutoRefreshEnabled && initialOptions.provider.isEqual(options.provider)) {
      return existingInstance;
    } else {
      throw ERROR_FACTORY2.create("already-initialized", {
        appName: app.name
      });
    }
  }
  const appCheck = provider.initialize({ options });
  _activate(app, options.provider, options.isTokenAutoRefreshEnabled);
  if (getState(app).isTokenAutoRefreshEnabled) {
    addTokenListener(appCheck, "INTERNAL", () => {
    });
  }
  return appCheck;
}
function _activate(app, provider, isTokenAutoRefreshEnabled) {
  const state = getState(app);
  const newState = Object.assign(Object.assign({}, state), { activated: true });
  newState.provider = provider;
  newState.cachedTokenPromise = readTokenFromStorage(app).then((cachedToken) => {
    if (cachedToken && isValid(cachedToken)) {
      setState(app, Object.assign(Object.assign({}, getState(app)), { token: cachedToken }));
      notifyTokenListeners(app, { token: cachedToken.token });
    }
    return cachedToken;
  });
  newState.isTokenAutoRefreshEnabled = isTokenAutoRefreshEnabled === void 0 ? app.automaticDataCollectionEnabled : isTokenAutoRefreshEnabled;
  setState(app, newState);
  newState.provider.initialize(app);
}
function setTokenAutoRefreshEnabled(appCheckInstance, isTokenAutoRefreshEnabled) {
  const app = appCheckInstance.app;
  const state = getState(app);
  if (state.tokenRefresher) {
    if (isTokenAutoRefreshEnabled === true) {
      state.tokenRefresher.start();
    } else {
      state.tokenRefresher.stop();
    }
  }
  setState(app, Object.assign(Object.assign({}, state), { isTokenAutoRefreshEnabled }));
}
async function getToken(appCheckInstance, forceRefresh) {
  const result = await getToken$2(appCheckInstance, forceRefresh);
  if (result.error) {
    throw result.error;
  }
  return { token: result.token };
}
function onTokenChanged(appCheckInstance, onNextOrObserver, onError, onCompletion) {
  let nextFn = () => {
  };
  let errorFn = () => {
  };
  if (onNextOrObserver.next != null) {
    nextFn = onNextOrObserver.next.bind(onNextOrObserver);
  } else {
    nextFn = onNextOrObserver;
  }
  if (onNextOrObserver.error != null) {
    errorFn = onNextOrObserver.error.bind(onNextOrObserver);
  } else if (onError) {
    errorFn = onError;
  }
  addTokenListener(appCheckInstance, "EXTERNAL", nextFn, errorFn);
  return () => removeTokenListener(appCheckInstance.app, nextFn);
}
var APP_CHECK_NAME = "app-check";
var APP_CHECK_NAME_INTERNAL = "app-check-internal";
function registerAppCheck() {
  _registerComponent(new Component(APP_CHECK_NAME, (container) => {
    const app = container.getProvider("app").getImmediate();
    const heartbeatServiceProvider = container.getProvider("heartbeat");
    return factory2(app, heartbeatServiceProvider);
  }, "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((container, _identifier, _appcheckService) => {
    container.getProvider(APP_CHECK_NAME_INTERNAL).initialize();
  }));
  _registerComponent(new Component(APP_CHECK_NAME_INTERNAL, (container) => {
    const appCheck = container.getProvider("app-check").getImmediate();
    return internalFactory(appCheck);
  }, "PUBLIC").setInstantiationMode("EXPLICIT"));
  registerVersion(name3, version3);
}
registerAppCheck();

// node_modules/@firebase/app-check-compat/dist/esm/index.esm2017.js
var name4 = "@firebase/app-check-compat";
var version4 = "0.2.9";
var ERRORS3 = {
  ["use-before-activation"]: "App Check is being used before activate() is called for FirebaseApp {$appName}. Call activate() before instantiating other Firebase services."
};
var ERROR_FACTORY3 = new ErrorFactory("appCheck", "AppCheck", ERRORS3);
var AppCheckService2 = class {
  constructor(app) {
    this.app = app;
  }
  activate(siteKeyOrProvider, isTokenAutoRefreshEnabled) {
    let provider;
    if (typeof siteKeyOrProvider === "string") {
      provider = new ReCaptchaV3Provider(siteKeyOrProvider);
    } else if (siteKeyOrProvider instanceof ReCaptchaEnterpriseProvider || siteKeyOrProvider instanceof ReCaptchaV3Provider || siteKeyOrProvider instanceof CustomProvider) {
      provider = siteKeyOrProvider;
    } else {
      provider = new CustomProvider({ getToken: siteKeyOrProvider.getToken });
    }
    this._delegate = initializeAppCheck(this.app, {
      provider,
      isTokenAutoRefreshEnabled
    });
  }
  setTokenAutoRefreshEnabled(isTokenAutoRefreshEnabled) {
    if (!this._delegate) {
      throw ERROR_FACTORY3.create("use-before-activation", {
        appName: this.app.name
      });
    }
    setTokenAutoRefreshEnabled(this._delegate, isTokenAutoRefreshEnabled);
  }
  getToken(forceRefresh) {
    if (!this._delegate) {
      throw ERROR_FACTORY3.create("use-before-activation", {
        appName: this.app.name
      });
    }
    return getToken(this._delegate, forceRefresh);
  }
  onTokenChanged(onNextOrObserver, onError, onCompletion) {
    if (!this._delegate) {
      throw ERROR_FACTORY3.create("use-before-activation", {
        appName: this.app.name
      });
    }
    return onTokenChanged(this._delegate, onNextOrObserver, onError, onCompletion);
  }
};
var factory3 = (container) => {
  const app = container.getProvider("app-compat").getImmediate();
  return new AppCheckService2(app);
};
function registerAppCheck2() {
  firebase.INTERNAL.registerComponent(new Component("appCheck-compat", factory3, "PUBLIC").setServiceProps({
    ReCaptchaEnterpriseProvider,
    ReCaptchaV3Provider,
    CustomProvider
  }));
}
registerAppCheck2();
firebase.registerVersion(name4, version4);

// node_modules/@firebase/auth/dist/esm2017/internal.js
function _cordovaWindow() {
  return window;
}
var REDIRECT_TIMEOUT_MS = 2e3;
async function _generateHandlerUrl(auth, event, provider) {
  var _a2;
  const { BuildInfo } = _cordovaWindow();
  debugAssert(event.sessionId, "AuthEvent did not contain a session ID");
  const sessionDigest = await computeSha256(event.sessionId);
  const additionalParams = {};
  if (_isIOS()) {
    additionalParams["ibi"] = BuildInfo.packageName;
  } else if (_isAndroid()) {
    additionalParams["apn"] = BuildInfo.packageName;
  } else {
    _fail(auth, "operation-not-supported-in-this-environment");
  }
  if (BuildInfo.displayName) {
    additionalParams["appDisplayName"] = BuildInfo.displayName;
  }
  additionalParams["sessionId"] = sessionDigest;
  return _getRedirectUrl(auth, provider, event.type, void 0, (_a2 = event.eventId) !== null && _a2 !== void 0 ? _a2 : void 0, additionalParams);
}
async function _validateOrigin(auth) {
  const { BuildInfo } = _cordovaWindow();
  const request = {};
  if (_isIOS()) {
    request.iosBundleId = BuildInfo.packageName;
  } else if (_isAndroid()) {
    request.androidPackageName = BuildInfo.packageName;
  } else {
    _fail(auth, "operation-not-supported-in-this-environment");
  }
  await _getProjectConfig(auth, request);
}
function _performRedirect(handlerUrl) {
  const { cordova } = _cordovaWindow();
  return new Promise((resolve) => {
    cordova.plugins.browsertab.isAvailable((browserTabIsAvailable) => {
      let iabRef = null;
      if (browserTabIsAvailable) {
        cordova.plugins.browsertab.openUrl(handlerUrl);
      } else {
        iabRef = cordova.InAppBrowser.open(handlerUrl, _isIOS7Or8() ? "_blank" : "_system", "location=yes");
      }
      resolve(iabRef);
    });
  });
}
async function _waitForAppResume(auth, eventListener, iabRef) {
  const { cordova } = _cordovaWindow();
  let cleanup = () => {
  };
  try {
    await new Promise((resolve, reject) => {
      let onCloseTimer = null;
      function authEventSeen() {
        var _a2;
        resolve();
        const closeBrowserTab = (_a2 = cordova.plugins.browsertab) === null || _a2 === void 0 ? void 0 : _a2.close;
        if (typeof closeBrowserTab === "function") {
          closeBrowserTab();
        }
        if (typeof (iabRef === null || iabRef === void 0 ? void 0 : iabRef.close) === "function") {
          iabRef.close();
        }
      }
      function resumed() {
        if (onCloseTimer) {
          return;
        }
        onCloseTimer = window.setTimeout(() => {
          reject(_createError(auth, "redirect-cancelled-by-user"));
        }, REDIRECT_TIMEOUT_MS);
      }
      function visibilityChanged() {
        if ((document === null || document === void 0 ? void 0 : document.visibilityState) === "visible") {
          resumed();
        }
      }
      eventListener.addPassiveListener(authEventSeen);
      document.addEventListener("resume", resumed, false);
      if (_isAndroid()) {
        document.addEventListener("visibilitychange", visibilityChanged, false);
      }
      cleanup = () => {
        eventListener.removePassiveListener(authEventSeen);
        document.removeEventListener("resume", resumed, false);
        document.removeEventListener("visibilitychange", visibilityChanged, false);
        if (onCloseTimer) {
          window.clearTimeout(onCloseTimer);
        }
      };
    });
  } finally {
    cleanup();
  }
}
function _checkCordovaConfiguration(auth) {
  var _a2, _b, _c2, _d, _e2, _f, _g, _h2, _j, _k;
  const win = _cordovaWindow();
  _assert(typeof ((_a2 = win === null || win === void 0 ? void 0 : win.universalLinks) === null || _a2 === void 0 ? void 0 : _a2.subscribe) === "function", auth, "invalid-cordova-configuration", {
    missingPlugin: "cordova-universal-links-plugin-fix"
  });
  _assert(typeof ((_b = win === null || win === void 0 ? void 0 : win.BuildInfo) === null || _b === void 0 ? void 0 : _b.packageName) !== "undefined", auth, "invalid-cordova-configuration", {
    missingPlugin: "cordova-plugin-buildInfo"
  });
  _assert(typeof ((_e2 = (_d = (_c2 = win === null || win === void 0 ? void 0 : win.cordova) === null || _c2 === void 0 ? void 0 : _c2.plugins) === null || _d === void 0 ? void 0 : _d.browsertab) === null || _e2 === void 0 ? void 0 : _e2.openUrl) === "function", auth, "invalid-cordova-configuration", {
    missingPlugin: "cordova-plugin-browsertab"
  });
  _assert(typeof ((_h2 = (_g = (_f = win === null || win === void 0 ? void 0 : win.cordova) === null || _f === void 0 ? void 0 : _f.plugins) === null || _g === void 0 ? void 0 : _g.browsertab) === null || _h2 === void 0 ? void 0 : _h2.isAvailable) === "function", auth, "invalid-cordova-configuration", {
    missingPlugin: "cordova-plugin-browsertab"
  });
  _assert(typeof ((_k = (_j = win === null || win === void 0 ? void 0 : win.cordova) === null || _j === void 0 ? void 0 : _j.InAppBrowser) === null || _k === void 0 ? void 0 : _k.open) === "function", auth, "invalid-cordova-configuration", {
    missingPlugin: "cordova-plugin-inappbrowser"
  });
}
async function computeSha256(sessionId) {
  const bytes = stringToArrayBuffer(sessionId);
  const buf = await crypto.subtle.digest("SHA-256", bytes);
  const arr = Array.from(new Uint8Array(buf));
  return arr.map((num) => num.toString(16).padStart(2, "0")).join("");
}
function stringToArrayBuffer(str) {
  debugAssert(/[0-9a-zA-Z]+/.test(str), "Can only convert alpha-numeric strings");
  if (typeof TextEncoder !== "undefined") {
    return new TextEncoder().encode(str);
  }
  const buff = new ArrayBuffer(str.length);
  const view = new Uint8Array(buff);
  for (let i = 0; i < str.length; i++) {
    view[i] = str.charCodeAt(i);
  }
  return view;
}
var SESSION_ID_LENGTH = 20;
var CordovaAuthEventManager = class extends AuthEventManager {
  constructor() {
    super(...arguments);
    this.passiveListeners = /* @__PURE__ */ new Set();
    this.initPromise = new Promise((resolve) => {
      this.resolveInialized = resolve;
    });
  }
  addPassiveListener(cb2) {
    this.passiveListeners.add(cb2);
  }
  removePassiveListener(cb2) {
    this.passiveListeners.delete(cb2);
  }
  resetRedirect() {
    this.queuedRedirectEvent = null;
    this.hasHandledPotentialRedirect = false;
  }
  onEvent(event) {
    this.resolveInialized();
    this.passiveListeners.forEach((cb2) => cb2(event));
    return super.onEvent(event);
  }
  async initialized() {
    await this.initPromise;
  }
};
function _generateNewEvent(auth, type, eventId = null) {
  return {
    type,
    eventId,
    urlResponse: null,
    sessionId: generateSessionId(),
    postBody: null,
    tenantId: auth.tenantId,
    error: _createError(auth, "no-auth-event")
  };
}
function _savePartialEvent(auth, event) {
  return storage()._set(persistenceKey(auth), event);
}
async function _getAndRemoveEvent(auth) {
  const event = await storage()._get(persistenceKey(auth));
  if (event) {
    await storage()._remove(persistenceKey(auth));
  }
  return event;
}
function _eventFromPartialAndUrl(partialEvent, url) {
  var _a2, _b;
  const callbackUrl = _getDeepLinkFromCallback(url);
  if (callbackUrl.includes("/__/auth/callback")) {
    const params = searchParamsOrEmpty(callbackUrl);
    const errorObject = params["firebaseError"] ? parseJsonOrNull(decodeURIComponent(params["firebaseError"])) : null;
    const code = (_b = (_a2 = errorObject === null || errorObject === void 0 ? void 0 : errorObject["code"]) === null || _a2 === void 0 ? void 0 : _a2.split("auth/")) === null || _b === void 0 ? void 0 : _b[1];
    const error = code ? _createError(code) : null;
    if (error) {
      return {
        type: partialEvent.type,
        eventId: partialEvent.eventId,
        tenantId: partialEvent.tenantId,
        error,
        urlResponse: null,
        sessionId: null,
        postBody: null
      };
    } else {
      return {
        type: partialEvent.type,
        eventId: partialEvent.eventId,
        tenantId: partialEvent.tenantId,
        sessionId: partialEvent.sessionId,
        urlResponse: callbackUrl,
        postBody: null
      };
    }
  }
  return null;
}
function generateSessionId() {
  const chars = [];
  const allowedChars = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  for (let i = 0; i < SESSION_ID_LENGTH; i++) {
    const idx = Math.floor(Math.random() * allowedChars.length);
    chars.push(allowedChars.charAt(idx));
  }
  return chars.join("");
}
function storage() {
  return _getInstance(browserLocalPersistence);
}
function persistenceKey(auth) {
  return _persistenceKeyName("authEvent", auth.config.apiKey, auth.name);
}
function parseJsonOrNull(json) {
  try {
    return JSON.parse(json);
  } catch (e) {
    return null;
  }
}
function _getDeepLinkFromCallback(url) {
  const params = searchParamsOrEmpty(url);
  const link = params["link"] ? decodeURIComponent(params["link"]) : void 0;
  const doubleDeepLink = searchParamsOrEmpty(link)["link"];
  const iOSDeepLink = params["deep_link_id"] ? decodeURIComponent(params["deep_link_id"]) : void 0;
  const iOSDoubleDeepLink = searchParamsOrEmpty(iOSDeepLink)["link"];
  return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;
}
function searchParamsOrEmpty(url) {
  if (!(url === null || url === void 0 ? void 0 : url.includes("?"))) {
    return {};
  }
  const [_, ...rest] = url.split("?");
  return querystringDecode(rest.join("?"));
}
var INITIAL_EVENT_TIMEOUT_MS = 500;
var CordovaPopupRedirectResolver = class {
  constructor() {
    this._redirectPersistence = browserSessionPersistence;
    this._shouldInitProactively = true;
    this.eventManagers = /* @__PURE__ */ new Map();
    this.originValidationPromises = {};
    this._completeRedirectFn = _getRedirectResult;
    this._overrideRedirectResult = _overrideRedirectResult;
  }
  async _initialize(auth) {
    const key = auth._key();
    let manager = this.eventManagers.get(key);
    if (!manager) {
      manager = new CordovaAuthEventManager(auth);
      this.eventManagers.set(key, manager);
      this.attachCallbackListeners(auth, manager);
    }
    return manager;
  }
  _openPopup(auth) {
    _fail(auth, "operation-not-supported-in-this-environment");
  }
  async _openRedirect(auth, provider, authType, eventId) {
    _checkCordovaConfiguration(auth);
    const manager = await this._initialize(auth);
    await manager.initialized();
    manager.resetRedirect();
    _clearRedirectOutcomes();
    await this._originValidation(auth);
    const event = _generateNewEvent(auth, authType, eventId);
    await _savePartialEvent(auth, event);
    const url = await _generateHandlerUrl(auth, event, provider);
    const iabRef = await _performRedirect(url);
    return _waitForAppResume(auth, manager, iabRef);
  }
  _isIframeWebStorageSupported(_auth, _cb) {
    throw new Error("Method not implemented.");
  }
  _originValidation(auth) {
    const key = auth._key();
    if (!this.originValidationPromises[key]) {
      this.originValidationPromises[key] = _validateOrigin(auth);
    }
    return this.originValidationPromises[key];
  }
  attachCallbackListeners(auth, manager) {
    const { universalLinks, handleOpenURL, BuildInfo } = _cordovaWindow();
    const noEventTimeout = setTimeout(async () => {
      await _getAndRemoveEvent(auth);
      manager.onEvent(generateNoEvent());
    }, INITIAL_EVENT_TIMEOUT_MS);
    const universalLinksCb = async (eventData) => {
      clearTimeout(noEventTimeout);
      const partialEvent = await _getAndRemoveEvent(auth);
      let finalEvent = null;
      if (partialEvent && (eventData === null || eventData === void 0 ? void 0 : eventData["url"])) {
        finalEvent = _eventFromPartialAndUrl(partialEvent, eventData["url"]);
      }
      manager.onEvent(finalEvent || generateNoEvent());
    };
    if (typeof universalLinks !== "undefined" && typeof universalLinks.subscribe === "function") {
      universalLinks.subscribe(null, universalLinksCb);
    }
    const existingHandleOpenURL = handleOpenURL;
    const packagePrefix = `${BuildInfo.packageName.toLowerCase()}://`;
    _cordovaWindow().handleOpenURL = async (url) => {
      if (url.toLowerCase().startsWith(packagePrefix)) {
        universalLinksCb({ url });
      }
      if (typeof existingHandleOpenURL === "function") {
        try {
          existingHandleOpenURL(url);
        } catch (e) {
          console.error(e);
        }
      }
    };
  }
};
var cordovaPopupRedirectResolver = CordovaPopupRedirectResolver;
function generateNoEvent() {
  return {
    type: "unknown",
    eventId: null,
    sessionId: null,
    urlResponse: null,
    postBody: null,
    tenantId: null,
    error: _createError("no-auth-event")
  };
}
function addFrameworkForLogging(auth, framework) {
  _castAuth(auth)._logFramework(framework);
}

// node_modules/@firebase/auth-compat/dist/index.esm2017.js
var name5 = "@firebase/auth-compat";
var version5 = "0.2.16";
var CORDOVA_ONDEVICEREADY_TIMEOUT_MS = 1e3;
function _getCurrentScheme() {
  var _a2;
  return ((_a2 = self === null || self === void 0 ? void 0 : self.location) === null || _a2 === void 0 ? void 0 : _a2.protocol) || null;
}
function _isHttpOrHttps() {
  return _getCurrentScheme() === "http:" || _getCurrentScheme() === "https:";
}
function _isAndroidOrIosCordovaScheme(ua3 = getUA()) {
  return !!((_getCurrentScheme() === "file:" || _getCurrentScheme() === "ionic:" || _getCurrentScheme() === "capacitor:") && ua3.toLowerCase().match(/iphone|ipad|ipod|android/));
}
function _isNativeEnvironment() {
  return isReactNative() || isNode();
}
function _isIe11() {
  return isIE() && (document === null || document === void 0 ? void 0 : document.documentMode) === 11;
}
function _isEdge(ua3 = getUA()) {
  return /Edge\/\d+/.test(ua3);
}
function _isLocalStorageNotSynchronized(ua3 = getUA()) {
  return _isIe11() || _isEdge(ua3);
}
function _isWebStorageSupported() {
  try {
    const storage2 = self.localStorage;
    const key = _generateEventId();
    if (storage2) {
      storage2["setItem"](key, "1");
      storage2["removeItem"](key);
      if (_isLocalStorageNotSynchronized()) {
        return isIndexedDBAvailable();
      }
      return true;
    }
  } catch (e) {
    return _isWorker() && isIndexedDBAvailable();
  }
  return false;
}
function _isWorker() {
  return typeof global !== "undefined" && "WorkerGlobalScope" in global && "importScripts" in global;
}
function _isPopupRedirectSupported() {
  return (_isHttpOrHttps() || isBrowserExtension() || _isAndroidOrIosCordovaScheme()) && !_isNativeEnvironment() && _isWebStorageSupported() && !_isWorker();
}
function _isLikelyCordova() {
  return _isAndroidOrIosCordovaScheme() && typeof document !== "undefined";
}
async function _isCordova() {
  if (!_isLikelyCordova()) {
    return false;
  }
  return new Promise((resolve) => {
    const timeoutId = setTimeout(() => {
      resolve(false);
    }, CORDOVA_ONDEVICEREADY_TIMEOUT_MS);
    document.addEventListener("deviceready", () => {
      clearTimeout(timeoutId);
      resolve(true);
    });
  });
}
function _getSelfWindow() {
  return typeof window !== "undefined" ? window : null;
}
var Persistence = {
  LOCAL: "local",
  NONE: "none",
  SESSION: "session"
};
var _assert$3 = _assert;
var PERSISTENCE_KEY = "persistence";
function _validatePersistenceArgument(auth, persistence) {
  _assert$3(Object.values(Persistence).includes(persistence), auth, "invalid-persistence-type");
  if (isReactNative()) {
    _assert$3(persistence !== Persistence.SESSION, auth, "unsupported-persistence-type");
    return;
  }
  if (isNode()) {
    _assert$3(persistence === Persistence.NONE, auth, "unsupported-persistence-type");
    return;
  }
  if (_isWorker()) {
    _assert$3(persistence === Persistence.NONE || persistence === Persistence.LOCAL && isIndexedDBAvailable(), auth, "unsupported-persistence-type");
    return;
  }
  _assert$3(persistence === Persistence.NONE || _isWebStorageSupported(), auth, "unsupported-persistence-type");
}
async function _savePersistenceForRedirect(auth) {
  await auth._initializationPromise;
  const session = getSessionStorageIfAvailable();
  const key = _persistenceKeyName(PERSISTENCE_KEY, auth.config.apiKey, auth.name);
  if (session) {
    session.setItem(key, auth._getPersistence());
  }
}
function _getPersistencesFromRedirect(apiKey, appName) {
  const session = getSessionStorageIfAvailable();
  if (!session) {
    return [];
  }
  const key = _persistenceKeyName(PERSISTENCE_KEY, apiKey, appName);
  const persistence = session.getItem(key);
  switch (persistence) {
    case Persistence.NONE:
      return [inMemoryPersistence];
    case Persistence.LOCAL:
      return [indexedDBLocalPersistence, browserSessionPersistence];
    case Persistence.SESSION:
      return [browserSessionPersistence];
    default:
      return [];
  }
}
function getSessionStorageIfAvailable() {
  var _a2;
  try {
    return ((_a2 = _getSelfWindow()) === null || _a2 === void 0 ? void 0 : _a2.sessionStorage) || null;
  } catch (e) {
    return null;
  }
}
var _assert$2 = _assert;
var CompatPopupRedirectResolver = class {
  constructor() {
    this.browserResolver = _getInstance(browserPopupRedirectResolver);
    this.cordovaResolver = _getInstance(cordovaPopupRedirectResolver);
    this.underlyingResolver = null;
    this._redirectPersistence = browserSessionPersistence;
    this._completeRedirectFn = _getRedirectResult;
    this._overrideRedirectResult = _overrideRedirectResult;
  }
  async _initialize(auth) {
    await this.selectUnderlyingResolver();
    return this.assertedUnderlyingResolver._initialize(auth);
  }
  async _openPopup(auth, provider, authType, eventId) {
    await this.selectUnderlyingResolver();
    return this.assertedUnderlyingResolver._openPopup(auth, provider, authType, eventId);
  }
  async _openRedirect(auth, provider, authType, eventId) {
    await this.selectUnderlyingResolver();
    return this.assertedUnderlyingResolver._openRedirect(auth, provider, authType, eventId);
  }
  _isIframeWebStorageSupported(auth, cb2) {
    this.assertedUnderlyingResolver._isIframeWebStorageSupported(auth, cb2);
  }
  _originValidation(auth) {
    return this.assertedUnderlyingResolver._originValidation(auth);
  }
  get _shouldInitProactively() {
    return _isLikelyCordova() || this.browserResolver._shouldInitProactively;
  }
  get assertedUnderlyingResolver() {
    _assert$2(this.underlyingResolver, "internal-error");
    return this.underlyingResolver;
  }
  async selectUnderlyingResolver() {
    if (this.underlyingResolver) {
      return;
    }
    const isCordova = await _isCordova();
    this.underlyingResolver = isCordova ? this.cordovaResolver : this.browserResolver;
  }
};
function unwrap(object) {
  return object.unwrap();
}
function wrapped(object) {
  return object.wrapped();
}
function credentialFromResponse(userCredential) {
  return credentialFromObject(userCredential);
}
function attachExtraErrorFields(auth, e) {
  var _a2;
  const response = (_a2 = e.customData) === null || _a2 === void 0 ? void 0 : _a2._tokenResponse;
  if (e.code === "auth/multi-factor-auth-required") {
    const mfaErr = e;
    mfaErr.resolver = new MultiFactorResolver(auth, getMultiFactorResolver(auth, e));
  } else if (response) {
    const credential = credentialFromObject(e);
    const credErr = e;
    if (credential) {
      credErr.credential = credential;
      credErr.tenantId = response.tenantId || void 0;
      credErr.email = response.email || void 0;
      credErr.phoneNumber = response.phoneNumber || void 0;
    }
  }
}
function credentialFromObject(object) {
  const { _tokenResponse } = object instanceof FirebaseError ? object.customData : object;
  if (!_tokenResponse) {
    return null;
  }
  if (!(object instanceof FirebaseError)) {
    if ("temporaryProof" in _tokenResponse && "phoneNumber" in _tokenResponse) {
      return PhoneAuthProvider.credentialFromResult(object);
    }
  }
  const providerId = _tokenResponse.providerId;
  if (!providerId || providerId === ProviderId.PASSWORD) {
    return null;
  }
  let provider;
  switch (providerId) {
    case ProviderId.GOOGLE:
      provider = GoogleAuthProvider;
      break;
    case ProviderId.FACEBOOK:
      provider = FacebookAuthProvider;
      break;
    case ProviderId.GITHUB:
      provider = GithubAuthProvider;
      break;
    case ProviderId.TWITTER:
      provider = TwitterAuthProvider;
      break;
    default:
      const { oauthIdToken, oauthAccessToken, oauthTokenSecret, pendingToken, nonce } = _tokenResponse;
      if (!oauthAccessToken && !oauthTokenSecret && !oauthIdToken && !pendingToken) {
        return null;
      }
      if (pendingToken) {
        if (providerId.startsWith("saml.")) {
          return SAMLAuthCredential._create(providerId, pendingToken);
        } else {
          return OAuthCredential._fromParams({
            providerId,
            signInMethod: providerId,
            pendingToken,
            idToken: oauthIdToken,
            accessToken: oauthAccessToken
          });
        }
      }
      return new OAuthProvider(providerId).credential({
        idToken: oauthIdToken,
        accessToken: oauthAccessToken,
        rawNonce: nonce
      });
  }
  return object instanceof FirebaseError ? provider.credentialFromError(object) : provider.credentialFromResult(object);
}
function convertCredential(auth, credentialPromise) {
  return credentialPromise.catch((e) => {
    if (e instanceof FirebaseError) {
      attachExtraErrorFields(auth, e);
    }
    throw e;
  }).then((credential) => {
    const operationType = credential.operationType;
    const user = credential.user;
    return {
      operationType,
      credential: credentialFromResponse(credential),
      additionalUserInfo: getAdditionalUserInfo(credential),
      user: User.getOrCreate(user)
    };
  });
}
async function convertConfirmationResult(auth, confirmationResultPromise) {
  const confirmationResultExp = await confirmationResultPromise;
  return {
    verificationId: confirmationResultExp.verificationId,
    confirm: (verificationCode) => convertCredential(auth, confirmationResultExp.confirm(verificationCode))
  };
}
var MultiFactorResolver = class {
  constructor(auth, resolver) {
    this.resolver = resolver;
    this.auth = wrapped(auth);
  }
  get session() {
    return this.resolver.session;
  }
  get hints() {
    return this.resolver.hints;
  }
  resolveSignIn(assertion) {
    return convertCredential(unwrap(this.auth), this.resolver.resolveSignIn(assertion));
  }
};
var User = class {
  constructor(_delegate) {
    this._delegate = _delegate;
    this.multiFactor = multiFactor(_delegate);
  }
  static getOrCreate(user) {
    if (!User.USER_MAP.has(user)) {
      User.USER_MAP.set(user, new User(user));
    }
    return User.USER_MAP.get(user);
  }
  delete() {
    return this._delegate.delete();
  }
  reload() {
    return this._delegate.reload();
  }
  toJSON() {
    return this._delegate.toJSON();
  }
  getIdTokenResult(forceRefresh) {
    return this._delegate.getIdTokenResult(forceRefresh);
  }
  getIdToken(forceRefresh) {
    return this._delegate.getIdToken(forceRefresh);
  }
  linkAndRetrieveDataWithCredential(credential) {
    return this.linkWithCredential(credential);
  }
  async linkWithCredential(credential) {
    return convertCredential(this.auth, linkWithCredential(this._delegate, credential));
  }
  async linkWithPhoneNumber(phoneNumber, applicationVerifier) {
    return convertConfirmationResult(this.auth, linkWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier));
  }
  async linkWithPopup(provider) {
    return convertCredential(this.auth, linkWithPopup(this._delegate, provider, CompatPopupRedirectResolver));
  }
  async linkWithRedirect(provider) {
    await _savePersistenceForRedirect(_castAuth(this.auth));
    return linkWithRedirect(this._delegate, provider, CompatPopupRedirectResolver);
  }
  reauthenticateAndRetrieveDataWithCredential(credential) {
    return this.reauthenticateWithCredential(credential);
  }
  async reauthenticateWithCredential(credential) {
    return convertCredential(this.auth, reauthenticateWithCredential(this._delegate, credential));
  }
  reauthenticateWithPhoneNumber(phoneNumber, applicationVerifier) {
    return convertConfirmationResult(this.auth, reauthenticateWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier));
  }
  reauthenticateWithPopup(provider) {
    return convertCredential(this.auth, reauthenticateWithPopup(this._delegate, provider, CompatPopupRedirectResolver));
  }
  async reauthenticateWithRedirect(provider) {
    await _savePersistenceForRedirect(_castAuth(this.auth));
    return reauthenticateWithRedirect(this._delegate, provider, CompatPopupRedirectResolver);
  }
  sendEmailVerification(actionCodeSettings) {
    return sendEmailVerification(this._delegate, actionCodeSettings);
  }
  async unlink(providerId) {
    await unlink(this._delegate, providerId);
    return this;
  }
  updateEmail(newEmail) {
    return updateEmail(this._delegate, newEmail);
  }
  updatePassword(newPassword) {
    return updatePassword(this._delegate, newPassword);
  }
  updatePhoneNumber(phoneCredential) {
    return updatePhoneNumber(this._delegate, phoneCredential);
  }
  updateProfile(profile) {
    return updateProfile(this._delegate, profile);
  }
  verifyBeforeUpdateEmail(newEmail, actionCodeSettings) {
    return verifyBeforeUpdateEmail(this._delegate, newEmail, actionCodeSettings);
  }
  get emailVerified() {
    return this._delegate.emailVerified;
  }
  get isAnonymous() {
    return this._delegate.isAnonymous;
  }
  get metadata() {
    return this._delegate.metadata;
  }
  get phoneNumber() {
    return this._delegate.phoneNumber;
  }
  get providerData() {
    return this._delegate.providerData;
  }
  get refreshToken() {
    return this._delegate.refreshToken;
  }
  get tenantId() {
    return this._delegate.tenantId;
  }
  get displayName() {
    return this._delegate.displayName;
  }
  get email() {
    return this._delegate.email;
  }
  get photoURL() {
    return this._delegate.photoURL;
  }
  get providerId() {
    return this._delegate.providerId;
  }
  get uid() {
    return this._delegate.uid;
  }
  get auth() {
    return this._delegate.auth;
  }
};
User.USER_MAP = /* @__PURE__ */ new WeakMap();
var _assert$1 = _assert;
var Auth = class {
  constructor(app, provider) {
    this.app = app;
    if (provider.isInitialized()) {
      this._delegate = provider.getImmediate();
      this.linkUnderlyingAuth();
      return;
    }
    const { apiKey } = app.options;
    _assert$1(apiKey, "invalid-api-key", {
      appName: app.name
    });
    _assert$1(apiKey, "invalid-api-key", {
      appName: app.name
    });
    const resolver = typeof window !== "undefined" ? CompatPopupRedirectResolver : void 0;
    this._delegate = provider.initialize({
      options: {
        persistence: buildPersistenceHierarchy(apiKey, app.name),
        popupRedirectResolver: resolver
      }
    });
    this._delegate._updateErrorMap(debugErrorMap);
    this.linkUnderlyingAuth();
  }
  get emulatorConfig() {
    return this._delegate.emulatorConfig;
  }
  get currentUser() {
    if (!this._delegate.currentUser) {
      return null;
    }
    return User.getOrCreate(this._delegate.currentUser);
  }
  get languageCode() {
    return this._delegate.languageCode;
  }
  set languageCode(languageCode) {
    this._delegate.languageCode = languageCode;
  }
  get settings() {
    return this._delegate.settings;
  }
  get tenantId() {
    return this._delegate.tenantId;
  }
  set tenantId(tid) {
    this._delegate.tenantId = tid;
  }
  useDeviceLanguage() {
    this._delegate.useDeviceLanguage();
  }
  signOut() {
    return this._delegate.signOut();
  }
  useEmulator(url, options) {
    connectAuthEmulator(this._delegate, url, options);
  }
  applyActionCode(code) {
    return applyActionCode(this._delegate, code);
  }
  checkActionCode(code) {
    return checkActionCode(this._delegate, code);
  }
  confirmPasswordReset(code, newPassword) {
    return confirmPasswordReset(this._delegate, code, newPassword);
  }
  async createUserWithEmailAndPassword(email, password) {
    return convertCredential(this._delegate, createUserWithEmailAndPassword(this._delegate, email, password));
  }
  fetchProvidersForEmail(email) {
    return this.fetchSignInMethodsForEmail(email);
  }
  fetchSignInMethodsForEmail(email) {
    return fetchSignInMethodsForEmail(this._delegate, email);
  }
  isSignInWithEmailLink(emailLink) {
    return isSignInWithEmailLink(this._delegate, emailLink);
  }
  async getRedirectResult() {
    _assert$1(_isPopupRedirectSupported(), this._delegate, "operation-not-supported-in-this-environment");
    const credential = await getRedirectResult(this._delegate, CompatPopupRedirectResolver);
    if (!credential) {
      return {
        credential: null,
        user: null
      };
    }
    return convertCredential(this._delegate, Promise.resolve(credential));
  }
  addFrameworkForLogging(framework) {
    addFrameworkForLogging(this._delegate, framework);
  }
  onAuthStateChanged(nextOrObserver, errorFn, completed) {
    const { next, error, complete } = wrapObservers(nextOrObserver, errorFn, completed);
    return this._delegate.onAuthStateChanged(next, error, complete);
  }
  onIdTokenChanged(nextOrObserver, errorFn, completed) {
    const { next, error, complete } = wrapObservers(nextOrObserver, errorFn, completed);
    return this._delegate.onIdTokenChanged(next, error, complete);
  }
  sendSignInLinkToEmail(email, actionCodeSettings) {
    return sendSignInLinkToEmail(this._delegate, email, actionCodeSettings);
  }
  sendPasswordResetEmail(email, actionCodeSettings) {
    return sendPasswordResetEmail(this._delegate, email, actionCodeSettings || void 0);
  }
  async setPersistence(persistence) {
    _validatePersistenceArgument(this._delegate, persistence);
    let converted;
    switch (persistence) {
      case Persistence.SESSION:
        converted = browserSessionPersistence;
        break;
      case Persistence.LOCAL:
        const isIndexedDBFullySupported = await _getInstance(indexedDBLocalPersistence)._isAvailable();
        converted = isIndexedDBFullySupported ? indexedDBLocalPersistence : browserLocalPersistence;
        break;
      case Persistence.NONE:
        converted = inMemoryPersistence;
        break;
      default:
        return _fail("argument-error", {
          appName: this._delegate.name
        });
    }
    return this._delegate.setPersistence(converted);
  }
  signInAndRetrieveDataWithCredential(credential) {
    return this.signInWithCredential(credential);
  }
  signInAnonymously() {
    return convertCredential(this._delegate, signInAnonymously(this._delegate));
  }
  signInWithCredential(credential) {
    return convertCredential(this._delegate, signInWithCredential(this._delegate, credential));
  }
  signInWithCustomToken(token) {
    return convertCredential(this._delegate, signInWithCustomToken(this._delegate, token));
  }
  signInWithEmailAndPassword(email, password) {
    return convertCredential(this._delegate, signInWithEmailAndPassword(this._delegate, email, password));
  }
  signInWithEmailLink(email, emailLink) {
    return convertCredential(this._delegate, signInWithEmailLink(this._delegate, email, emailLink));
  }
  signInWithPhoneNumber(phoneNumber, applicationVerifier) {
    return convertConfirmationResult(this._delegate, signInWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier));
  }
  async signInWithPopup(provider) {
    _assert$1(_isPopupRedirectSupported(), this._delegate, "operation-not-supported-in-this-environment");
    return convertCredential(this._delegate, signInWithPopup(this._delegate, provider, CompatPopupRedirectResolver));
  }
  async signInWithRedirect(provider) {
    _assert$1(_isPopupRedirectSupported(), this._delegate, "operation-not-supported-in-this-environment");
    await _savePersistenceForRedirect(this._delegate);
    return signInWithRedirect(this._delegate, provider, CompatPopupRedirectResolver);
  }
  updateCurrentUser(user) {
    return this._delegate.updateCurrentUser(user);
  }
  verifyPasswordResetCode(code) {
    return verifyPasswordResetCode(this._delegate, code);
  }
  unwrap() {
    return this._delegate;
  }
  _delete() {
    return this._delegate._delete();
  }
  linkUnderlyingAuth() {
    this._delegate.wrapped = () => this;
  }
};
Auth.Persistence = Persistence;
function wrapObservers(nextOrObserver, error, complete) {
  let next = nextOrObserver;
  if (typeof nextOrObserver !== "function") {
    ({ next, error, complete } = nextOrObserver);
  }
  const oldNext = next;
  const newNext = (user) => oldNext(user && User.getOrCreate(user));
  return {
    next: newNext,
    error,
    complete
  };
}
function buildPersistenceHierarchy(apiKey, appName) {
  const persistences = _getPersistencesFromRedirect(apiKey, appName);
  if (typeof self !== "undefined" && !persistences.includes(indexedDBLocalPersistence)) {
    persistences.push(indexedDBLocalPersistence);
  }
  if (typeof window !== "undefined") {
    for (const persistence of [
      browserLocalPersistence,
      browserSessionPersistence
    ]) {
      if (!persistences.includes(persistence)) {
        persistences.push(persistence);
      }
    }
  }
  if (!persistences.includes(inMemoryPersistence)) {
    persistences.push(inMemoryPersistence);
  }
  return persistences;
}
var PhoneAuthProvider2 = class {
  constructor() {
    this.providerId = "phone";
    this._delegate = new PhoneAuthProvider(unwrap(firebase.auth()));
  }
  static credential(verificationId, verificationCode) {
    return PhoneAuthProvider.credential(verificationId, verificationCode);
  }
  verifyPhoneNumber(phoneInfoOptions, applicationVerifier) {
    return this._delegate.verifyPhoneNumber(phoneInfoOptions, applicationVerifier);
  }
  unwrap() {
    return this._delegate;
  }
};
PhoneAuthProvider2.PHONE_SIGN_IN_METHOD = PhoneAuthProvider.PHONE_SIGN_IN_METHOD;
PhoneAuthProvider2.PROVIDER_ID = PhoneAuthProvider.PROVIDER_ID;
var _assert2 = _assert;
var RecaptchaVerifier2 = class {
  constructor(container, parameters, app = firebase.app()) {
    var _a2;
    _assert2((_a2 = app.options) === null || _a2 === void 0 ? void 0 : _a2.apiKey, "invalid-api-key", {
      appName: app.name
    });
    this._delegate = new RecaptchaVerifier(container, parameters, app.auth());
    this.type = this._delegate.type;
  }
  clear() {
    this._delegate.clear();
  }
  render() {
    return this._delegate.render();
  }
  verify() {
    return this._delegate.verify();
  }
};
var AUTH_TYPE = "auth-compat";
function registerAuthCompat(instance) {
  instance.INTERNAL.registerComponent(new Component(AUTH_TYPE, (container) => {
    const app = container.getProvider("app-compat").getImmediate();
    const authProvider = container.getProvider("auth");
    return new Auth(app, authProvider);
  }, "PUBLIC").setServiceProps({
    ActionCodeInfo: {
      Operation: {
        EMAIL_SIGNIN: ActionCodeOperation.EMAIL_SIGNIN,
        PASSWORD_RESET: ActionCodeOperation.PASSWORD_RESET,
        RECOVER_EMAIL: ActionCodeOperation.RECOVER_EMAIL,
        REVERT_SECOND_FACTOR_ADDITION: ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION,
        VERIFY_AND_CHANGE_EMAIL: ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL,
        VERIFY_EMAIL: ActionCodeOperation.VERIFY_EMAIL
      }
    },
    EmailAuthProvider,
    FacebookAuthProvider,
    GithubAuthProvider,
    GoogleAuthProvider,
    OAuthProvider,
    SAMLAuthProvider,
    PhoneAuthProvider: PhoneAuthProvider2,
    PhoneMultiFactorGenerator,
    RecaptchaVerifier: RecaptchaVerifier2,
    TwitterAuthProvider,
    Auth,
    AuthCredential,
    Error: FirebaseError
  }).setInstantiationMode("LAZY").setMultipleInstances(false));
  instance.registerVersion(name5, version5);
}
registerAuthCompat(firebase);

// node_modules/@firebase/database-compat/dist/index.esm2017.js
var name6 = "@firebase/database-compat";
var version6 = "0.2.1";
var logClient = new Logger("@firebase/database-compat");
var warn = function(msg) {
  const message = "FIREBASE WARNING: " + msg;
  logClient.warn(message);
};
var validateBoolean = function(fnName, argumentName, bool, optional) {
  if (optional && bool === void 0) {
    return;
  }
  if (typeof bool !== "boolean") {
    throw new Error(errorPrefix(fnName, argumentName) + "must be a boolean.");
  }
};
var validateEventType = function(fnName, eventType, optional) {
  if (optional && eventType === void 0) {
    return;
  }
  switch (eventType) {
    case "value":
    case "child_added":
    case "child_removed":
    case "child_changed":
    case "child_moved":
      break;
    default:
      throw new Error(errorPrefix(fnName, "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".');
  }
};
var OnDisconnect2 = class {
  constructor(_delegate) {
    this._delegate = _delegate;
  }
  cancel(onComplete) {
    validateArgCount("OnDisconnect.cancel", 0, 1, arguments.length);
    validateCallback("OnDisconnect.cancel", "onComplete", onComplete, true);
    const result = this._delegate.cancel();
    if (onComplete) {
      result.then(() => onComplete(null), (error) => onComplete(error));
    }
    return result;
  }
  remove(onComplete) {
    validateArgCount("OnDisconnect.remove", 0, 1, arguments.length);
    validateCallback("OnDisconnect.remove", "onComplete", onComplete, true);
    const result = this._delegate.remove();
    if (onComplete) {
      result.then(() => onComplete(null), (error) => onComplete(error));
    }
    return result;
  }
  set(value, onComplete) {
    validateArgCount("OnDisconnect.set", 1, 2, arguments.length);
    validateCallback("OnDisconnect.set", "onComplete", onComplete, true);
    const result = this._delegate.set(value);
    if (onComplete) {
      result.then(() => onComplete(null), (error) => onComplete(error));
    }
    return result;
  }
  setWithPriority(value, priority, onComplete) {
    validateArgCount("OnDisconnect.setWithPriority", 2, 3, arguments.length);
    validateCallback("OnDisconnect.setWithPriority", "onComplete", onComplete, true);
    const result = this._delegate.setWithPriority(value, priority);
    if (onComplete) {
      result.then(() => onComplete(null), (error) => onComplete(error));
    }
    return result;
  }
  update(objectToMerge, onComplete) {
    validateArgCount("OnDisconnect.update", 1, 2, arguments.length);
    if (Array.isArray(objectToMerge)) {
      const newObjectToMerge = {};
      for (let i = 0; i < objectToMerge.length; ++i) {
        newObjectToMerge["" + i] = objectToMerge[i];
      }
      objectToMerge = newObjectToMerge;
      warn("Passing an Array to firebase.database.onDisconnect().update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.");
    }
    validateCallback("OnDisconnect.update", "onComplete", onComplete, true);
    const result = this._delegate.update(objectToMerge);
    if (onComplete) {
      result.then(() => onComplete(null), (error) => onComplete(error));
    }
    return result;
  }
};
var TransactionResult = class {
  constructor(committed, snapshot) {
    this.committed = committed;
    this.snapshot = snapshot;
  }
  toJSON() {
    validateArgCount("TransactionResult.toJSON", 0, 1, arguments.length);
    return { committed: this.committed, snapshot: this.snapshot.toJSON() };
  }
};
var DataSnapshot = class {
  constructor(_database, _delegate) {
    this._database = _database;
    this._delegate = _delegate;
  }
  val() {
    validateArgCount("DataSnapshot.val", 0, 0, arguments.length);
    return this._delegate.val();
  }
  exportVal() {
    validateArgCount("DataSnapshot.exportVal", 0, 0, arguments.length);
    return this._delegate.exportVal();
  }
  toJSON() {
    validateArgCount("DataSnapshot.toJSON", 0, 1, arguments.length);
    return this._delegate.toJSON();
  }
  exists() {
    validateArgCount("DataSnapshot.exists", 0, 0, arguments.length);
    return this._delegate.exists();
  }
  child(path) {
    validateArgCount("DataSnapshot.child", 0, 1, arguments.length);
    path = String(path);
    validatePathString("DataSnapshot.child", "path", path, false);
    return new DataSnapshot(this._database, this._delegate.child(path));
  }
  hasChild(path) {
    validateArgCount("DataSnapshot.hasChild", 1, 1, arguments.length);
    validatePathString("DataSnapshot.hasChild", "path", path, false);
    return this._delegate.hasChild(path);
  }
  getPriority() {
    validateArgCount("DataSnapshot.getPriority", 0, 0, arguments.length);
    return this._delegate.priority;
  }
  forEach(action) {
    validateArgCount("DataSnapshot.forEach", 1, 1, arguments.length);
    validateCallback("DataSnapshot.forEach", "action", action, false);
    return this._delegate.forEach((expDataSnapshot) => action(new DataSnapshot(this._database, expDataSnapshot)));
  }
  hasChildren() {
    validateArgCount("DataSnapshot.hasChildren", 0, 0, arguments.length);
    return this._delegate.hasChildren();
  }
  get key() {
    return this._delegate.key;
  }
  numChildren() {
    validateArgCount("DataSnapshot.numChildren", 0, 0, arguments.length);
    return this._delegate.size;
  }
  getRef() {
    validateArgCount("DataSnapshot.ref", 0, 0, arguments.length);
    return new Reference(this._database, this._delegate.ref);
  }
  get ref() {
    return this.getRef();
  }
};
var Query = class {
  constructor(database, _delegate) {
    this.database = database;
    this._delegate = _delegate;
  }
  on(eventType, callback, cancelCallbackOrContext, context) {
    var _a2;
    validateArgCount("Query.on", 2, 4, arguments.length);
    validateCallback("Query.on", "callback", callback, false);
    const ret = Query.getCancelAndContextArgs_("Query.on", cancelCallbackOrContext, context);
    const valueCallback = (expSnapshot, previousChildName) => {
      callback.call(ret.context, new DataSnapshot(this.database, expSnapshot), previousChildName);
    };
    valueCallback.userCallback = callback;
    valueCallback.context = ret.context;
    const cancelCallback = (_a2 = ret.cancel) === null || _a2 === void 0 ? void 0 : _a2.bind(ret.context);
    switch (eventType) {
      case "value":
        onValue(this._delegate, valueCallback, cancelCallback);
        return callback;
      case "child_added":
        onChildAdded(this._delegate, valueCallback, cancelCallback);
        return callback;
      case "child_removed":
        onChildRemoved(this._delegate, valueCallback, cancelCallback);
        return callback;
      case "child_changed":
        onChildChanged(this._delegate, valueCallback, cancelCallback);
        return callback;
      case "child_moved":
        onChildMoved(this._delegate, valueCallback, cancelCallback);
        return callback;
      default:
        throw new Error(errorPrefix("Query.on", "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".');
    }
  }
  off(eventType, callback, context) {
    validateArgCount("Query.off", 0, 3, arguments.length);
    validateEventType("Query.off", eventType, true);
    validateCallback("Query.off", "callback", callback, true);
    validateContextObject("Query.off", "context", context, true);
    if (callback) {
      const valueCallback = () => {
      };
      valueCallback.userCallback = callback;
      valueCallback.context = context;
      off(this._delegate, eventType, valueCallback);
    } else {
      off(this._delegate, eventType);
    }
  }
  get() {
    return get(this._delegate).then((expSnapshot) => {
      return new DataSnapshot(this.database, expSnapshot);
    });
  }
  once(eventType, callback, failureCallbackOrContext, context) {
    validateArgCount("Query.once", 1, 4, arguments.length);
    validateCallback("Query.once", "callback", callback, true);
    const ret = Query.getCancelAndContextArgs_("Query.once", failureCallbackOrContext, context);
    const deferred = new Deferred();
    const valueCallback = (expSnapshot, previousChildName) => {
      const result = new DataSnapshot(this.database, expSnapshot);
      if (callback) {
        callback.call(ret.context, result, previousChildName);
      }
      deferred.resolve(result);
    };
    valueCallback.userCallback = callback;
    valueCallback.context = ret.context;
    const cancelCallback = (error) => {
      if (ret.cancel) {
        ret.cancel.call(ret.context, error);
      }
      deferred.reject(error);
    };
    switch (eventType) {
      case "value":
        onValue(this._delegate, valueCallback, cancelCallback, {
          onlyOnce: true
        });
        break;
      case "child_added":
        onChildAdded(this._delegate, valueCallback, cancelCallback, {
          onlyOnce: true
        });
        break;
      case "child_removed":
        onChildRemoved(this._delegate, valueCallback, cancelCallback, {
          onlyOnce: true
        });
        break;
      case "child_changed":
        onChildChanged(this._delegate, valueCallback, cancelCallback, {
          onlyOnce: true
        });
        break;
      case "child_moved":
        onChildMoved(this._delegate, valueCallback, cancelCallback, {
          onlyOnce: true
        });
        break;
      default:
        throw new Error(errorPrefix("Query.once", "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".');
    }
    return deferred.promise;
  }
  limitToFirst(limit) {
    validateArgCount("Query.limitToFirst", 1, 1, arguments.length);
    return new Query(this.database, query(this._delegate, limitToFirst(limit)));
  }
  limitToLast(limit) {
    validateArgCount("Query.limitToLast", 1, 1, arguments.length);
    return new Query(this.database, query(this._delegate, limitToLast(limit)));
  }
  orderByChild(path) {
    validateArgCount("Query.orderByChild", 1, 1, arguments.length);
    return new Query(this.database, query(this._delegate, orderByChild(path)));
  }
  orderByKey() {
    validateArgCount("Query.orderByKey", 0, 0, arguments.length);
    return new Query(this.database, query(this._delegate, orderByKey()));
  }
  orderByPriority() {
    validateArgCount("Query.orderByPriority", 0, 0, arguments.length);
    return new Query(this.database, query(this._delegate, orderByPriority()));
  }
  orderByValue() {
    validateArgCount("Query.orderByValue", 0, 0, arguments.length);
    return new Query(this.database, query(this._delegate, orderByValue()));
  }
  startAt(value = null, name19) {
    validateArgCount("Query.startAt", 0, 2, arguments.length);
    return new Query(this.database, query(this._delegate, startAt(value, name19)));
  }
  startAfter(value = null, name19) {
    validateArgCount("Query.startAfter", 0, 2, arguments.length);
    return new Query(this.database, query(this._delegate, startAfter(value, name19)));
  }
  endAt(value = null, name19) {
    validateArgCount("Query.endAt", 0, 2, arguments.length);
    return new Query(this.database, query(this._delegate, endAt(value, name19)));
  }
  endBefore(value = null, name19) {
    validateArgCount("Query.endBefore", 0, 2, arguments.length);
    return new Query(this.database, query(this._delegate, endBefore(value, name19)));
  }
  equalTo(value, name19) {
    validateArgCount("Query.equalTo", 1, 2, arguments.length);
    return new Query(this.database, query(this._delegate, equalTo(value, name19)));
  }
  toString() {
    validateArgCount("Query.toString", 0, 0, arguments.length);
    return this._delegate.toString();
  }
  toJSON() {
    validateArgCount("Query.toJSON", 0, 1, arguments.length);
    return this._delegate.toJSON();
  }
  isEqual(other) {
    validateArgCount("Query.isEqual", 1, 1, arguments.length);
    if (!(other instanceof Query)) {
      const error = "Query.isEqual failed: First argument must be an instance of firebase.database.Query.";
      throw new Error(error);
    }
    return this._delegate.isEqual(other._delegate);
  }
  static getCancelAndContextArgs_(fnName, cancelOrContext, context) {
    const ret = { cancel: void 0, context: void 0 };
    if (cancelOrContext && context) {
      ret.cancel = cancelOrContext;
      validateCallback(fnName, "cancel", ret.cancel, true);
      ret.context = context;
      validateContextObject(fnName, "context", ret.context, true);
    } else if (cancelOrContext) {
      if (typeof cancelOrContext === "object" && cancelOrContext !== null) {
        ret.context = cancelOrContext;
      } else if (typeof cancelOrContext === "function") {
        ret.cancel = cancelOrContext;
      } else {
        throw new Error(errorPrefix(fnName, "cancelOrContext") + " must either be a cancel callback or a context object.");
      }
    }
    return ret;
  }
  get ref() {
    return new Reference(this.database, new ReferenceImpl(this._delegate._repo, this._delegate._path));
  }
};
var Reference = class extends Query {
  constructor(database, _delegate) {
    super(database, new QueryImpl(_delegate._repo, _delegate._path, new QueryParams(), false));
    this.database = database;
    this._delegate = _delegate;
  }
  getKey() {
    validateArgCount("Reference.key", 0, 0, arguments.length);
    return this._delegate.key;
  }
  child(pathString) {
    validateArgCount("Reference.child", 1, 1, arguments.length);
    if (typeof pathString === "number") {
      pathString = String(pathString);
    }
    return new Reference(this.database, child(this._delegate, pathString));
  }
  getParent() {
    validateArgCount("Reference.parent", 0, 0, arguments.length);
    const parent2 = this._delegate.parent;
    return parent2 ? new Reference(this.database, parent2) : null;
  }
  getRoot() {
    validateArgCount("Reference.root", 0, 0, arguments.length);
    return new Reference(this.database, this._delegate.root);
  }
  set(newVal, onComplete) {
    validateArgCount("Reference.set", 1, 2, arguments.length);
    validateCallback("Reference.set", "onComplete", onComplete, true);
    const result = set(this._delegate, newVal);
    if (onComplete) {
      result.then(() => onComplete(null), (error) => onComplete(error));
    }
    return result;
  }
  update(values, onComplete) {
    validateArgCount("Reference.update", 1, 2, arguments.length);
    if (Array.isArray(values)) {
      const newObjectToMerge = {};
      for (let i = 0; i < values.length; ++i) {
        newObjectToMerge["" + i] = values[i];
      }
      values = newObjectToMerge;
      warn("Passing an Array to Firebase.update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.");
    }
    validateWritablePath("Reference.update", this._delegate._path);
    validateCallback("Reference.update", "onComplete", onComplete, true);
    const result = update(this._delegate, values);
    if (onComplete) {
      result.then(() => onComplete(null), (error) => onComplete(error));
    }
    return result;
  }
  setWithPriority(newVal, newPriority, onComplete) {
    validateArgCount("Reference.setWithPriority", 2, 3, arguments.length);
    validateCallback("Reference.setWithPriority", "onComplete", onComplete, true);
    const result = setWithPriority(this._delegate, newVal, newPriority);
    if (onComplete) {
      result.then(() => onComplete(null), (error) => onComplete(error));
    }
    return result;
  }
  remove(onComplete) {
    validateArgCount("Reference.remove", 0, 1, arguments.length);
    validateCallback("Reference.remove", "onComplete", onComplete, true);
    const result = remove(this._delegate);
    if (onComplete) {
      result.then(() => onComplete(null), (error) => onComplete(error));
    }
    return result;
  }
  transaction(transactionUpdate, onComplete, applyLocally) {
    validateArgCount("Reference.transaction", 1, 3, arguments.length);
    validateCallback("Reference.transaction", "transactionUpdate", transactionUpdate, false);
    validateCallback("Reference.transaction", "onComplete", onComplete, true);
    validateBoolean("Reference.transaction", "applyLocally", applyLocally, true);
    const result = runTransaction(this._delegate, transactionUpdate, {
      applyLocally
    }).then((transactionResult) => new TransactionResult(transactionResult.committed, new DataSnapshot(this.database, transactionResult.snapshot)));
    if (onComplete) {
      result.then((transactionResult) => onComplete(null, transactionResult.committed, transactionResult.snapshot), (error) => onComplete(error, false, null));
    }
    return result;
  }
  setPriority(priority, onComplete) {
    validateArgCount("Reference.setPriority", 1, 2, arguments.length);
    validateCallback("Reference.setPriority", "onComplete", onComplete, true);
    const result = setPriority(this._delegate, priority);
    if (onComplete) {
      result.then(() => onComplete(null), (error) => onComplete(error));
    }
    return result;
  }
  push(value, onComplete) {
    validateArgCount("Reference.push", 0, 2, arguments.length);
    validateCallback("Reference.push", "onComplete", onComplete, true);
    const expPromise = push(this._delegate, value);
    const promise = expPromise.then((expRef) => new Reference(this.database, expRef));
    if (onComplete) {
      promise.then(() => onComplete(null), (error) => onComplete(error));
    }
    const result = new Reference(this.database, expPromise);
    result.then = promise.then.bind(promise);
    result.catch = promise.catch.bind(promise, void 0);
    return result;
  }
  onDisconnect() {
    validateWritablePath("Reference.onDisconnect", this._delegate._path);
    return new OnDisconnect2(new OnDisconnect(this._delegate._repo, this._delegate._path));
  }
  get key() {
    return this.getKey();
  }
  get parent() {
    return this.getParent();
  }
  get root() {
    return this.getRoot();
  }
};
var Database = class {
  constructor(_delegate, app) {
    this._delegate = _delegate;
    this.app = app;
    this.INTERNAL = {
      delete: () => this._delegate._delete(),
      forceWebSockets,
      forceLongPolling
    };
  }
  useEmulator(host, port, options = {}) {
    connectDatabaseEmulator(this._delegate, host, port, options);
  }
  ref(path) {
    validateArgCount("database.ref", 0, 1, arguments.length);
    if (path instanceof Reference) {
      const childRef = refFromURL(this._delegate, path.toString());
      return new Reference(this, childRef);
    } else {
      const childRef = ref(this._delegate, path);
      return new Reference(this, childRef);
    }
  }
  refFromURL(url) {
    const apiName = "database.refFromURL";
    validateArgCount(apiName, 1, 1, arguments.length);
    const childRef = refFromURL(this._delegate, url);
    return new Reference(this, childRef);
  }
  goOffline() {
    validateArgCount("database.goOffline", 0, 0, arguments.length);
    return goOffline(this._delegate);
  }
  goOnline() {
    validateArgCount("database.goOnline", 0, 0, arguments.length);
    return goOnline(this._delegate);
  }
};
Database.ServerValue = {
  TIMESTAMP: serverTimestamp(),
  increment: (delta) => increment(delta)
};
function initStandalone({ app, url, version: version19, customAuthImpl, namespace, nodeAdmin = false }) {
  setSDKVersion(version19);
  const authProvider = new Provider("auth-internal", new ComponentContainer("database-standalone"));
  authProvider.setComponent(new Component("auth-internal", () => customAuthImpl, "PRIVATE"));
  return {
    instance: new Database(repoManagerDatabaseFromApp(app, authProvider, void 0, url, nodeAdmin), app),
    namespace
  };
}
var INTERNAL = Object.freeze({
  __proto__: null,
  initStandalone
});
var ServerValue = Database.ServerValue;
function registerDatabase(instance) {
  instance.INTERNAL.registerComponent(new Component("database-compat", (container, { instanceIdentifier: url }) => {
    const app = container.getProvider("app-compat").getImmediate();
    const databaseExp = container.getProvider("database").getImmediate({ identifier: url });
    return new Database(databaseExp, app);
  }, "PUBLIC").setServiceProps({
    Reference,
    Query,
    Database,
    DataSnapshot,
    enableLogging,
    INTERNAL,
    ServerValue
  }).setMultipleInstances(true));
  instance.registerVersion(name6, version6);
}
registerDatabase(firebase);

// node_modules/@firebase/webchannel-wrapper/dist/index.esm2017.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var esm = {};
var k;
var goog = goog || {};
var l = commonjsGlobal || self;
function aa() {
}
function ba(a) {
  var b = typeof a;
  b = b != "object" ? b : a ? Array.isArray(a) ? "array" : b : "null";
  return b == "array" || b == "object" && typeof a.length == "number";
}
function p(a) {
  var b = typeof a;
  return b == "object" && a != null || b == "function";
}
function da(a) {
  return Object.prototype.hasOwnProperty.call(a, ea) && a[ea] || (a[ea] = ++fa);
}
var ea = "closure_uid_" + (1e9 * Math.random() >>> 0);
var fa = 0;
function ha(a, b, c) {
  return a.call.apply(a.bind, arguments);
}
function ia(a, b, c) {
  if (!a)
    throw Error();
  if (2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var e = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(e, d);
      return a.apply(b, e);
    };
  }
  return function() {
    return a.apply(b, arguments);
  };
}
function q(a, b, c) {
  Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? q = ha : q = ia;
  return q.apply(null, arguments);
}
function ja(a, b) {
  var c = Array.prototype.slice.call(arguments, 1);
  return function() {
    var d = c.slice();
    d.push.apply(d, arguments);
    return a.apply(this, d);
  };
}
function t(a, b) {
  function c() {
  }
  c.prototype = b.prototype;
  a.Z = b.prototype;
  a.prototype = new c();
  a.prototype.constructor = a;
  a.Vb = function(d, e, f) {
    for (var h = Array(arguments.length - 2), n = 2; n < arguments.length; n++)
      h[n - 2] = arguments[n];
    return b.prototype[e].apply(d, h);
  };
}
function v() {
  this.s = this.s;
  this.o = this.o;
}
var ka = 0;
var la = {};
v.prototype.s = false;
v.prototype.na = function() {
  if (!this.s && (this.s = true, this.M(), ka != 0)) {
    var a = da(this);
    delete la[a];
  }
};
v.prototype.M = function() {
  if (this.o)
    for (; this.o.length; )
      this.o.shift()();
};
var ma = Array.prototype.indexOf ? function(a, b) {
  return Array.prototype.indexOf.call(a, b, void 0);
} : function(a, b) {
  if (typeof a === "string")
    return typeof b !== "string" || b.length != 1 ? -1 : a.indexOf(b, 0);
  for (let c = 0; c < a.length; c++)
    if (c in a && a[c] === b)
      return c;
  return -1;
};
var na = Array.prototype.forEach ? function(a, b, c) {
  Array.prototype.forEach.call(a, b, c);
} : function(a, b, c) {
  const d = a.length, e = typeof a === "string" ? a.split("") : a;
  for (let f = 0; f < d; f++)
    f in e && b.call(c, e[f], f, a);
};
function oa(a) {
  a: {
    var b = pa;
    const c = a.length, d = typeof a === "string" ? a.split("") : a;
    for (let e = 0; e < c; e++)
      if (e in d && b.call(void 0, d[e], e, a)) {
        b = e;
        break a;
      }
    b = -1;
  }
  return 0 > b ? null : typeof a === "string" ? a.charAt(b) : a[b];
}
function qa(a) {
  return Array.prototype.concat.apply([], arguments);
}
function ra(a) {
  const b = a.length;
  if (0 < b) {
    const c = Array(b);
    for (let d = 0; d < b; d++)
      c[d] = a[d];
    return c;
  }
  return [];
}
function sa(a) {
  return /^[\s\xa0]*$/.test(a);
}
var ta = String.prototype.trim ? function(a) {
  return a.trim();
} : function(a) {
  return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
};
function w(a, b) {
  return a.indexOf(b) != -1;
}
function ua(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
var x;
a: {
  va2 = l.navigator;
  if (va2) {
    wa2 = va2.userAgent;
    if (wa2) {
      x = wa2;
      break a;
    }
  }
  x = "";
}
var va2;
var wa2;
function xa(a, b, c) {
  for (const d in a)
    b.call(c, a[d], d, a);
}
function ya(a) {
  const b = {};
  for (const c in a)
    b[c] = a[c];
  return b;
}
var za = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Aa(a, b) {
  let c, d;
  for (let e = 1; e < arguments.length; e++) {
    d = arguments[e];
    for (c in d)
      a[c] = d[c];
    for (let f = 0; f < za.length; f++)
      c = za[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
  }
}
function Ca(a) {
  Ca[" "](a);
  return a;
}
Ca[" "] = aa;
function Fa(a) {
  var b = Ga;
  return Object.prototype.hasOwnProperty.call(b, 9) ? b[9] : b[9] = a(9);
}
var Ha = w(x, "Opera");
var y = w(x, "Trident") || w(x, "MSIE");
var Ia = w(x, "Edge");
var Ja = Ia || y;
var Ka = w(x, "Gecko") && !(w(x.toLowerCase(), "webkit") && !w(x, "Edge")) && !(w(x, "Trident") || w(x, "MSIE")) && !w(x, "Edge");
var La = w(x.toLowerCase(), "webkit") && !w(x, "Edge");
function Ma() {
  var a = l.document;
  return a ? a.documentMode : void 0;
}
var Na;
a: {
  Oa2 = "", Pa2 = function() {
    var a = x;
    if (Ka)
      return /rv:([^\);]+)(\)|;)/.exec(a);
    if (Ia)
      return /Edge\/([\d\.]+)/.exec(a);
    if (y)
      return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
    if (La)
      return /WebKit\/(\S+)/.exec(a);
    if (Ha)
      return /(?:Version)[ \/]?(\S+)/.exec(a);
  }();
  Pa2 && (Oa2 = Pa2 ? Pa2[1] : "");
  if (y) {
    Qa2 = Ma();
    if (Qa2 != null && Qa2 > parseFloat(Oa2)) {
      Na = String(Qa2);
      break a;
    }
  }
  Na = Oa2;
}
var Oa2;
var Pa2;
var Qa2;
var Ga = {};
function Ra() {
  return Fa(function() {
    let a = 0;
    const b = ta(String(Na)).split("."), c = ta("9").split("."), d = Math.max(b.length, c.length);
    for (let h = 0; a == 0 && h < d; h++) {
      var e = b[h] || "", f = c[h] || "";
      do {
        e = /(\d*)(\D*)(.*)/.exec(e) || ["", "", "", ""];
        f = /(\d*)(\D*)(.*)/.exec(f) || ["", "", "", ""];
        if (e[0].length == 0 && f[0].length == 0)
          break;
        a = ua(e[1].length == 0 ? 0 : parseInt(e[1], 10), f[1].length == 0 ? 0 : parseInt(f[1], 10)) || ua(e[2].length == 0, f[2].length == 0) || ua(e[2], f[2]);
        e = e[3];
        f = f[3];
      } while (a == 0);
    }
    return 0 <= a;
  });
}
var Sa;
if (l.document && y) {
  Ta2 = Ma();
  Sa = Ta2 ? Ta2 : parseInt(Na, 10) || void 0;
} else
  Sa = void 0;
var Ta2;
var Ua = Sa;
var Va = function() {
  if (!l.addEventListener || !Object.defineProperty)
    return false;
  var a = false, b = Object.defineProperty({}, "passive", { get: function() {
    a = true;
  } });
  try {
    l.addEventListener("test", aa, b), l.removeEventListener("test", aa, b);
  } catch (c) {
  }
  return a;
}();
function z(a, b) {
  this.type = a;
  this.g = this.target = b;
  this.defaultPrevented = false;
}
z.prototype.h = function() {
  this.defaultPrevented = true;
};
function A(a, b) {
  z.call(this, a ? a.type : "");
  this.relatedTarget = this.g = this.target = null;
  this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
  this.key = "";
  this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
  this.state = null;
  this.pointerId = 0;
  this.pointerType = "";
  this.i = null;
  if (a) {
    var c = this.type = a.type, d = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;
    this.target = a.target || a.srcElement;
    this.g = b;
    if (b = a.relatedTarget) {
      if (Ka) {
        a: {
          try {
            Ca(b.nodeName);
            var e = true;
            break a;
          } catch (f) {
          }
          e = false;
        }
        e || (b = null);
      }
    } else
      c == "mouseover" ? b = a.fromElement : c == "mouseout" && (b = a.toElement);
    this.relatedTarget = b;
    d ? (this.clientX = d.clientX !== void 0 ? d.clientX : d.pageX, this.clientY = d.clientY !== void 0 ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0) : (this.clientX = a.clientX !== void 0 ? a.clientX : a.pageX, this.clientY = a.clientY !== void 0 ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);
    this.button = a.button;
    this.key = a.key || "";
    this.ctrlKey = a.ctrlKey;
    this.altKey = a.altKey;
    this.shiftKey = a.shiftKey;
    this.metaKey = a.metaKey;
    this.pointerId = a.pointerId || 0;
    this.pointerType = typeof a.pointerType === "string" ? a.pointerType : Wa[a.pointerType] || "";
    this.state = a.state;
    this.i = a;
    a.defaultPrevented && A.Z.h.call(this);
  }
}
t(A, z);
var Wa = { 2: "touch", 3: "pen", 4: "mouse" };
A.prototype.h = function() {
  A.Z.h.call(this);
  var a = this.i;
  a.preventDefault ? a.preventDefault() : a.returnValue = false;
};
var B = "closure_listenable_" + (1e6 * Math.random() | 0);
var Xa = 0;
function Ya(a, b, c, d, e) {
  this.listener = a;
  this.proxy = null;
  this.src = b;
  this.type = c;
  this.capture = !!d;
  this.ia = e;
  this.key = ++Xa;
  this.ca = this.fa = false;
}
function Za(a) {
  a.ca = true;
  a.listener = null;
  a.proxy = null;
  a.src = null;
  a.ia = null;
}
function $a(a) {
  this.src = a;
  this.g = {};
  this.h = 0;
}
$a.prototype.add = function(a, b, c, d, e) {
  var f = a.toString();
  a = this.g[f];
  a || (a = this.g[f] = [], this.h++);
  var h = ab(a, b, d, e);
  -1 < h ? (b = a[h], c || (b.fa = false)) : (b = new Ya(b, this.src, f, !!d, e), b.fa = c, a.push(b));
  return b;
};
function bb(a, b) {
  var c = b.type;
  if (c in a.g) {
    var d = a.g[c], e = ma(d, b), f;
    (f = 0 <= e) && Array.prototype.splice.call(d, e, 1);
    f && (Za(b), a.g[c].length == 0 && (delete a.g[c], a.h--));
  }
}
function ab(a, b, c, d) {
  for (var e = 0; e < a.length; ++e) {
    var f = a[e];
    if (!f.ca && f.listener == b && f.capture == !!c && f.ia == d)
      return e;
  }
  return -1;
}
var cb = "closure_lm_" + (1e6 * Math.random() | 0);
var db = {};
function fb(a, b, c, d, e) {
  if (d && d.once)
    return gb(a, b, c, d, e);
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      fb(a, b[f], c, d, e);
    return null;
  }
  c = hb(c);
  return a && a[B] ? a.N(b, c, p(d) ? !!d.capture : !!d, e) : ib(a, b, c, false, d, e);
}
function ib(a, b, c, d, e, f) {
  if (!b)
    throw Error("Invalid event type");
  var h = p(e) ? !!e.capture : !!e, n = jb(a);
  n || (a[cb] = n = new $a(a));
  c = n.add(b, c, d, h, f);
  if (c.proxy)
    return c;
  d = kb();
  c.proxy = d;
  d.src = a;
  d.listener = c;
  if (a.addEventListener)
    Va || (e = h), e === void 0 && (e = false), a.addEventListener(b.toString(), d, e);
  else if (a.attachEvent)
    a.attachEvent(lb(b.toString()), d);
  else if (a.addListener && a.removeListener)
    a.addListener(d);
  else
    throw Error("addEventListener and attachEvent are unavailable.");
  return c;
}
function kb() {
  function a(c) {
    return b.call(a.src, a.listener, c);
  }
  var b = mb;
  return a;
}
function gb(a, b, c, d, e) {
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      gb(a, b[f], c, d, e);
    return null;
  }
  c = hb(c);
  return a && a[B] ? a.O(b, c, p(d) ? !!d.capture : !!d, e) : ib(a, b, c, true, d, e);
}
function nb(a, b, c, d, e) {
  if (Array.isArray(b))
    for (var f = 0; f < b.length; f++)
      nb(a, b[f], c, d, e);
  else
    (d = p(d) ? !!d.capture : !!d, c = hb(c), a && a[B]) ? (a = a.i, b = String(b).toString(), b in a.g && (f = a.g[b], c = ab(f, c, d, e), -1 < c && (Za(f[c]), Array.prototype.splice.call(f, c, 1), f.length == 0 && (delete a.g[b], a.h--)))) : a && (a = jb(a)) && (b = a.g[b.toString()], a = -1, b && (a = ab(b, c, d, e)), (c = -1 < a ? b[a] : null) && ob(c));
}
function ob(a) {
  if (typeof a !== "number" && a && !a.ca) {
    var b = a.src;
    if (b && b[B])
      bb(b.i, a);
    else {
      var c = a.type, d = a.proxy;
      b.removeEventListener ? b.removeEventListener(c, d, a.capture) : b.detachEvent ? b.detachEvent(lb(c), d) : b.addListener && b.removeListener && b.removeListener(d);
      (c = jb(b)) ? (bb(c, a), c.h == 0 && (c.src = null, b[cb] = null)) : Za(a);
    }
  }
}
function lb(a) {
  return a in db ? db[a] : db[a] = "on" + a;
}
function mb(a, b) {
  if (a.ca)
    a = true;
  else {
    b = new A(b, this);
    var c = a.listener, d = a.ia || a.src;
    a.fa && ob(a);
    a = c.call(d, b);
  }
  return a;
}
function jb(a) {
  a = a[cb];
  return a instanceof $a ? a : null;
}
var pb = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
function hb(a) {
  if (typeof a === "function")
    return a;
  a[pb] || (a[pb] = function(b) {
    return a.handleEvent(b);
  });
  return a[pb];
}
function C() {
  v.call(this);
  this.i = new $a(this);
  this.P = this;
  this.I = null;
}
t(C, v);
C.prototype[B] = true;
C.prototype.removeEventListener = function(a, b, c, d) {
  nb(this, a, b, c, d);
};
function D(a, b) {
  var c, d = a.I;
  if (d)
    for (c = []; d; d = d.I)
      c.push(d);
  a = a.P;
  d = b.type || b;
  if (typeof b === "string")
    b = new z(b, a);
  else if (b instanceof z)
    b.target = b.target || a;
  else {
    var e = b;
    b = new z(d, a);
    Aa(b, e);
  }
  e = true;
  if (c)
    for (var f = c.length - 1; 0 <= f; f--) {
      var h = b.g = c[f];
      e = qb(h, d, true, b) && e;
    }
  h = b.g = a;
  e = qb(h, d, true, b) && e;
  e = qb(h, d, false, b) && e;
  if (c)
    for (f = 0; f < c.length; f++)
      h = b.g = c[f], e = qb(h, d, false, b) && e;
}
C.prototype.M = function() {
  C.Z.M.call(this);
  if (this.i) {
    var a = this.i, c;
    for (c in a.g) {
      for (var d = a.g[c], e = 0; e < d.length; e++)
        Za(d[e]);
      delete a.g[c];
      a.h--;
    }
  }
  this.I = null;
};
C.prototype.N = function(a, b, c, d) {
  return this.i.add(String(a), b, false, c, d);
};
C.prototype.O = function(a, b, c, d) {
  return this.i.add(String(a), b, true, c, d);
};
function qb(a, b, c, d) {
  b = a.i.g[String(b)];
  if (!b)
    return true;
  b = b.concat();
  for (var e = true, f = 0; f < b.length; ++f) {
    var h = b[f];
    if (h && !h.ca && h.capture == c) {
      var n = h.listener, u = h.ia || h.src;
      h.fa && bb(a.i, h);
      e = n.call(u, d) !== false && e;
    }
  }
  return e && !d.defaultPrevented;
}
var rb = l.JSON.stringify;
function sb() {
  var a = tb;
  let b = null;
  a.g && (b = a.g, a.g = a.g.next, a.g || (a.h = null), b.next = null);
  return b;
}
var ub = class {
  constructor() {
    this.h = this.g = null;
  }
  add(a, b) {
    const c = vb.get();
    c.set(a, b);
    this.h ? this.h.next = c : this.g = c;
    this.h = c;
  }
};
var vb = new class {
  constructor(a, b) {
    this.i = a;
    this.j = b;
    this.h = 0;
    this.g = null;
  }
  get() {
    let a;
    0 < this.h ? (this.h--, a = this.g, this.g = a.next, a.next = null) : a = this.i();
    return a;
  }
}(() => new wb(), (a) => a.reset());
var wb = class {
  constructor() {
    this.next = this.g = this.h = null;
  }
  set(a, b) {
    this.h = a;
    this.g = b;
    this.next = null;
  }
  reset() {
    this.next = this.g = this.h = null;
  }
};
function yb(a) {
  l.setTimeout(() => {
    throw a;
  }, 0);
}
function zb(a, b) {
  Ab || Bb();
  Cb || (Ab(), Cb = true);
  tb.add(a, b);
}
var Ab;
function Bb() {
  var a = l.Promise.resolve(void 0);
  Ab = function() {
    a.then(Db);
  };
}
var Cb = false;
var tb = new ub();
function Db() {
  for (var a; a = sb(); ) {
    try {
      a.h.call(a.g);
    } catch (c) {
      yb(c);
    }
    var b = vb;
    b.j(a);
    100 > b.h && (b.h++, a.next = b.g, b.g = a);
  }
  Cb = false;
}
function Eb(a, b) {
  C.call(this);
  this.h = a || 1;
  this.g = b || l;
  this.j = q(this.kb, this);
  this.l = Date.now();
}
t(Eb, C);
k = Eb.prototype;
k.da = false;
k.S = null;
k.kb = function() {
  if (this.da) {
    var a = Date.now() - this.l;
    0 < a && a < 0.8 * this.h ? this.S = this.g.setTimeout(this.j, this.h - a) : (this.S && (this.g.clearTimeout(this.S), this.S = null), D(this, "tick"), this.da && (Fb(this), this.start()));
  }
};
k.start = function() {
  this.da = true;
  this.S || (this.S = this.g.setTimeout(this.j, this.h), this.l = Date.now());
};
function Fb(a) {
  a.da = false;
  a.S && (a.g.clearTimeout(a.S), a.S = null);
}
k.M = function() {
  Eb.Z.M.call(this);
  Fb(this);
  delete this.g;
};
function Gb(a, b, c) {
  if (typeof a === "function")
    c && (a = q(a, c));
  else if (a && typeof a.handleEvent == "function")
    a = q(a.handleEvent, a);
  else
    throw Error("Invalid listener argument");
  return 2147483647 < Number(b) ? -1 : l.setTimeout(a, b || 0);
}
function Hb(a) {
  a.g = Gb(() => {
    a.g = null;
    a.i && (a.i = false, Hb(a));
  }, a.j);
  const b = a.h;
  a.h = null;
  a.m.apply(null, b);
}
var Ib = class extends v {
  constructor(a, b) {
    super();
    this.m = a;
    this.j = b;
    this.h = null;
    this.i = false;
    this.g = null;
  }
  l(a) {
    this.h = arguments;
    this.g ? this.i = true : Hb(this);
  }
  M() {
    super.M();
    this.g && (l.clearTimeout(this.g), this.g = null, this.i = false, this.h = null);
  }
};
function E(a) {
  v.call(this);
  this.h = a;
  this.g = {};
}
t(E, v);
var Jb = [];
function Kb(a, b, c, d) {
  Array.isArray(c) || (c && (Jb[0] = c.toString()), c = Jb);
  for (var e = 0; e < c.length; e++) {
    var f = fb(b, c[e], d || a.handleEvent, false, a.h || a);
    if (!f)
      break;
    a.g[f.key] = f;
  }
}
function Lb(a) {
  xa(a.g, function(b, c) {
    this.g.hasOwnProperty(c) && ob(b);
  }, a);
  a.g = {};
}
E.prototype.M = function() {
  E.Z.M.call(this);
  Lb(this);
};
E.prototype.handleEvent = function() {
  throw Error("EventHandler.handleEvent not implemented");
};
function Mb() {
  this.g = true;
}
Mb.prototype.Aa = function() {
  this.g = false;
};
function Nb(a, b, c, d, e, f) {
  a.info(function() {
    if (a.g)
      if (f) {
        var h = "";
        for (var n = f.split("&"), u = 0; u < n.length; u++) {
          var m = n[u].split("=");
          if (1 < m.length) {
            var r = m[0];
            m = m[1];
            var G2 = r.split("_");
            h = 2 <= G2.length && G2[1] == "type" ? h + (r + "=" + m + "&") : h + (r + "=redacted&");
          }
        }
      } else
        h = null;
    else
      h = f;
    return "XMLHTTP REQ (" + d + ") [attempt " + e + "]: " + b + "\n" + c + "\n" + h;
  });
}
function Ob(a, b, c, d, e, f, h) {
  a.info(function() {
    return "XMLHTTP RESP (" + d + ") [ attempt " + e + "]: " + b + "\n" + c + "\n" + f + " " + h;
  });
}
function F(a, b, c, d) {
  a.info(function() {
    return "XMLHTTP TEXT (" + b + "): " + Pb(a, c) + (d ? " " + d : "");
  });
}
function Qb(a, b) {
  a.info(function() {
    return "TIMEOUT: " + b;
  });
}
Mb.prototype.info = function() {
};
function Pb(a, b) {
  if (!a.g)
    return b;
  if (!b)
    return null;
  try {
    var c = JSON.parse(b);
    if (c) {
      for (a = 0; a < c.length; a++)
        if (Array.isArray(c[a])) {
          var d = c[a];
          if (!(2 > d.length)) {
            var e = d[1];
            if (Array.isArray(e) && !(1 > e.length)) {
              var f = e[0];
              if (f != "noop" && f != "stop" && f != "close")
                for (var h = 1; h < e.length; h++)
                  e[h] = "";
            }
          }
        }
    }
    return rb(c);
  } catch (n) {
    return b;
  }
}
var H = {};
var Rb = null;
function Sb() {
  return Rb = Rb || new C();
}
H.Ma = "serverreachability";
function Tb(a) {
  z.call(this, H.Ma, a);
}
t(Tb, z);
function I(a) {
  const b = Sb();
  D(b, new Tb(b, a));
}
H.STAT_EVENT = "statevent";
function Ub(a, b) {
  z.call(this, H.STAT_EVENT, a);
  this.stat = b;
}
t(Ub, z);
function J(a) {
  const b = Sb();
  D(b, new Ub(b, a));
}
H.Na = "timingevent";
function Vb(a, b) {
  z.call(this, H.Na, a);
  this.size = b;
}
t(Vb, z);
function K(a, b) {
  if (typeof a !== "function")
    throw Error("Fn must not be null and must be a function");
  return l.setTimeout(function() {
    a();
  }, b);
}
var Wb = { NO_ERROR: 0, lb: 1, yb: 2, xb: 3, sb: 4, wb: 5, zb: 6, Ja: 7, TIMEOUT: 8, Cb: 9 };
var Xb = { qb: "complete", Mb: "success", Ka: "error", Ja: "abort", Eb: "ready", Fb: "readystatechange", TIMEOUT: "timeout", Ab: "incrementaldata", Db: "progress", tb: "downloadprogress", Ub: "uploadprogress" };
function Yb() {
}
Yb.prototype.h = null;
function Zb(a) {
  return a.h || (a.h = a.i());
}
function $b() {
}
var L = { OPEN: "a", pb: "b", Ka: "c", Bb: "d" };
function ac() {
  z.call(this, "d");
}
t(ac, z);
function bc() {
  z.call(this, "c");
}
t(bc, z);
var cc;
function dc() {
}
t(dc, Yb);
dc.prototype.g = function() {
  return new XMLHttpRequest();
};
dc.prototype.i = function() {
  return {};
};
cc = new dc();
function M(a, b, c, d) {
  this.l = a;
  this.j = b;
  this.m = c;
  this.X = d || 1;
  this.V = new E(this);
  this.P = ec;
  a = Ja ? 125 : void 0;
  this.W = new Eb(a);
  this.H = null;
  this.i = false;
  this.s = this.A = this.v = this.K = this.F = this.Y = this.B = null;
  this.D = [];
  this.g = null;
  this.C = 0;
  this.o = this.u = null;
  this.N = -1;
  this.I = false;
  this.O = 0;
  this.L = null;
  this.aa = this.J = this.$ = this.U = false;
  this.h = new fc();
}
function fc() {
  this.i = null;
  this.g = "";
  this.h = false;
}
var ec = 45e3;
var gc = {};
var hc = {};
k = M.prototype;
k.setTimeout = function(a) {
  this.P = a;
};
function ic(a, b, c) {
  a.K = 1;
  a.v = jc(N(b));
  a.s = c;
  a.U = true;
  kc(a, null);
}
function kc(a, b) {
  a.F = Date.now();
  lc(a);
  a.A = N(a.v);
  var c = a.A, d = a.X;
  Array.isArray(d) || (d = [String(d)]);
  mc(c.h, "t", d);
  a.C = 0;
  c = a.l.H;
  a.h = new fc();
  a.g = nc(a.l, c ? b : null, !a.s);
  0 < a.O && (a.L = new Ib(q(a.Ia, a, a.g), a.O));
  Kb(a.V, a.g, "readystatechange", a.gb);
  b = a.H ? ya(a.H) : {};
  a.s ? (a.u || (a.u = "POST"), b["Content-Type"] = "application/x-www-form-urlencoded", a.g.ea(a.A, a.u, a.s, b)) : (a.u = "GET", a.g.ea(a.A, a.u, null, b));
  I(1);
  Nb(a.j, a.u, a.A, a.m, a.X, a.s);
}
k.gb = function(a) {
  a = a.target;
  const b = this.L;
  b && O(a) == 3 ? b.l() : this.Ia(a);
};
k.Ia = function(a) {
  try {
    if (a == this.g)
      a: {
        const r = O(this.g);
        var b = this.g.Da();
        const G2 = this.g.ba();
        if (!(3 > r) && (r != 3 || Ja || this.g && (this.h.h || this.g.ga() || oc(this.g)))) {
          this.I || r != 4 || b == 7 || (b == 8 || 0 >= G2 ? I(3) : I(2));
          pc(this);
          var c = this.g.ba();
          this.N = c;
          b:
            if (qc(this)) {
              var d = oc(this.g);
              a = "";
              var e = d.length, f = O(this.g) == 4;
              if (!this.h.i) {
                if (typeof TextDecoder === "undefined") {
                  P(this);
                  rc(this);
                  var h = "";
                  break b;
                }
                this.h.i = new l.TextDecoder();
              }
              for (b = 0; b < e; b++)
                this.h.h = true, a += this.h.i.decode(d[b], { stream: f && b == e - 1 });
              d.splice(0, e);
              this.h.g += a;
              this.C = 0;
              h = this.h.g;
            } else
              h = this.g.ga();
          this.i = c == 200;
          Ob(this.j, this.u, this.A, this.m, this.X, r, c);
          if (this.i) {
            if (this.$ && !this.J) {
              b: {
                if (this.g) {
                  var n, u = this.g;
                  if ((n = u.g ? u.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !sa(n)) {
                    var m = n;
                    break b;
                  }
                }
                m = null;
              }
              if (c = m)
                F(this.j, this.m, c, "Initial handshake response via X-HTTP-Initial-Response"), this.J = true, sc(this, c);
              else {
                this.i = false;
                this.o = 3;
                J(12);
                P(this);
                rc(this);
                break a;
              }
            }
            this.U ? (tc(this, r, h), Ja && this.i && r == 3 && (Kb(this.V, this.W, "tick", this.fb), this.W.start())) : (F(this.j, this.m, h, null), sc(this, h));
            r == 4 && P(this);
            this.i && !this.I && (r == 4 ? uc(this.l, this) : (this.i = false, lc(this)));
          } else
            c == 400 && 0 < h.indexOf("Unknown SID") ? (this.o = 3, J(12)) : (this.o = 0, J(13)), P(this), rc(this);
        }
      }
  } catch (r) {
  } finally {
  }
};
function qc(a) {
  return a.g ? a.u == "GET" && a.K != 2 && a.l.Ba : false;
}
function tc(a, b, c) {
  let d = true, e;
  for (; !a.I && a.C < c.length; )
    if (e = vc(a, c), e == hc) {
      b == 4 && (a.o = 4, J(14), d = false);
      F(a.j, a.m, null, "[Incomplete Response]");
      break;
    } else if (e == gc) {
      a.o = 4;
      J(15);
      F(a.j, a.m, c, "[Invalid Chunk]");
      d = false;
      break;
    } else
      F(a.j, a.m, e, null), sc(a, e);
  qc(a) && e != hc && e != gc && (a.h.g = "", a.C = 0);
  b != 4 || c.length != 0 || a.h.h || (a.o = 1, J(16), d = false);
  a.i = a.i && d;
  d ? 0 < c.length && !a.aa && (a.aa = true, b = a.l, b.g == a && b.$ && !b.L && (b.h.info("Great, no buffering proxy detected. Bytes received: " + c.length), wc(b), b.L = true, J(11))) : (F(a.j, a.m, c, "[Invalid Chunked Response]"), P(a), rc(a));
}
k.fb = function() {
  if (this.g) {
    var a = O(this.g), b = this.g.ga();
    this.C < b.length && (pc(this), tc(this, a, b), this.i && a != 4 && lc(this));
  }
};
function vc(a, b) {
  var c = a.C, d = b.indexOf("\n", c);
  if (d == -1)
    return hc;
  c = Number(b.substring(c, d));
  if (isNaN(c))
    return gc;
  d += 1;
  if (d + c > b.length)
    return hc;
  b = b.substr(d, c);
  a.C = d + c;
  return b;
}
k.cancel = function() {
  this.I = true;
  P(this);
};
function lc(a) {
  a.Y = Date.now() + a.P;
  xc(a, a.P);
}
function xc(a, b) {
  if (a.B != null)
    throw Error("WatchDog timer not null");
  a.B = K(q(a.eb, a), b);
}
function pc(a) {
  a.B && (l.clearTimeout(a.B), a.B = null);
}
k.eb = function() {
  this.B = null;
  const a = Date.now();
  0 <= a - this.Y ? (Qb(this.j, this.A), this.K != 2 && (I(3), J(17)), P(this), this.o = 2, rc(this)) : xc(this, this.Y - a);
};
function rc(a) {
  a.l.G == 0 || a.I || uc(a.l, a);
}
function P(a) {
  pc(a);
  var b = a.L;
  b && typeof b.na == "function" && b.na();
  a.L = null;
  Fb(a.W);
  Lb(a.V);
  a.g && (b = a.g, a.g = null, b.abort(), b.na());
}
function sc(a, b) {
  try {
    var c = a.l;
    if (c.G != 0 && (c.g == a || yc(c.i, a))) {
      if (c.I = a.N, !a.J && yc(c.i, a) && c.G == 3) {
        try {
          var d = c.Ca.g.parse(b);
        } catch (m) {
          d = null;
        }
        if (Array.isArray(d) && d.length == 3) {
          var e = d;
          if (e[0] == 0)
            a: {
              if (!c.u) {
                if (c.g)
                  if (c.g.F + 3e3 < a.F)
                    zc(c), Ac(c);
                  else
                    break a;
                Bc(c);
                J(18);
              }
            }
          else
            c.ta = e[1], 0 < c.ta - c.U && 37500 > e[2] && c.N && c.A == 0 && !c.v && (c.v = K(q(c.ab, c), 6e3));
          if (1 >= Cc(c.i) && c.ka) {
            try {
              c.ka();
            } catch (m) {
            }
            c.ka = void 0;
          }
        } else
          Q(c, 11);
      } else if ((a.J || c.g == a) && zc(c), !sa(b))
        for (e = c.Ca.g.parse(b), b = 0; b < e.length; b++) {
          let m = e[b];
          c.U = m[0];
          m = m[1];
          if (c.G == 2)
            if (m[0] == "c") {
              c.J = m[1];
              c.la = m[2];
              const r = m[3];
              r != null && (c.ma = r, c.h.info("VER=" + c.ma));
              const G2 = m[4];
              G2 != null && (c.za = G2, c.h.info("SVER=" + c.za));
              const Da2 = m[5];
              Da2 != null && typeof Da2 === "number" && 0 < Da2 && (d = 1.5 * Da2, c.K = d, c.h.info("backChannelRequestTimeoutMs_=" + d));
              d = c;
              const ca2 = a.g;
              if (ca2) {
                const Ea2 = ca2.g ? ca2.g.getResponseHeader("X-Client-Wire-Protocol") : null;
                if (Ea2) {
                  var f = d.i;
                  !f.g && (w(Ea2, "spdy") || w(Ea2, "quic") || w(Ea2, "h2")) && (f.j = f.l, f.g = /* @__PURE__ */ new Set(), f.h && (Dc(f, f.h), f.h = null));
                }
                if (d.D) {
                  const xb = ca2.g ? ca2.g.getResponseHeader("X-HTTP-Session-Id") : null;
                  xb && (d.sa = xb, R(d.F, d.D, xb));
                }
              }
              c.G = 3;
              c.j && c.j.xa();
              c.$ && (c.O = Date.now() - a.F, c.h.info("Handshake RTT: " + c.O + "ms"));
              d = c;
              var h = a;
              d.oa = Ec(d, d.H ? d.la : null, d.W);
              if (h.J) {
                Fc(d.i, h);
                var n = h, u = d.K;
                u && n.setTimeout(u);
                n.B && (pc(n), lc(n));
                d.g = h;
              } else
                Gc(d);
              0 < c.l.length && Hc(c);
            } else
              m[0] != "stop" && m[0] != "close" || Q(c, 7);
          else
            c.G == 3 && (m[0] == "stop" || m[0] == "close" ? m[0] == "stop" ? Q(c, 7) : Ic(c) : m[0] != "noop" && c.j && c.j.wa(m), c.A = 0);
        }
    }
    I(4);
  } catch (m) {
  }
}
function Jc(a) {
  if (a.R && typeof a.R == "function")
    return a.R();
  if (typeof a === "string")
    return a.split("");
  if (ba(a)) {
    for (var b = [], c = a.length, d = 0; d < c; d++)
      b.push(a[d]);
    return b;
  }
  b = [];
  c = 0;
  for (d in a)
    b[c++] = a[d];
  return b;
}
function Kc(a, b) {
  if (a.forEach && typeof a.forEach == "function")
    a.forEach(b, void 0);
  else if (ba(a) || typeof a === "string")
    na(a, b, void 0);
  else {
    if (a.T && typeof a.T == "function")
      var c = a.T();
    else if (a.R && typeof a.R == "function")
      c = void 0;
    else if (ba(a) || typeof a === "string") {
      c = [];
      for (var d = a.length, e = 0; e < d; e++)
        c.push(e);
    } else
      for (e in c = [], d = 0, a)
        c[d++] = e;
    d = Jc(a);
    e = d.length;
    for (var f = 0; f < e; f++)
      b.call(void 0, d[f], c && c[f], a);
  }
}
function S(a, b) {
  this.h = {};
  this.g = [];
  this.i = 0;
  var c = arguments.length;
  if (1 < c) {
    if (c % 2)
      throw Error("Uneven number of arguments");
    for (var d = 0; d < c; d += 2)
      this.set(arguments[d], arguments[d + 1]);
  } else if (a)
    if (a instanceof S)
      for (c = a.T(), d = 0; d < c.length; d++)
        this.set(c[d], a.get(c[d]));
    else
      for (d in a)
        this.set(d, a[d]);
}
k = S.prototype;
k.R = function() {
  Lc(this);
  for (var a = [], b = 0; b < this.g.length; b++)
    a.push(this.h[this.g[b]]);
  return a;
};
k.T = function() {
  Lc(this);
  return this.g.concat();
};
function Lc(a) {
  if (a.i != a.g.length) {
    for (var b = 0, c = 0; b < a.g.length; ) {
      var d = a.g[b];
      T(a.h, d) && (a.g[c++] = d);
      b++;
    }
    a.g.length = c;
  }
  if (a.i != a.g.length) {
    var e = {};
    for (c = b = 0; b < a.g.length; )
      d = a.g[b], T(e, d) || (a.g[c++] = d, e[d] = 1), b++;
    a.g.length = c;
  }
}
k.get = function(a, b) {
  return T(this.h, a) ? this.h[a] : b;
};
k.set = function(a, b) {
  T(this.h, a) || (this.i++, this.g.push(a));
  this.h[a] = b;
};
k.forEach = function(a, b) {
  for (var c = this.T(), d = 0; d < c.length; d++) {
    var e = c[d], f = this.get(e);
    a.call(b, f, e, this);
  }
};
function T(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
var Mc = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^\\/?#]*)@)?([^\\/?#]*?)(?::([0-9]+))?(?=[\\/?#]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
function Nc(a, b) {
  if (a) {
    a = a.split("&");
    for (var c = 0; c < a.length; c++) {
      var d = a[c].indexOf("="), e = null;
      if (0 <= d) {
        var f = a[c].substring(0, d);
        e = a[c].substring(d + 1);
      } else
        f = a[c];
      b(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
    }
  }
}
function U(a, b) {
  this.i = this.s = this.j = "";
  this.m = null;
  this.o = this.l = "";
  this.g = false;
  if (a instanceof U) {
    this.g = b !== void 0 ? b : a.g;
    Oc(this, a.j);
    this.s = a.s;
    Pc(this, a.i);
    Qc(this, a.m);
    this.l = a.l;
    b = a.h;
    var c = new Rc();
    c.i = b.i;
    b.g && (c.g = new S(b.g), c.h = b.h);
    Sc(this, c);
    this.o = a.o;
  } else
    a && (c = String(a).match(Mc)) ? (this.g = !!b, Oc(this, c[1] || "", true), this.s = Tc(c[2] || ""), Pc(this, c[3] || "", true), Qc(this, c[4]), this.l = Tc(c[5] || "", true), Sc(this, c[6] || "", true), this.o = Tc(c[7] || "")) : (this.g = !!b, this.h = new Rc(null, this.g));
}
U.prototype.toString = function() {
  var a = [], b = this.j;
  b && a.push(Uc(b, Vc, true), ":");
  var c = this.i;
  if (c || b == "file")
    a.push("//"), (b = this.s) && a.push(Uc(b, Vc, true), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.m, c != null && a.push(":", String(c));
  if (c = this.l)
    this.i && c.charAt(0) != "/" && a.push("/"), a.push(Uc(c, c.charAt(0) == "/" ? Wc : Xc, true));
  (c = this.h.toString()) && a.push("?", c);
  (c = this.o) && a.push("#", Uc(c, Yc));
  return a.join("");
};
function N(a) {
  return new U(a);
}
function Oc(a, b, c) {
  a.j = c ? Tc(b, true) : b;
  a.j && (a.j = a.j.replace(/:$/, ""));
}
function Pc(a, b, c) {
  a.i = c ? Tc(b, true) : b;
}
function Qc(a, b) {
  if (b) {
    b = Number(b);
    if (isNaN(b) || 0 > b)
      throw Error("Bad port number " + b);
    a.m = b;
  } else
    a.m = null;
}
function Sc(a, b, c) {
  b instanceof Rc ? (a.h = b, Zc(a.h, a.g)) : (c || (b = Uc(b, $c)), a.h = new Rc(b, a.g));
}
function R(a, b, c) {
  a.h.set(b, c);
}
function jc(a) {
  R(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36));
  return a;
}
function ad(a) {
  return a instanceof U ? N(a) : new U(a, void 0);
}
function bd(a, b, c, d) {
  var e = new U(null, void 0);
  a && Oc(e, a);
  b && Pc(e, b);
  c && Qc(e, c);
  d && (e.l = d);
  return e;
}
function Tc(a, b) {
  return a ? b ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
}
function Uc(a, b, c) {
  return typeof a === "string" ? (a = encodeURI(a).replace(b, cd), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
}
function cd(a) {
  a = a.charCodeAt(0);
  return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
}
var Vc = /[#\/\?@]/g;
var Xc = /[#\?:]/g;
var Wc = /[#\?]/g;
var $c = /[#\?@]/g;
var Yc = /#/g;
function Rc(a, b) {
  this.h = this.g = null;
  this.i = a || null;
  this.j = !!b;
}
function V(a) {
  a.g || (a.g = new S(), a.h = 0, a.i && Nc(a.i, function(b, c) {
    a.add(decodeURIComponent(b.replace(/\+/g, " ")), c);
  }));
}
k = Rc.prototype;
k.add = function(a, b) {
  V(this);
  this.i = null;
  a = W(this, a);
  var c = this.g.get(a);
  c || this.g.set(a, c = []);
  c.push(b);
  this.h += 1;
  return this;
};
function dd(a, b) {
  V(a);
  b = W(a, b);
  T(a.g.h, b) && (a.i = null, a.h -= a.g.get(b).length, a = a.g, T(a.h, b) && (delete a.h[b], a.i--, a.g.length > 2 * a.i && Lc(a)));
}
function ed(a, b) {
  V(a);
  b = W(a, b);
  return T(a.g.h, b);
}
k.forEach = function(a, b) {
  V(this);
  this.g.forEach(function(c, d) {
    na(c, function(e) {
      a.call(b, e, d, this);
    }, this);
  }, this);
};
k.T = function() {
  V(this);
  for (var a = this.g.R(), b = this.g.T(), c = [], d = 0; d < b.length; d++)
    for (var e = a[d], f = 0; f < e.length; f++)
      c.push(b[d]);
  return c;
};
k.R = function(a) {
  V(this);
  var b = [];
  if (typeof a === "string")
    ed(this, a) && (b = qa(b, this.g.get(W(this, a))));
  else {
    a = this.g.R();
    for (var c = 0; c < a.length; c++)
      b = qa(b, a[c]);
  }
  return b;
};
k.set = function(a, b) {
  V(this);
  this.i = null;
  a = W(this, a);
  ed(this, a) && (this.h -= this.g.get(a).length);
  this.g.set(a, [b]);
  this.h += 1;
  return this;
};
k.get = function(a, b) {
  if (!a)
    return b;
  a = this.R(a);
  return 0 < a.length ? String(a[0]) : b;
};
function mc(a, b, c) {
  dd(a, b);
  0 < c.length && (a.i = null, a.g.set(W(a, b), ra(c)), a.h += c.length);
}
k.toString = function() {
  if (this.i)
    return this.i;
  if (!this.g)
    return "";
  for (var a = [], b = this.g.T(), c = 0; c < b.length; c++) {
    var d = b[c], e = encodeURIComponent(String(d));
    d = this.R(d);
    for (var f = 0; f < d.length; f++) {
      var h = e;
      d[f] !== "" && (h += "=" + encodeURIComponent(String(d[f])));
      a.push(h);
    }
  }
  return this.i = a.join("&");
};
function W(a, b) {
  b = String(b);
  a.j && (b = b.toLowerCase());
  return b;
}
function Zc(a, b) {
  b && !a.j && (V(a), a.i = null, a.g.forEach(function(c, d) {
    var e = d.toLowerCase();
    d != e && (dd(this, d), mc(this, e, c));
  }, a));
  a.j = b;
}
var fd = class {
  constructor(a, b) {
    this.h = a;
    this.g = b;
  }
};
function gd(a) {
  this.l = a || hd;
  l.PerformanceNavigationTiming ? (a = l.performance.getEntriesByType("navigation"), a = 0 < a.length && (a[0].nextHopProtocol == "hq" || a[0].nextHopProtocol == "h2")) : a = !!(l.g && l.g.Ea && l.g.Ea() && l.g.Ea().Zb);
  this.j = a ? this.l : 1;
  this.g = null;
  1 < this.j && (this.g = /* @__PURE__ */ new Set());
  this.h = null;
  this.i = [];
}
var hd = 10;
function id(a) {
  return a.h ? true : a.g ? a.g.size >= a.j : false;
}
function Cc(a) {
  return a.h ? 1 : a.g ? a.g.size : 0;
}
function yc(a, b) {
  return a.h ? a.h == b : a.g ? a.g.has(b) : false;
}
function Dc(a, b) {
  a.g ? a.g.add(b) : a.h = b;
}
function Fc(a, b) {
  a.h && a.h == b ? a.h = null : a.g && a.g.has(b) && a.g.delete(b);
}
gd.prototype.cancel = function() {
  this.i = jd(this);
  if (this.h)
    this.h.cancel(), this.h = null;
  else if (this.g && this.g.size !== 0) {
    for (const a of this.g.values())
      a.cancel();
    this.g.clear();
  }
};
function jd(a) {
  if (a.h != null)
    return a.i.concat(a.h.D);
  if (a.g != null && a.g.size !== 0) {
    let b = a.i;
    for (const c of a.g.values())
      b = b.concat(c.D);
    return b;
  }
  return ra(a.i);
}
function kd() {
}
kd.prototype.stringify = function(a) {
  return l.JSON.stringify(a, void 0);
};
kd.prototype.parse = function(a) {
  return l.JSON.parse(a, void 0);
};
function ld() {
  this.g = new kd();
}
function md(a, b, c) {
  const d = c || "";
  try {
    Kc(a, function(e, f) {
      let h = e;
      p(e) && (h = rb(e));
      b.push(d + f + "=" + encodeURIComponent(h));
    });
  } catch (e) {
    throw b.push(d + "type=" + encodeURIComponent("_badmap")), e;
  }
}
function nd(a, b) {
  const c = new Mb();
  if (l.Image) {
    const d = new Image();
    d.onload = ja(od, c, d, "TestLoadImage: loaded", true, b);
    d.onerror = ja(od, c, d, "TestLoadImage: error", false, b);
    d.onabort = ja(od, c, d, "TestLoadImage: abort", false, b);
    d.ontimeout = ja(od, c, d, "TestLoadImage: timeout", false, b);
    l.setTimeout(function() {
      if (d.ontimeout)
        d.ontimeout();
    }, 1e4);
    d.src = a;
  } else
    b(false);
}
function od(a, b, c, d, e) {
  try {
    b.onload = null, b.onerror = null, b.onabort = null, b.ontimeout = null, e(d);
  } catch (f) {
  }
}
function pd(a) {
  this.l = a.$b || null;
  this.j = a.ib || false;
}
t(pd, Yb);
pd.prototype.g = function() {
  return new qd(this.l, this.j);
};
pd.prototype.i = function(a) {
  return function() {
    return a;
  };
}({});
function qd(a, b) {
  C.call(this);
  this.D = a;
  this.u = b;
  this.m = void 0;
  this.readyState = rd;
  this.status = 0;
  this.responseType = this.responseText = this.response = this.statusText = "";
  this.onreadystatechange = null;
  this.v = new Headers();
  this.h = null;
  this.C = "GET";
  this.B = "";
  this.g = false;
  this.A = this.j = this.l = null;
}
t(qd, C);
var rd = 0;
k = qd.prototype;
k.open = function(a, b) {
  if (this.readyState != rd)
    throw this.abort(), Error("Error reopening a connection");
  this.C = a;
  this.B = b;
  this.readyState = 1;
  sd(this);
};
k.send = function(a) {
  if (this.readyState != 1)
    throw this.abort(), Error("need to call open() first. ");
  this.g = true;
  const b = { headers: this.v, method: this.C, credentials: this.m, cache: void 0 };
  a && (b.body = a);
  (this.D || l).fetch(new Request(this.B, b)).then(this.Va.bind(this), this.ha.bind(this));
};
k.abort = function() {
  this.response = this.responseText = "";
  this.v = new Headers();
  this.status = 0;
  this.j && this.j.cancel("Request was aborted.");
  1 <= this.readyState && this.g && this.readyState != 4 && (this.g = false, td(this));
  this.readyState = rd;
};
k.Va = function(a) {
  if (this.g && (this.l = a, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = a.headers, this.readyState = 2, sd(this)), this.g && (this.readyState = 3, sd(this), this.g)))
    if (this.responseType === "arraybuffer")
      a.arrayBuffer().then(this.Ta.bind(this), this.ha.bind(this));
    else if (typeof l.ReadableStream !== "undefined" && "body" in a) {
      this.j = a.body.getReader();
      if (this.u) {
        if (this.responseType)
          throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
        this.response = [];
      } else
        this.response = this.responseText = "", this.A = new TextDecoder();
      ud(this);
    } else
      a.text().then(this.Ua.bind(this), this.ha.bind(this));
};
function ud(a) {
  a.j.read().then(a.Sa.bind(a)).catch(a.ha.bind(a));
}
k.Sa = function(a) {
  if (this.g) {
    if (this.u && a.value)
      this.response.push(a.value);
    else if (!this.u) {
      var b = a.value ? a.value : new Uint8Array(0);
      if (b = this.A.decode(b, { stream: !a.done }))
        this.response = this.responseText += b;
    }
    a.done ? td(this) : sd(this);
    this.readyState == 3 && ud(this);
  }
};
k.Ua = function(a) {
  this.g && (this.response = this.responseText = a, td(this));
};
k.Ta = function(a) {
  this.g && (this.response = a, td(this));
};
k.ha = function() {
  this.g && td(this);
};
function td(a) {
  a.readyState = 4;
  a.l = null;
  a.j = null;
  a.A = null;
  sd(a);
}
k.setRequestHeader = function(a, b) {
  this.v.append(a, b);
};
k.getResponseHeader = function(a) {
  return this.h ? this.h.get(a.toLowerCase()) || "" : "";
};
k.getAllResponseHeaders = function() {
  if (!this.h)
    return "";
  const a = [], b = this.h.entries();
  for (var c = b.next(); !c.done; )
    c = c.value, a.push(c[0] + ": " + c[1]), c = b.next();
  return a.join("\r\n");
};
function sd(a) {
  a.onreadystatechange && a.onreadystatechange.call(a);
}
Object.defineProperty(qd.prototype, "withCredentials", { get: function() {
  return this.m === "include";
}, set: function(a) {
  this.m = a ? "include" : "same-origin";
} });
var vd = l.JSON.parse;
function X(a) {
  C.call(this);
  this.headers = new S();
  this.u = a || null;
  this.h = false;
  this.C = this.g = null;
  this.H = "";
  this.m = 0;
  this.j = "";
  this.l = this.F = this.v = this.D = false;
  this.B = 0;
  this.A = null;
  this.J = wd;
  this.K = this.L = false;
}
t(X, C);
var wd = "";
var xd = /^https?$/i;
var yd = ["POST", "PUT"];
k = X.prototype;
k.ea = function(a, b, c, d) {
  if (this.g)
    throw Error("[goog.net.XhrIo] Object is active with another request=" + this.H + "; newUri=" + a);
  b = b ? b.toUpperCase() : "GET";
  this.H = a;
  this.j = "";
  this.m = 0;
  this.D = false;
  this.h = true;
  this.g = this.u ? this.u.g() : cc.g();
  this.C = this.u ? Zb(this.u) : Zb(cc);
  this.g.onreadystatechange = q(this.Fa, this);
  try {
    this.F = true, this.g.open(b, String(a), true), this.F = false;
  } catch (f) {
    zd(this, f);
    return;
  }
  a = c || "";
  const e = new S(this.headers);
  d && Kc(d, function(f, h) {
    e.set(h, f);
  });
  d = oa(e.T());
  c = l.FormData && a instanceof l.FormData;
  !(0 <= ma(yd, b)) || d || c || e.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
  e.forEach(function(f, h) {
    this.g.setRequestHeader(h, f);
  }, this);
  this.J && (this.g.responseType = this.J);
  "withCredentials" in this.g && this.g.withCredentials !== this.L && (this.g.withCredentials = this.L);
  try {
    Ad(this), 0 < this.B && ((this.K = Bd(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = q(this.pa, this)) : this.A = Gb(this.pa, this.B, this)), this.v = true, this.g.send(a), this.v = false;
  } catch (f) {
    zd(this, f);
  }
};
function Bd(a) {
  return y && Ra() && typeof a.timeout === "number" && a.ontimeout !== void 0;
}
function pa(a) {
  return a.toLowerCase() == "content-type";
}
k.pa = function() {
  typeof goog != "undefined" && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, D(this, "timeout"), this.abort(8));
};
function zd(a, b) {
  a.h = false;
  a.g && (a.l = true, a.g.abort(), a.l = false);
  a.j = b;
  a.m = 5;
  Cd(a);
  Dd(a);
}
function Cd(a) {
  a.D || (a.D = true, D(a, "complete"), D(a, "error"));
}
k.abort = function(a) {
  this.g && this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false, this.m = a || 7, D(this, "complete"), D(this, "abort"), Dd(this));
};
k.M = function() {
  this.g && (this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false), Dd(this, true));
  X.Z.M.call(this);
};
k.Fa = function() {
  this.s || (this.F || this.v || this.l ? Ed(this) : this.cb());
};
k.cb = function() {
  Ed(this);
};
function Ed(a) {
  if (a.h && typeof goog != "undefined" && (!a.C[1] || O(a) != 4 || a.ba() != 2)) {
    if (a.v && O(a) == 4)
      Gb(a.Fa, 0, a);
    else if (D(a, "readystatechange"), O(a) == 4) {
      a.h = false;
      try {
        const n = a.ba();
        a:
          switch (n) {
            case 200:
            case 201:
            case 202:
            case 204:
            case 206:
            case 304:
            case 1223:
              var b = true;
              break a;
            default:
              b = false;
          }
        var c;
        if (!(c = b)) {
          var d;
          if (d = n === 0) {
            var e = String(a.H).match(Mc)[1] || null;
            if (!e && l.self && l.self.location) {
              var f = l.self.location.protocol;
              e = f.substr(0, f.length - 1);
            }
            d = !xd.test(e ? e.toLowerCase() : "");
          }
          c = d;
        }
        if (c)
          D(a, "complete"), D(a, "success");
        else {
          a.m = 6;
          try {
            var h = 2 < O(a) ? a.g.statusText : "";
          } catch (u) {
            h = "";
          }
          a.j = h + " [" + a.ba() + "]";
          Cd(a);
        }
      } finally {
        Dd(a);
      }
    }
  }
}
function Dd(a, b) {
  if (a.g) {
    Ad(a);
    const c = a.g, d = a.C[0] ? aa : null;
    a.g = null;
    a.C = null;
    b || D(a, "ready");
    try {
      c.onreadystatechange = d;
    } catch (e) {
    }
  }
}
function Ad(a) {
  a.g && a.K && (a.g.ontimeout = null);
  a.A && (l.clearTimeout(a.A), a.A = null);
}
function O(a) {
  return a.g ? a.g.readyState : 0;
}
k.ba = function() {
  try {
    return 2 < O(this) ? this.g.status : -1;
  } catch (a) {
    return -1;
  }
};
k.ga = function() {
  try {
    return this.g ? this.g.responseText : "";
  } catch (a) {
    return "";
  }
};
k.Qa = function(a) {
  if (this.g) {
    var b = this.g.responseText;
    a && b.indexOf(a) == 0 && (b = b.substring(a.length));
    return vd(b);
  }
};
function oc(a) {
  try {
    if (!a.g)
      return null;
    if ("response" in a.g)
      return a.g.response;
    switch (a.J) {
      case wd:
      case "text":
        return a.g.responseText;
      case "arraybuffer":
        if ("mozResponseArrayBuffer" in a.g)
          return a.g.mozResponseArrayBuffer;
    }
    return null;
  } catch (b) {
    return null;
  }
}
k.Da = function() {
  return this.m;
};
k.La = function() {
  return typeof this.j === "string" ? this.j : String(this.j);
};
function Fd(a) {
  let b = "";
  xa(a, function(c, d) {
    b += d;
    b += ":";
    b += c;
    b += "\r\n";
  });
  return b;
}
function Gd(a, b, c) {
  a: {
    for (d in c) {
      var d = false;
      break a;
    }
    d = true;
  }
  d || (c = Fd(c), typeof a === "string" ? c != null && encodeURIComponent(String(c)) : R(a, b, c));
}
function Hd(a, b, c) {
  return c && c.internalChannelParams ? c.internalChannelParams[a] || b : b;
}
function Id(a) {
  this.za = 0;
  this.l = [];
  this.h = new Mb();
  this.la = this.oa = this.F = this.W = this.g = this.sa = this.D = this.aa = this.o = this.P = this.s = null;
  this.Za = this.V = 0;
  this.Xa = Hd("failFast", false, a);
  this.N = this.v = this.u = this.m = this.j = null;
  this.X = true;
  this.I = this.ta = this.U = -1;
  this.Y = this.A = this.C = 0;
  this.Pa = Hd("baseRetryDelayMs", 5e3, a);
  this.$a = Hd("retryDelaySeedMs", 1e4, a);
  this.Ya = Hd("forwardChannelMaxRetries", 2, a);
  this.ra = Hd("forwardChannelRequestTimeoutMs", 2e4, a);
  this.qa = a && a.xmlHttpFactory || void 0;
  this.Ba = a && a.Yb || false;
  this.K = void 0;
  this.H = a && a.supportsCrossDomainXhr || false;
  this.J = "";
  this.i = new gd(a && a.concurrentRequestLimit);
  this.Ca = new ld();
  this.ja = a && a.fastHandshake || false;
  this.Ra = a && a.Wb || false;
  a && a.Aa && this.h.Aa();
  a && a.forceLongPolling && (this.X = false);
  this.$ = !this.ja && this.X && a && a.detectBufferingProxy || false;
  this.ka = void 0;
  this.O = 0;
  this.L = false;
  this.B = null;
  this.Wa = !a || a.Xb !== false;
}
k = Id.prototype;
k.ma = 8;
k.G = 1;
function Ic(a) {
  Jd(a);
  if (a.G == 3) {
    var b = a.V++, c = N(a.F);
    R(c, "SID", a.J);
    R(c, "RID", b);
    R(c, "TYPE", "terminate");
    Kd(a, c);
    b = new M(a, a.h, b, void 0);
    b.K = 2;
    b.v = jc(N(c));
    c = false;
    l.navigator && l.navigator.sendBeacon && (c = l.navigator.sendBeacon(b.v.toString(), ""));
    !c && l.Image && (new Image().src = b.v, c = true);
    c || (b.g = nc(b.l, null), b.g.ea(b.v));
    b.F = Date.now();
    lc(b);
  }
  Ld(a);
}
k.hb = function(a) {
  try {
    this.h.info("Origin Trials invoked: " + a);
  } catch (b) {
  }
};
function Ac(a) {
  a.g && (wc(a), a.g.cancel(), a.g = null);
}
function Jd(a) {
  Ac(a);
  a.u && (l.clearTimeout(a.u), a.u = null);
  zc(a);
  a.i.cancel();
  a.m && (typeof a.m === "number" && l.clearTimeout(a.m), a.m = null);
}
function Md(a, b) {
  a.l.push(new fd(a.Za++, b));
  a.G == 3 && Hc(a);
}
function Hc(a) {
  id(a.i) || a.m || (a.m = true, zb(a.Ha, a), a.C = 0);
}
function Nd(a, b) {
  if (Cc(a.i) >= a.i.j - (a.m ? 1 : 0))
    return false;
  if (a.m)
    return a.l = b.D.concat(a.l), true;
  if (a.G == 1 || a.G == 2 || a.C >= (a.Xa ? 0 : a.Ya))
    return false;
  a.m = K(q(a.Ha, a, b), Od(a, a.C));
  a.C++;
  return true;
}
k.Ha = function(a) {
  if (this.m)
    if (this.m = null, this.G == 1) {
      if (!a) {
        this.V = Math.floor(1e5 * Math.random());
        a = this.V++;
        const e = new M(this, this.h, a, void 0);
        let f = this.s;
        this.P && (f ? (f = ya(f), Aa(f, this.P)) : f = this.P);
        this.o === null && (e.H = f);
        if (this.ja)
          a: {
            var b = 0;
            for (var c = 0; c < this.l.length; c++) {
              b: {
                var d = this.l[c];
                if ("__data__" in d.g && (d = d.g.__data__, typeof d === "string")) {
                  d = d.length;
                  break b;
                }
                d = void 0;
              }
              if (d === void 0)
                break;
              b += d;
              if (4096 < b) {
                b = c;
                break a;
              }
              if (b === 4096 || c === this.l.length - 1) {
                b = c + 1;
                break a;
              }
            }
            b = 1e3;
          }
        else
          b = 1e3;
        b = Pd(this, e, b);
        c = N(this.F);
        R(c, "RID", a);
        R(c, "CVER", 22);
        this.D && R(c, "X-HTTP-Session-Id", this.D);
        Kd(this, c);
        this.o && f && Gd(c, this.o, f);
        Dc(this.i, e);
        this.Ra && R(c, "TYPE", "init");
        this.ja ? (R(c, "$req", b), R(c, "SID", "null"), e.$ = true, ic(e, c, null)) : ic(e, c, b);
        this.G = 2;
      }
    } else
      this.G == 3 && (a ? Qd(this, a) : this.l.length == 0 || id(this.i) || Qd(this));
};
function Qd(a, b) {
  var c;
  b ? c = b.m : c = a.V++;
  const d = N(a.F);
  R(d, "SID", a.J);
  R(d, "RID", c);
  R(d, "AID", a.U);
  Kd(a, d);
  a.o && a.s && Gd(d, a.o, a.s);
  c = new M(a, a.h, c, a.C + 1);
  a.o === null && (c.H = a.s);
  b && (a.l = b.D.concat(a.l));
  b = Pd(a, c, 1e3);
  c.setTimeout(Math.round(0.5 * a.ra) + Math.round(0.5 * a.ra * Math.random()));
  Dc(a.i, c);
  ic(c, d, b);
}
function Kd(a, b) {
  a.j && Kc({}, function(c, d) {
    R(b, d, c);
  });
}
function Pd(a, b, c) {
  c = Math.min(a.l.length, c);
  var d = a.j ? q(a.j.Oa, a.j, a) : null;
  a: {
    var e = a.l;
    let f = -1;
    for (; ; ) {
      const h = ["count=" + c];
      f == -1 ? 0 < c ? (f = e[0].h, h.push("ofs=" + f)) : f = 0 : h.push("ofs=" + f);
      let n = true;
      for (let u = 0; u < c; u++) {
        let m = e[u].h;
        const r = e[u].g;
        m -= f;
        if (0 > m)
          f = Math.max(0, e[u].h - 100), n = false;
        else
          try {
            md(r, h, "req" + m + "_");
          } catch (G2) {
            d && d(r);
          }
      }
      if (n) {
        d = h.join("&");
        break a;
      }
    }
  }
  a = a.l.splice(0, c);
  b.D = a;
  return d;
}
function Gc(a) {
  a.g || a.u || (a.Y = 1, zb(a.Ga, a), a.A = 0);
}
function Bc(a) {
  if (a.g || a.u || 3 <= a.A)
    return false;
  a.Y++;
  a.u = K(q(a.Ga, a), Od(a, a.A));
  a.A++;
  return true;
}
k.Ga = function() {
  this.u = null;
  Rd(this);
  if (this.$ && !(this.L || this.g == null || 0 >= this.O)) {
    var a = 2 * this.O;
    this.h.info("BP detection timer enabled: " + a);
    this.B = K(q(this.bb, this), a);
  }
};
k.bb = function() {
  this.B && (this.B = null, this.h.info("BP detection timeout reached."), this.h.info("Buffering proxy detected and switch to long-polling!"), this.N = false, this.L = true, J(10), Ac(this), Rd(this));
};
function wc(a) {
  a.B != null && (l.clearTimeout(a.B), a.B = null);
}
function Rd(a) {
  a.g = new M(a, a.h, "rpc", a.Y);
  a.o === null && (a.g.H = a.s);
  a.g.O = 0;
  var b = N(a.oa);
  R(b, "RID", "rpc");
  R(b, "SID", a.J);
  R(b, "CI", a.N ? "0" : "1");
  R(b, "AID", a.U);
  Kd(a, b);
  R(b, "TYPE", "xmlhttp");
  a.o && a.s && Gd(b, a.o, a.s);
  a.K && a.g.setTimeout(a.K);
  var c = a.g;
  a = a.la;
  c.K = 1;
  c.v = jc(N(b));
  c.s = null;
  c.U = true;
  kc(c, a);
}
k.ab = function() {
  this.v != null && (this.v = null, Ac(this), Bc(this), J(19));
};
function zc(a) {
  a.v != null && (l.clearTimeout(a.v), a.v = null);
}
function uc(a, b) {
  var c = null;
  if (a.g == b) {
    zc(a);
    wc(a);
    a.g = null;
    var d = 2;
  } else if (yc(a.i, b))
    c = b.D, Fc(a.i, b), d = 1;
  else
    return;
  a.I = b.N;
  if (a.G != 0) {
    if (b.i)
      if (d == 1) {
        c = b.s ? b.s.length : 0;
        b = Date.now() - b.F;
        var e = a.C;
        d = Sb();
        D(d, new Vb(d, c, b, e));
        Hc(a);
      } else
        Gc(a);
    else if (e = b.o, e == 3 || e == 0 && 0 < a.I || !(d == 1 && Nd(a, b) || d == 2 && Bc(a)))
      switch (c && 0 < c.length && (b = a.i, b.i = b.i.concat(c)), e) {
        case 1:
          Q(a, 5);
          break;
        case 4:
          Q(a, 10);
          break;
        case 3:
          Q(a, 6);
          break;
        default:
          Q(a, 2);
      }
  }
}
function Od(a, b) {
  let c = a.Pa + Math.floor(Math.random() * a.$a);
  a.j || (c *= 2);
  return c * b;
}
function Q(a, b) {
  a.h.info("Error code " + b);
  if (b == 2) {
    var c = null;
    a.j && (c = null);
    var d = q(a.jb, a);
    c || (c = new U("//www.google.com/images/cleardot.gif"), l.location && l.location.protocol == "http" || Oc(c, "https"), jc(c));
    nd(c.toString(), d);
  } else
    J(2);
  a.G = 0;
  a.j && a.j.va(b);
  Ld(a);
  Jd(a);
}
k.jb = function(a) {
  a ? (this.h.info("Successfully pinged google.com"), J(2)) : (this.h.info("Failed to ping google.com"), J(1));
};
function Ld(a) {
  a.G = 0;
  a.I = -1;
  if (a.j) {
    if (jd(a.i).length != 0 || a.l.length != 0)
      a.i.i.length = 0, ra(a.l), a.l.length = 0;
    a.j.ua();
  }
}
function Ec(a, b, c) {
  let d = ad(c);
  if (d.i != "")
    b && Pc(d, b + "." + d.i), Qc(d, d.m);
  else {
    const e = l.location;
    d = bd(e.protocol, b ? b + "." + e.hostname : e.hostname, +e.port, c);
  }
  a.aa && xa(a.aa, function(e, f) {
    R(d, f, e);
  });
  b = a.D;
  c = a.sa;
  b && c && R(d, b, c);
  R(d, "VER", a.ma);
  Kd(a, d);
  return d;
}
function nc(a, b, c) {
  if (b && !a.H)
    throw Error("Can't create secondary domain capable XhrIo object.");
  b = c && a.Ba && !a.qa ? new X(new pd({ ib: true })) : new X(a.qa);
  b.L = a.H;
  return b;
}
function Sd() {
}
k = Sd.prototype;
k.xa = function() {
};
k.wa = function() {
};
k.va = function() {
};
k.ua = function() {
};
k.Oa = function() {
};
function Td() {
  if (y && !(10 <= Number(Ua)))
    throw Error("Environmental error: no available transport.");
}
Td.prototype.g = function(a, b) {
  return new Y(a, b);
};
function Y(a, b) {
  C.call(this);
  this.g = new Id(b);
  this.l = a;
  this.h = b && b.messageUrlParams || null;
  a = b && b.messageHeaders || null;
  b && b.clientProtocolHeaderRequired && (a ? a["X-Client-Protocol"] = "webchannel" : a = { "X-Client-Protocol": "webchannel" });
  this.g.s = a;
  a = b && b.initMessageHeaders || null;
  b && b.messageContentType && (a ? a["X-WebChannel-Content-Type"] = b.messageContentType : a = { "X-WebChannel-Content-Type": b.messageContentType });
  b && b.ya && (a ? a["X-WebChannel-Client-Profile"] = b.ya : a = { "X-WebChannel-Client-Profile": b.ya });
  this.g.P = a;
  (a = b && b.httpHeadersOverwriteParam) && !sa(a) && (this.g.o = a);
  this.A = b && b.supportsCrossDomainXhr || false;
  this.v = b && b.sendRawJson || false;
  (b = b && b.httpSessionIdParam) && !sa(b) && (this.g.D = b, a = this.h, a !== null && b in a && (a = this.h, b in a && delete a[b]));
  this.j = new Z(this);
}
t(Y, C);
Y.prototype.m = function() {
  this.g.j = this.j;
  this.A && (this.g.H = true);
  var a = this.g, b = this.l, c = this.h || void 0;
  a.Wa && (a.h.info("Origin Trials enabled."), zb(q(a.hb, a, b)));
  J(0);
  a.W = b;
  a.aa = c || {};
  a.N = a.X;
  a.F = Ec(a, null, a.W);
  Hc(a);
};
Y.prototype.close = function() {
  Ic(this.g);
};
Y.prototype.u = function(a) {
  if (typeof a === "string") {
    var b = {};
    b.__data__ = a;
    Md(this.g, b);
  } else
    this.v ? (b = {}, b.__data__ = rb(a), Md(this.g, b)) : Md(this.g, a);
};
Y.prototype.M = function() {
  this.g.j = null;
  delete this.j;
  Ic(this.g);
  delete this.g;
  Y.Z.M.call(this);
};
function Ud(a) {
  ac.call(this);
  var b = a.__sm__;
  if (b) {
    a: {
      for (const c in b) {
        a = c;
        break a;
      }
      a = void 0;
    }
    if (this.i = a)
      a = this.i, b = b !== null && a in b ? b[a] : void 0;
    this.data = b;
  } else
    this.data = a;
}
t(Ud, ac);
function Vd() {
  bc.call(this);
  this.status = 1;
}
t(Vd, bc);
function Z(a) {
  this.g = a;
}
t(Z, Sd);
Z.prototype.xa = function() {
  D(this.g, "a");
};
Z.prototype.wa = function(a) {
  D(this.g, new Ud(a));
};
Z.prototype.va = function(a) {
  D(this.g, new Vd(a));
};
Z.prototype.ua = function() {
  D(this.g, "b");
};
Td.prototype.createWebChannel = Td.prototype.g;
Y.prototype.send = Y.prototype.u;
Y.prototype.open = Y.prototype.m;
Y.prototype.close = Y.prototype.close;
Wb.NO_ERROR = 0;
Wb.TIMEOUT = 8;
Wb.HTTP_ERROR = 6;
Xb.COMPLETE = "complete";
$b.EventType = L;
L.OPEN = "a";
L.CLOSE = "b";
L.ERROR = "c";
L.MESSAGE = "d";
C.prototype.listen = C.prototype.N;
X.prototype.listenOnce = X.prototype.O;
X.prototype.getLastError = X.prototype.La;
X.prototype.getLastErrorCode = X.prototype.Da;
X.prototype.getStatus = X.prototype.ba;
X.prototype.getResponseJson = X.prototype.Qa;
X.prototype.getResponseText = X.prototype.ga;
X.prototype.send = X.prototype.ea;
var createWebChannelTransport = esm.createWebChannelTransport = function() {
  return new Td();
};
var getStatEventTarget = esm.getStatEventTarget = function() {
  return Sb();
};
var ErrorCode = esm.ErrorCode = Wb;
var EventType = esm.EventType = Xb;
var Event = esm.Event = H;
var Stat = esm.Stat = { rb: 0, ub: 1, vb: 2, Ob: 3, Tb: 4, Qb: 5, Rb: 6, Pb: 7, Nb: 8, Sb: 9, PROXY: 10, NOPROXY: 11, Lb: 12, Hb: 13, Ib: 14, Gb: 15, Jb: 16, Kb: 17, nb: 18, mb: 19, ob: 20 };
var FetchXmlHttpFactory = esm.FetchXmlHttpFactory = pd;
var WebChannel = esm.WebChannel = $b;
var XhrIo = esm.XhrIo = X;

// node_modules/@firebase/firestore/dist/index.esm2017.js
var D2 = "@firebase/firestore";
var C2 = class {
  constructor(t2) {
    this.uid = t2;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(t2) {
    return t2.uid === this.uid;
  }
};
C2.UNAUTHENTICATED = new C2(null), C2.GOOGLE_CREDENTIALS = new C2("google-credentials-uid"), C2.FIRST_PARTY = new C2("first-party-uid"), C2.MOCK_USER = new C2("mock-user");
var x2 = "9.8.3";
var N2 = new Logger("@firebase/firestore");
function k2() {
  return N2.logLevel;
}
function O2(t2) {
  N2.setLogLevel(t2);
}
function M2(t2, ...e) {
  if (N2.logLevel <= LogLevel.DEBUG) {
    const n = e.map(B2);
    N2.debug(`Firestore (${x2}): ${t2}`, ...n);
  }
}
function F2(t2, ...e) {
  if (N2.logLevel <= LogLevel.ERROR) {
    const n = e.map(B2);
    N2.error(`Firestore (${x2}): ${t2}`, ...n);
  }
}
function $(t2, ...e) {
  if (N2.logLevel <= LogLevel.WARN) {
    const n = e.map(B2);
    N2.warn(`Firestore (${x2}): ${t2}`, ...n);
  }
}
function B2(t2) {
  if (typeof t2 == "string")
    return t2;
  try {
    return e = t2, JSON.stringify(e);
  } catch (e2) {
    return t2;
  }
  var e;
}
function L2(t2 = "Unexpected state") {
  const e = `FIRESTORE (${x2}) INTERNAL ASSERTION FAILED: ` + t2;
  throw F2(e), new Error(e);
}
function U2(t2, e) {
  t2 || L2();
}
function q2(t2, e) {
  t2 || L2();
}
function K2(t2, e) {
  return t2;
}
var G = {
  OK: "ok",
  CANCELLED: "cancelled",
  UNKNOWN: "unknown",
  INVALID_ARGUMENT: "invalid-argument",
  DEADLINE_EXCEEDED: "deadline-exceeded",
  NOT_FOUND: "not-found",
  ALREADY_EXISTS: "already-exists",
  PERMISSION_DENIED: "permission-denied",
  UNAUTHENTICATED: "unauthenticated",
  RESOURCE_EXHAUSTED: "resource-exhausted",
  FAILED_PRECONDITION: "failed-precondition",
  ABORTED: "aborted",
  OUT_OF_RANGE: "out-of-range",
  UNIMPLEMENTED: "unimplemented",
  INTERNAL: "internal",
  UNAVAILABLE: "unavailable",
  DATA_LOSS: "data-loss"
};
var Q2 = class extends FirebaseError {
  constructor(t2, e) {
    super(t2, e), this.code = t2, this.message = e, this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
};
var j = class {
  constructor() {
    this.promise = new Promise((t2, e) => {
      this.resolve = t2, this.reject = e;
    });
  }
};
var W2 = class {
  constructor(t2, e) {
    this.user = e, this.type = "OAuth", this.headers = /* @__PURE__ */ new Map(), this.headers.set("Authorization", `Bearer ${t2}`);
  }
};
var z2 = class {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(C2.UNAUTHENTICATED));
  }
  shutdown() {
  }
};
var H2 = class {
  constructor(t2) {
    this.token = t2, this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(t2, e) {
    this.changeListener = e, t2.enqueueRetryable(() => e(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
};
var J2 = class {
  constructor(t2) {
    this.t = t2, this.currentUser = C2.UNAUTHENTICATED, this.i = 0, this.forceRefresh = false, this.auth = null;
  }
  start(t2, e) {
    let n = this.i;
    const s = (t3) => this.i !== n ? (n = this.i, e(t3)) : Promise.resolve();
    let i = new j();
    this.o = () => {
      this.i++, this.currentUser = this.u(), i.resolve(), i = new j(), t2.enqueueRetryable(() => s(this.currentUser));
    };
    const r = () => {
      const e2 = i;
      t2.enqueueRetryable(async () => {
        await e2.promise, await s(this.currentUser);
      });
    }, o = (t3) => {
      M2("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = t3, this.auth.addAuthTokenListener(this.o), r();
    };
    this.t.onInit((t3) => o(t3)), setTimeout(() => {
      if (!this.auth) {
        const t3 = this.t.getImmediate({
          optional: true
        });
        t3 ? o(t3) : (M2("FirebaseAuthCredentialsProvider", "Auth not yet detected"), i.resolve(), i = new j());
      }
    }, 0), r();
  }
  getToken() {
    const t2 = this.i, e = this.forceRefresh;
    return this.forceRefresh = false, this.auth ? this.auth.getToken(e).then((e2) => this.i !== t2 ? (M2("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : e2 ? (U2(typeof e2.accessToken == "string"), new W2(e2.accessToken, this.currentUser)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.auth && this.auth.removeAuthTokenListener(this.o);
  }
  u() {
    const t2 = this.auth && this.auth.getUid();
    return U2(t2 === null || typeof t2 == "string"), new C2(t2);
  }
};
var Y2 = class {
  constructor(t2, e, n) {
    this.type = "FirstParty", this.user = C2.FIRST_PARTY, this.headers = /* @__PURE__ */ new Map(), this.headers.set("X-Goog-AuthUser", e);
    const s = t2.auth.getAuthHeaderValueForFirstParty([]);
    s && this.headers.set("Authorization", s), n && this.headers.set("X-Goog-Iam-Authorization-Token", n);
  }
};
var X2 = class {
  constructor(t2, e, n) {
    this.h = t2, this.l = e, this.m = n;
  }
  getToken() {
    return Promise.resolve(new Y2(this.h, this.l, this.m));
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(C2.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
};
var Z2 = class {
  constructor(t2) {
    this.value = t2, this.type = "AppCheck", this.headers = /* @__PURE__ */ new Map(), t2 && t2.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
  }
};
var tt = class {
  constructor(t2) {
    this.g = t2, this.forceRefresh = false, this.appCheck = null, this.p = null;
  }
  start(t2, e) {
    const n = (t3) => {
      t3.error != null && M2("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${t3.error.message}`);
      const n2 = t3.token !== this.p;
      return this.p = t3.token, M2("FirebaseAppCheckTokenProvider", `Received ${n2 ? "new" : "existing"} token.`), n2 ? e(t3.token) : Promise.resolve();
    };
    this.o = (e2) => {
      t2.enqueueRetryable(() => n(e2));
    };
    const s = (t3) => {
      M2("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = t3, this.appCheck.addTokenListener(this.o);
    };
    this.g.onInit((t3) => s(t3)), setTimeout(() => {
      if (!this.appCheck) {
        const t3 = this.g.getImmediate({
          optional: true
        });
        t3 ? s(t3) : M2("FirebaseAppCheckTokenProvider", "AppCheck not yet detected");
      }
    }, 0);
  }
  getToken() {
    const t2 = this.forceRefresh;
    return this.forceRefresh = false, this.appCheck ? this.appCheck.getToken(t2).then((t3) => t3 ? (U2(typeof t3.token == "string"), this.p = t3.token, new Z2(t3.token)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.appCheck && this.appCheck.removeTokenListener(this.o);
  }
};
function nt(t2) {
  const e = typeof self != "undefined" && (self.crypto || self.msCrypto), n = new Uint8Array(t2);
  if (e && typeof e.getRandomValues == "function")
    e.getRandomValues(n);
  else
    for (let e2 = 0; e2 < t2; e2++)
      n[e2] = Math.floor(256 * Math.random());
  return n;
}
var st = class {
  static I() {
    const t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = Math.floor(256 / t2.length) * t2.length;
    let n = "";
    for (; n.length < 20; ) {
      const s = nt(40);
      for (let i = 0; i < s.length; ++i)
        n.length < 20 && s[i] < e && (n += t2.charAt(s[i] % t2.length));
    }
    return n;
  }
};
function it(t2, e) {
  return t2 < e ? -1 : t2 > e ? 1 : 0;
}
function rt(t2, e, n) {
  return t2.length === e.length && t2.every((t3, s) => n(t3, e[s]));
}
function ot(t2) {
  return t2 + "\0";
}
var ut = class {
  constructor(t2, e) {
    if (this.seconds = t2, this.nanoseconds = e, e < 0)
      throw new Q2(G.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (e >= 1e9)
      throw new Q2(G.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (t2 < -62135596800)
      throw new Q2(G.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
    if (t2 >= 253402300800)
      throw new Q2(G.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
  }
  static now() {
    return ut.fromMillis(Date.now());
  }
  static fromDate(t2) {
    return ut.fromMillis(t2.getTime());
  }
  static fromMillis(t2) {
    const e = Math.floor(t2 / 1e3), n = Math.floor(1e6 * (t2 - 1e3 * e));
    return new ut(e, n);
  }
  toDate() {
    return new Date(this.toMillis());
  }
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(t2) {
    return this.seconds === t2.seconds ? it(this.nanoseconds, t2.nanoseconds) : it(this.seconds, t2.seconds);
  }
  isEqual(t2) {
    return t2.seconds === this.seconds && t2.nanoseconds === this.nanoseconds;
  }
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  valueOf() {
    const t2 = this.seconds - -62135596800;
    return String(t2).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
};
var ct = class {
  constructor(t2) {
    this.timestamp = t2;
  }
  static fromTimestamp(t2) {
    return new ct(t2);
  }
  static min() {
    return new ct(new ut(0, 0));
  }
  static max() {
    return new ct(new ut(253402300799, 999999999));
  }
  compareTo(t2) {
    return this.timestamp._compareTo(t2.timestamp);
  }
  isEqual(t2) {
    return this.timestamp.isEqual(t2.timestamp);
  }
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
};
var at = class {
  constructor(t2, e, n) {
    e === void 0 ? e = 0 : e > t2.length && L2(), n === void 0 ? n = t2.length - e : n > t2.length - e && L2(), this.segments = t2, this.offset = e, this.len = n;
  }
  get length() {
    return this.len;
  }
  isEqual(t2) {
    return at.comparator(this, t2) === 0;
  }
  child(t2) {
    const e = this.segments.slice(this.offset, this.limit());
    return t2 instanceof at ? t2.forEach((t3) => {
      e.push(t3);
    }) : e.push(t2), this.construct(e);
  }
  limit() {
    return this.offset + this.length;
  }
  popFirst(t2) {
    return t2 = t2 === void 0 ? 1 : t2, this.construct(this.segments, this.offset + t2, this.length - t2);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(t2) {
    return this.segments[this.offset + t2];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(t2) {
    if (t2.length < this.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  isImmediateParentOf(t2) {
    if (this.length + 1 !== t2.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  forEach(t2) {
    for (let e = this.offset, n = this.limit(); e < n; e++)
      t2(this.segments[e]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(t2, e) {
    const n = Math.min(t2.length, e.length);
    for (let s = 0; s < n; s++) {
      const n2 = t2.get(s), i = e.get(s);
      if (n2 < i)
        return -1;
      if (n2 > i)
        return 1;
    }
    return t2.length < e.length ? -1 : t2.length > e.length ? 1 : 0;
  }
};
var ht = class extends at {
  construct(t2, e, n) {
    return new ht(t2, e, n);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  static fromString(...t2) {
    const e = [];
    for (const n of t2) {
      if (n.indexOf("//") >= 0)
        throw new Q2(G.INVALID_ARGUMENT, `Invalid segment (${n}). Paths must not contain // in them.`);
      e.push(...n.split("/").filter((t3) => t3.length > 0));
    }
    return new ht(e);
  }
  static emptyPath() {
    return new ht([]);
  }
};
var lt = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
var ft = class extends at {
  construct(t2, e, n) {
    return new ft(t2, e, n);
  }
  static isValidIdentifier(t2) {
    return lt.test(t2);
  }
  canonicalString() {
    return this.toArray().map((t2) => (t2 = t2.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), ft.isValidIdentifier(t2) || (t2 = "`" + t2 + "`"), t2)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  isKeyField() {
    return this.length === 1 && this.get(0) === "__name__";
  }
  static keyField() {
    return new ft(["__name__"]);
  }
  static fromServerFormat(t2) {
    const e = [];
    let n = "", s = 0;
    const i = () => {
      if (n.length === 0)
        throw new Q2(G.INVALID_ARGUMENT, `Invalid field path (${t2}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      e.push(n), n = "";
    };
    let r = false;
    for (; s < t2.length; ) {
      const e2 = t2[s];
      if (e2 === "\\") {
        if (s + 1 === t2.length)
          throw new Q2(G.INVALID_ARGUMENT, "Path has trailing escape character: " + t2);
        const e3 = t2[s + 1];
        if (e3 !== "\\" && e3 !== "." && e3 !== "`")
          throw new Q2(G.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t2);
        n += e3, s += 2;
      } else
        e2 === "`" ? (r = !r, s++) : e2 !== "." || r ? (n += e2, s++) : (i(), s++);
    }
    if (i(), r)
      throw new Q2(G.INVALID_ARGUMENT, "Unterminated ` in path: " + t2);
    return new ft(e);
  }
  static emptyPath() {
    return new ft([]);
  }
};
var dt = class {
  constructor(t2) {
    this.path = t2;
  }
  static fromPath(t2) {
    return new dt(ht.fromString(t2));
  }
  static fromName(t2) {
    return new dt(ht.fromString(t2).popFirst(5));
  }
  static empty() {
    return new dt(ht.emptyPath());
  }
  get collectionGroup() {
    return this.path.popLast().lastSegment();
  }
  hasCollectionId(t2) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === t2;
  }
  getCollectionGroup() {
    return this.path.get(this.path.length - 2);
  }
  getCollectionPath() {
    return this.path.popLast();
  }
  isEqual(t2) {
    return t2 !== null && ht.comparator(this.path, t2.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(t2, e) {
    return ht.comparator(t2.path, e.path);
  }
  static isDocumentKey(t2) {
    return t2.length % 2 == 0;
  }
  static fromSegments(t2) {
    return new dt(new ht(t2.slice()));
  }
};
var _t = class {
  constructor(t2, e, n, s) {
    this.indexId = t2, this.collectionGroup = e, this.fields = n, this.indexState = s;
  }
};
function wt(t2) {
  return t2.fields.find((t3) => t3.kind === 2);
}
function mt(t2) {
  return t2.fields.filter((t3) => t3.kind !== 2);
}
_t.UNKNOWN_ID = -1;
var gt = class {
  constructor(t2, e) {
    this.fieldPath = t2, this.kind = e;
  }
};
var yt = class {
  constructor(t2, e) {
    this.sequenceNumber = t2, this.offset = e;
  }
  static empty() {
    return new yt(0, Tt.min());
  }
};
function pt(t2, e) {
  const n = t2.toTimestamp().seconds, s = t2.toTimestamp().nanoseconds + 1, i = ct.fromTimestamp(s === 1e9 ? new ut(n + 1, 0) : new ut(n, s));
  return new Tt(i, dt.empty(), e);
}
function It(t2) {
  return new Tt(t2.readTime, t2.key, -1);
}
var Tt = class {
  constructor(t2, e, n) {
    this.readTime = t2, this.documentKey = e, this.largestBatchId = n;
  }
  static min() {
    return new Tt(ct.min(), dt.empty(), -1);
  }
  static max() {
    return new Tt(ct.max(), dt.empty(), -1);
  }
};
function Et(t2, e) {
  let n = t2.readTime.compareTo(e.readTime);
  return n !== 0 ? n : (n = dt.comparator(t2.documentKey, e.documentKey), n !== 0 ? n : it(t2.largestBatchId, e.largestBatchId));
}
var At = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
var Rt = class {
  constructor() {
    this.onCommittedListeners = [];
  }
  addOnCommittedListener(t2) {
    this.onCommittedListeners.push(t2);
  }
  raiseOnCommittedEvent() {
    this.onCommittedListeners.forEach((t2) => t2());
  }
};
async function bt(t2) {
  if (t2.code !== G.FAILED_PRECONDITION || t2.message !== At)
    throw t2;
  M2("LocalStore", "Unexpectedly lost primary lease");
}
var Pt = class {
  constructor(t2) {
    this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = false, this.callbackAttached = false, t2((t3) => {
      this.isDone = true, this.result = t3, this.nextCallback && this.nextCallback(t3);
    }, (t3) => {
      this.isDone = true, this.error = t3, this.catchCallback && this.catchCallback(t3);
    });
  }
  catch(t2) {
    return this.next(void 0, t2);
  }
  next(t2, e) {
    return this.callbackAttached && L2(), this.callbackAttached = true, this.isDone ? this.error ? this.wrapFailure(e, this.error) : this.wrapSuccess(t2, this.result) : new Pt((n, s) => {
      this.nextCallback = (e2) => {
        this.wrapSuccess(t2, e2).next(n, s);
      }, this.catchCallback = (t3) => {
        this.wrapFailure(e, t3).next(n, s);
      };
    });
  }
  toPromise() {
    return new Promise((t2, e) => {
      this.next(t2, e);
    });
  }
  wrapUserFunction(t2) {
    try {
      const e = t2();
      return e instanceof Pt ? e : Pt.resolve(e);
    } catch (t3) {
      return Pt.reject(t3);
    }
  }
  wrapSuccess(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : Pt.resolve(e);
  }
  wrapFailure(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : Pt.reject(e);
  }
  static resolve(t2) {
    return new Pt((e, n) => {
      e(t2);
    });
  }
  static reject(t2) {
    return new Pt((e, n) => {
      n(t2);
    });
  }
  static waitFor(t2) {
    return new Pt((e, n) => {
      let s = 0, i = 0, r = false;
      t2.forEach((t3) => {
        ++s, t3.next(() => {
          ++i, r && i === s && e();
        }, (t4) => n(t4));
      }), r = true, i === s && e();
    });
  }
  static or(t2) {
    let e = Pt.resolve(false);
    for (const n of t2)
      e = e.next((t3) => t3 ? Pt.resolve(t3) : n());
    return e;
  }
  static forEach(t2, e) {
    const n = [];
    return t2.forEach((t3, s) => {
      n.push(e.call(this, t3, s));
    }), this.waitFor(n);
  }
  static mapArray(t2, e) {
    return new Pt((n, s) => {
      const i = t2.length, r = new Array(i);
      let o = 0;
      for (let u = 0; u < i; u++) {
        const c = u;
        e(t2[c]).next((t3) => {
          r[c] = t3, ++o, o === i && n(r);
        }, (t3) => s(t3));
      }
    });
  }
  static doWhile(t2, e) {
    return new Pt((n, s) => {
      const i = () => {
        t2() === true ? e().next(() => {
          i();
        }, s) : n();
      };
      i();
    });
  }
};
var vt = class {
  constructor(t2, e) {
    this.action = t2, this.transaction = e, this.aborted = false, this.T = new j(), this.transaction.oncomplete = () => {
      this.T.resolve();
    }, this.transaction.onabort = () => {
      e.error ? this.T.reject(new Dt(t2, e.error)) : this.T.resolve();
    }, this.transaction.onerror = (e2) => {
      const n = Ot(e2.target.error);
      this.T.reject(new Dt(t2, n));
    };
  }
  static open(t2, e, n, s) {
    try {
      return new vt(e, t2.transaction(s, n));
    } catch (t3) {
      throw new Dt(e, t3);
    }
  }
  get A() {
    return this.T.promise;
  }
  abort(t2) {
    t2 && this.T.reject(t2), this.aborted || (M2("SimpleDb", "Aborting transaction:", t2 ? t2.message : "Client-initiated abort"), this.aborted = true, this.transaction.abort());
  }
  R() {
    const t2 = this.transaction;
    this.aborted || typeof t2.commit != "function" || t2.commit();
  }
  store(t2) {
    const e = this.transaction.objectStore(t2);
    return new xt(e);
  }
};
var Vt = class {
  constructor(t2, e, n) {
    this.name = t2, this.version = e, this.P = n;
    Vt.v(getUA()) === 12.2 && F2("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
  }
  static delete(t2) {
    return M2("SimpleDb", "Removing database:", t2), Nt(window.indexedDB.deleteDatabase(t2)).toPromise();
  }
  static V() {
    if (!isIndexedDBAvailable())
      return false;
    if (Vt.S())
      return true;
    const t2 = getUA(), e = Vt.v(t2), n = 0 < e && e < 10, s = Vt.D(t2), i = 0 < s && s < 4.5;
    return !(t2.indexOf("MSIE ") > 0 || t2.indexOf("Trident/") > 0 || t2.indexOf("Edge/") > 0 || n || i);
  }
  static S() {
    var t2;
    return typeof process != "undefined" && ((t2 = process.env) === null || t2 === void 0 ? void 0 : t2.C) === "YES";
  }
  static N(t2, e) {
    return t2.store(e);
  }
  static v(t2) {
    const e = t2.match(/i(?:phone|pad|pod) os ([\d_]+)/i), n = e ? e[1].split("_").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  static D(t2) {
    const e = t2.match(/Android ([\d.]+)/i), n = e ? e[1].split(".").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  async k(t2) {
    return this.db || (M2("SimpleDb", "Opening database:", this.name), this.db = await new Promise((e, n) => {
      const s = indexedDB.open(this.name, this.version);
      s.onsuccess = (t3) => {
        const n2 = t3.target.result;
        e(n2);
      }, s.onblocked = () => {
        n(new Dt(t2, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."));
      }, s.onerror = (e2) => {
        const s2 = e2.target.error;
        s2.name === "VersionError" ? n(new Q2(G.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.")) : s2.name === "InvalidStateError" ? n(new Q2(G.FAILED_PRECONDITION, "Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: " + s2)) : n(new Dt(t2, s2));
      }, s.onupgradeneeded = (t3) => {
        M2("SimpleDb", 'Database "' + this.name + '" requires upgrade from version:', t3.oldVersion);
        const e2 = t3.target.result;
        this.P.O(e2, s.transaction, t3.oldVersion, this.version).next(() => {
          M2("SimpleDb", "Database upgrade to version " + this.version + " complete");
        });
      };
    })), this.M && (this.db.onversionchange = (t3) => this.M(t3)), this.db;
  }
  F(t2) {
    this.M = t2, this.db && (this.db.onversionchange = (e) => t2(e));
  }
  async runTransaction(t2, e, n, s) {
    const i = e === "readonly";
    let r = 0;
    for (; ; ) {
      ++r;
      try {
        this.db = await this.k(t2);
        const e2 = vt.open(this.db, t2, i ? "readonly" : "readwrite", n), r2 = s(e2).next((t3) => (e2.R(), t3)).catch((t3) => (e2.abort(t3), Pt.reject(t3))).toPromise();
        return r2.catch(() => {
        }), await e2.A, r2;
      } catch (t3) {
        const e2 = t3.name !== "FirebaseError" && r < 3;
        if (M2("SimpleDb", "Transaction failed with error:", t3.message, "Retrying:", e2), this.close(), !e2)
          return Promise.reject(t3);
      }
    }
  }
  close() {
    this.db && this.db.close(), this.db = void 0;
  }
};
var St = class {
  constructor(t2) {
    this.$ = t2, this.B = false, this.L = null;
  }
  get isDone() {
    return this.B;
  }
  get U() {
    return this.L;
  }
  set cursor(t2) {
    this.$ = t2;
  }
  done() {
    this.B = true;
  }
  q(t2) {
    this.L = t2;
  }
  delete() {
    return Nt(this.$.delete());
  }
};
var Dt = class extends Q2 {
  constructor(t2, e) {
    super(G.UNAVAILABLE, `IndexedDB transaction '${t2}' failed: ${e}`), this.name = "IndexedDbTransactionError";
  }
};
function Ct(t2) {
  return t2.name === "IndexedDbTransactionError";
}
var xt = class {
  constructor(t2) {
    this.store = t2;
  }
  put(t2, e) {
    let n;
    return e !== void 0 ? (M2("SimpleDb", "PUT", this.store.name, t2, e), n = this.store.put(e, t2)) : (M2("SimpleDb", "PUT", this.store.name, "<auto-key>", t2), n = this.store.put(t2)), Nt(n);
  }
  add(t2) {
    M2("SimpleDb", "ADD", this.store.name, t2, t2);
    return Nt(this.store.add(t2));
  }
  get(t2) {
    return Nt(this.store.get(t2)).next((e) => (e === void 0 && (e = null), M2("SimpleDb", "GET", this.store.name, t2, e), e));
  }
  delete(t2) {
    M2("SimpleDb", "DELETE", this.store.name, t2);
    return Nt(this.store.delete(t2));
  }
  count() {
    M2("SimpleDb", "COUNT", this.store.name);
    return Nt(this.store.count());
  }
  K(t2, e) {
    const n = this.options(t2, e);
    if (n.index || typeof this.store.getAll != "function") {
      const t3 = this.cursor(n), e2 = [];
      return this.G(t3, (t4, n2) => {
        e2.push(n2);
      }).next(() => e2);
    }
    {
      const t3 = this.store.getAll(n.range);
      return new Pt((e2, n2) => {
        t3.onerror = (t4) => {
          n2(t4.target.error);
        }, t3.onsuccess = (t4) => {
          e2(t4.target.result);
        };
      });
    }
  }
  j(t2, e) {
    const n = this.store.getAll(t2, e === null ? void 0 : e);
    return new Pt((t3, e2) => {
      n.onerror = (t4) => {
        e2(t4.target.error);
      }, n.onsuccess = (e3) => {
        t3(e3.target.result);
      };
    });
  }
  W(t2, e) {
    M2("SimpleDb", "DELETE ALL", this.store.name);
    const n = this.options(t2, e);
    n.H = false;
    const s = this.cursor(n);
    return this.G(s, (t3, e2, n2) => n2.delete());
  }
  J(t2, e) {
    let n;
    e ? n = t2 : (n = {}, e = t2);
    const s = this.cursor(n);
    return this.G(s, e);
  }
  Y(t2) {
    const e = this.cursor({});
    return new Pt((n, s) => {
      e.onerror = (t3) => {
        const e2 = Ot(t3.target.error);
        s(e2);
      }, e.onsuccess = (e2) => {
        const s2 = e2.target.result;
        s2 ? t2(s2.primaryKey, s2.value).next((t3) => {
          t3 ? s2.continue() : n();
        }) : n();
      };
    });
  }
  G(t2, e) {
    const n = [];
    return new Pt((s, i) => {
      t2.onerror = (t3) => {
        i(t3.target.error);
      }, t2.onsuccess = (t3) => {
        const i2 = t3.target.result;
        if (!i2)
          return void s();
        const r = new St(i2), o = e(i2.primaryKey, i2.value, r);
        if (o instanceof Pt) {
          const t4 = o.catch((t5) => (r.done(), Pt.reject(t5)));
          n.push(t4);
        }
        r.isDone ? s() : r.U === null ? i2.continue() : i2.continue(r.U);
      };
    }).next(() => Pt.waitFor(n));
  }
  options(t2, e) {
    let n;
    return t2 !== void 0 && (typeof t2 == "string" ? n = t2 : e = t2), {
      index: n,
      range: e
    };
  }
  cursor(t2) {
    let e = "next";
    if (t2.reverse && (e = "prev"), t2.index) {
      const n = this.store.index(t2.index);
      return t2.H ? n.openKeyCursor(t2.range, e) : n.openCursor(t2.range, e);
    }
    return this.store.openCursor(t2.range, e);
  }
};
function Nt(t2) {
  return new Pt((e, n) => {
    t2.onsuccess = (t3) => {
      const n2 = t3.target.result;
      e(n2);
    }, t2.onerror = (t3) => {
      const e2 = Ot(t3.target.error);
      n(e2);
    };
  });
}
var kt = false;
function Ot(t2) {
  const e = Vt.v(getUA());
  if (e >= 12.2 && e < 13) {
    const e2 = "An internal error was encountered in the Indexed Database server";
    if (t2.message.indexOf(e2) >= 0) {
      const t3 = new Q2("internal", `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${e2}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`);
      return kt || (kt = true, setTimeout(() => {
        throw t3;
      }, 0)), t3;
    }
  }
  return t2;
}
var Mt = class {
  constructor(t2, e) {
    this.asyncQueue = t2, this.X = e, this.task = null;
  }
  start() {
  }
  stop() {
    this.task && (this.task.cancel(), this.task = null);
  }
  get started() {
    return this.task !== null;
  }
  Z(t2) {
    M2("IndexBackiller", `Scheduled in ${t2}ms`), this.task = this.asyncQueue.enqueueAfterDelay("index_backfill", t2, async () => {
      this.task = null;
      try {
        M2("IndexBackiller", `Documents written: ${await this.X.tt()}`);
      } catch (t3) {
        Ct(t3) ? M2("IndexBackiller", "Ignoring IndexedDB error during index backfill: ", t3) : await bt(t3);
      }
      await this.Z(1);
    });
  }
};
var Ft = class {
  constructor(t2, e) {
    this.localStore = t2, this.persistence = e;
  }
  async tt(t2 = 50) {
    return this.persistence.runTransaction("Backfill Indexes", "readwrite-primary", (e) => this.et(e, t2));
  }
  et(t2, e) {
    const n = /* @__PURE__ */ new Set();
    let s = e, i = true;
    return Pt.doWhile(() => i === true && s > 0, () => this.localStore.indexManager.getNextCollectionGroupToUpdate(t2).next((e2) => {
      if (e2 !== null && !n.has(e2))
        return M2("IndexBackiller", `Processing collection: ${e2}`), this.nt(t2, e2, s).next((t3) => {
          s -= t3, n.add(e2);
        });
      i = false;
    })).next(() => e - s);
  }
  nt(t2, e, n) {
    return this.localStore.indexManager.getMinOffsetFromCollectionGroup(t2, e).next((s) => this.localStore.localDocuments.getNextDocuments(t2, e, s, n).next((n2) => {
      const i = n2.changes;
      return this.localStore.indexManager.updateIndexEntries(t2, i).next(() => this.st(s, n2)).next((n3) => (M2("IndexBackiller", `Updating offset: ${n3}`), this.localStore.indexManager.updateCollectionGroup(t2, e, n3))).next(() => i.size);
    }));
  }
  st(t2, e) {
    let n = t2;
    return e.changes.forEach((t3, e2) => {
      const s = It(e2);
      Et(s, n) > 0 && (n = s);
    }), new Tt(n.readTime, n.documentKey, Math.max(e.batchId, t2.largestBatchId));
  }
};
var $t = class {
  constructor(t2, e) {
    this.previousValue = t2, e && (e.sequenceNumberHandler = (t3) => this.it(t3), this.rt = (t3) => e.writeSequenceNumber(t3));
  }
  it(t2) {
    return this.previousValue = Math.max(t2, this.previousValue), this.previousValue;
  }
  next() {
    const t2 = ++this.previousValue;
    return this.rt && this.rt(t2), t2;
  }
};
function Bt(t2) {
  let e = 0;
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e++;
  return e;
}
function Lt(t2, e) {
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e(n, t2[n]);
}
function Ut(t2) {
  for (const e in t2)
    if (Object.prototype.hasOwnProperty.call(t2, e))
      return false;
  return true;
}
$t.ot = -1;
var qt = class {
  constructor(t2, e) {
    this.comparator = t2, this.root = e || Gt.EMPTY;
  }
  insert(t2, e) {
    return new qt(this.comparator, this.root.insert(t2, e, this.comparator).copy(null, null, Gt.BLACK, null, null));
  }
  remove(t2) {
    return new qt(this.comparator, this.root.remove(t2, this.comparator).copy(null, null, Gt.BLACK, null, null));
  }
  get(t2) {
    let e = this.root;
    for (; !e.isEmpty(); ) {
      const n = this.comparator(t2, e.key);
      if (n === 0)
        return e.value;
      n < 0 ? e = e.left : n > 0 && (e = e.right);
    }
    return null;
  }
  indexOf(t2) {
    let e = 0, n = this.root;
    for (; !n.isEmpty(); ) {
      const s = this.comparator(t2, n.key);
      if (s === 0)
        return e + n.left.size;
      s < 0 ? n = n.left : (e += n.left.size + 1, n = n.right);
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  get size() {
    return this.root.size;
  }
  minKey() {
    return this.root.minKey();
  }
  maxKey() {
    return this.root.maxKey();
  }
  inorderTraversal(t2) {
    return this.root.inorderTraversal(t2);
  }
  forEach(t2) {
    this.inorderTraversal((e, n) => (t2(e, n), false));
  }
  toString() {
    const t2 = [];
    return this.inorderTraversal((e, n) => (t2.push(`${e}:${n}`), false)), `{${t2.join(", ")}}`;
  }
  reverseTraversal(t2) {
    return this.root.reverseTraversal(t2);
  }
  getIterator() {
    return new Kt(this.root, null, this.comparator, false);
  }
  getIteratorFrom(t2) {
    return new Kt(this.root, t2, this.comparator, false);
  }
  getReverseIterator() {
    return new Kt(this.root, null, this.comparator, true);
  }
  getReverseIteratorFrom(t2) {
    return new Kt(this.root, t2, this.comparator, true);
  }
};
var Kt = class {
  constructor(t2, e, n, s) {
    this.isReverse = s, this.nodeStack = [];
    let i = 1;
    for (; !t2.isEmpty(); )
      if (i = e ? n(t2.key, e) : 1, e && s && (i *= -1), i < 0)
        t2 = this.isReverse ? t2.left : t2.right;
      else {
        if (i === 0) {
          this.nodeStack.push(t2);
          break;
        }
        this.nodeStack.push(t2), t2 = this.isReverse ? t2.right : t2.left;
      }
  }
  getNext() {
    let t2 = this.nodeStack.pop();
    const e = {
      key: t2.key,
      value: t2.value
    };
    if (this.isReverse)
      for (t2 = t2.left; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.right;
    else
      for (t2 = t2.right; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.left;
    return e;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (this.nodeStack.length === 0)
      return null;
    const t2 = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: t2.key,
      value: t2.value
    };
  }
};
var Gt = class {
  constructor(t2, e, n, s, i) {
    this.key = t2, this.value = e, this.color = n != null ? n : Gt.RED, this.left = s != null ? s : Gt.EMPTY, this.right = i != null ? i : Gt.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  copy(t2, e, n, s, i) {
    return new Gt(t2 != null ? t2 : this.key, e != null ? e : this.value, n != null ? n : this.color, s != null ? s : this.left, i != null ? i : this.right);
  }
  isEmpty() {
    return false;
  }
  inorderTraversal(t2) {
    return this.left.inorderTraversal(t2) || t2(this.key, this.value) || this.right.inorderTraversal(t2);
  }
  reverseTraversal(t2) {
    return this.right.reverseTraversal(t2) || t2(this.key, this.value) || this.left.reverseTraversal(t2);
  }
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  minKey() {
    return this.min().key;
  }
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  insert(t2, e, n) {
    let s = this;
    const i = n(t2, s.key);
    return s = i < 0 ? s.copy(null, null, null, s.left.insert(t2, e, n), null) : i === 0 ? s.copy(null, e, null, null, null) : s.copy(null, null, null, null, s.right.insert(t2, e, n)), s.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty())
      return Gt.EMPTY;
    let t2 = this;
    return t2.left.isRed() || t2.left.left.isRed() || (t2 = t2.moveRedLeft()), t2 = t2.copy(null, null, null, t2.left.removeMin(), null), t2.fixUp();
  }
  remove(t2, e) {
    let n, s = this;
    if (e(t2, s.key) < 0)
      s.left.isEmpty() || s.left.isRed() || s.left.left.isRed() || (s = s.moveRedLeft()), s = s.copy(null, null, null, s.left.remove(t2, e), null);
    else {
      if (s.left.isRed() && (s = s.rotateRight()), s.right.isEmpty() || s.right.isRed() || s.right.left.isRed() || (s = s.moveRedRight()), e(t2, s.key) === 0) {
        if (s.right.isEmpty())
          return Gt.EMPTY;
        n = s.right.min(), s = s.copy(n.key, n.value, null, null, s.right.removeMin());
      }
      s = s.copy(null, null, null, null, s.right.remove(t2, e));
    }
    return s.fixUp();
  }
  isRed() {
    return this.color;
  }
  fixUp() {
    let t2 = this;
    return t2.right.isRed() && !t2.left.isRed() && (t2 = t2.rotateLeft()), t2.left.isRed() && t2.left.left.isRed() && (t2 = t2.rotateRight()), t2.left.isRed() && t2.right.isRed() && (t2 = t2.colorFlip()), t2;
  }
  moveRedLeft() {
    let t2 = this.colorFlip();
    return t2.right.left.isRed() && (t2 = t2.copy(null, null, null, null, t2.right.rotateRight()), t2 = t2.rotateLeft(), t2 = t2.colorFlip()), t2;
  }
  moveRedRight() {
    let t2 = this.colorFlip();
    return t2.left.left.isRed() && (t2 = t2.rotateRight(), t2 = t2.colorFlip()), t2;
  }
  rotateLeft() {
    const t2 = this.copy(null, null, Gt.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, t2, null);
  }
  rotateRight() {
    const t2 = this.copy(null, null, Gt.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, t2);
  }
  colorFlip() {
    const t2 = this.left.copy(null, null, !this.left.color, null, null), e = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, t2, e);
  }
  checkMaxDepth() {
    const t2 = this.check();
    return Math.pow(2, t2) <= this.size + 1;
  }
  check() {
    if (this.isRed() && this.left.isRed())
      throw L2();
    if (this.right.isRed())
      throw L2();
    const t2 = this.left.check();
    if (t2 !== this.right.check())
      throw L2();
    return t2 + (this.isRed() ? 0 : 1);
  }
};
Gt.EMPTY = null, Gt.RED = true, Gt.BLACK = false;
Gt.EMPTY = new class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw L2();
  }
  get value() {
    throw L2();
  }
  get color() {
    throw L2();
  }
  get left() {
    throw L2();
  }
  get right() {
    throw L2();
  }
  copy(t2, e, n, s, i) {
    return this;
  }
  insert(t2, e, n) {
    return new Gt(t2, e);
  }
  remove(t2, e) {
    return this;
  }
  isEmpty() {
    return true;
  }
  inorderTraversal(t2) {
    return false;
  }
  reverseTraversal(t2) {
    return false;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return false;
  }
  checkMaxDepth() {
    return true;
  }
  check() {
    return 0;
  }
}();
var Qt = class {
  constructor(t2) {
    this.comparator = t2, this.data = new qt(this.comparator);
  }
  has(t2) {
    return this.data.get(t2) !== null;
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(t2) {
    return this.data.indexOf(t2);
  }
  forEach(t2) {
    this.data.inorderTraversal((e, n) => (t2(e), false));
  }
  forEachInRange(t2, e) {
    const n = this.data.getIteratorFrom(t2[0]);
    for (; n.hasNext(); ) {
      const s = n.getNext();
      if (this.comparator(s.key, t2[1]) >= 0)
        return;
      e(s.key);
    }
  }
  forEachWhile(t2, e) {
    let n;
    for (n = e !== void 0 ? this.data.getIteratorFrom(e) : this.data.getIterator(); n.hasNext(); ) {
      if (!t2(n.getNext().key))
        return;
    }
  }
  firstAfterOrEqual(t2) {
    const e = this.data.getIteratorFrom(t2);
    return e.hasNext() ? e.getNext().key : null;
  }
  getIterator() {
    return new jt(this.data.getIterator());
  }
  getIteratorFrom(t2) {
    return new jt(this.data.getIteratorFrom(t2));
  }
  add(t2) {
    return this.copy(this.data.remove(t2).insert(t2, true));
  }
  delete(t2) {
    return this.has(t2) ? this.copy(this.data.remove(t2)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(t2) {
    let e = this;
    return e.size < t2.size && (e = t2, t2 = this), t2.forEach((t3) => {
      e = e.add(t3);
    }), e;
  }
  isEqual(t2) {
    if (!(t2 instanceof Qt))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.data.getIterator(), n = t2.data.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (this.comparator(t3, s) !== 0)
        return false;
    }
    return true;
  }
  toArray() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e);
    }), t2;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), "SortedSet(" + t2.toString() + ")";
  }
  copy(t2) {
    const e = new Qt(this.comparator);
    return e.data = t2, e;
  }
};
var jt = class {
  constructor(t2) {
    this.iter = t2;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
};
function Wt(t2) {
  return t2.hasNext() ? t2.getNext() : void 0;
}
var zt = class {
  constructor(t2) {
    this.fields = t2, t2.sort(ft.comparator);
  }
  static empty() {
    return new zt([]);
  }
  unionWith(t2) {
    let e = new Qt(ft.comparator);
    for (const t3 of this.fields)
      e = e.add(t3);
    for (const n of t2)
      e = e.add(n);
    return new zt(e.toArray());
  }
  covers(t2) {
    for (const e of this.fields)
      if (e.isPrefixOf(t2))
        return true;
    return false;
  }
  isEqual(t2) {
    return rt(this.fields, t2.fields, (t3, e) => t3.isEqual(e));
  }
};
function Ht() {
  return typeof atob != "undefined";
}
var Jt = class {
  constructor(t2) {
    this.binaryString = t2;
  }
  static fromBase64String(t2) {
    const e = atob(t2);
    return new Jt(e);
  }
  static fromUint8Array(t2) {
    const e = function(t3) {
      let e2 = "";
      for (let n = 0; n < t3.length; ++n)
        e2 += String.fromCharCode(t3[n]);
      return e2;
    }(t2);
    return new Jt(e);
  }
  [Symbol.iterator]() {
    let t2 = 0;
    return {
      next: () => t2 < this.binaryString.length ? {
        value: this.binaryString.charCodeAt(t2++),
        done: false
      } : {
        value: void 0,
        done: true
      }
    };
  }
  toBase64() {
    return t2 = this.binaryString, btoa(t2);
    var t2;
  }
  toUint8Array() {
    return function(t2) {
      const e = new Uint8Array(t2.length);
      for (let n = 0; n < t2.length; n++)
        e[n] = t2.charCodeAt(n);
      return e;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(t2) {
    return it(this.binaryString, t2.binaryString);
  }
  isEqual(t2) {
    return this.binaryString === t2.binaryString;
  }
};
Jt.EMPTY_BYTE_STRING = new Jt("");
var Yt = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function Xt(t2) {
  if (U2(!!t2), typeof t2 == "string") {
    let e = 0;
    const n = Yt.exec(t2);
    if (U2(!!n), n[1]) {
      let t3 = n[1];
      t3 = (t3 + "000000000").substr(0, 9), e = Number(t3);
    }
    const s = new Date(t2);
    return {
      seconds: Math.floor(s.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: Zt(t2.seconds),
    nanos: Zt(t2.nanos)
  };
}
function Zt(t2) {
  return typeof t2 == "number" ? t2 : typeof t2 == "string" ? Number(t2) : 0;
}
function te(t2) {
  return typeof t2 == "string" ? Jt.fromBase64String(t2) : Jt.fromUint8Array(t2);
}
function ee(t2) {
  var e, n;
  return ((n = (((e = t2 == null ? void 0 : t2.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || n === void 0 ? void 0 : n.stringValue) === "server_timestamp";
}
function ne(t2) {
  const e = t2.mapValue.fields.__previous_value__;
  return ee(e) ? ne(e) : e;
}
function se(t2) {
  const e = Xt(t2.mapValue.fields.__local_write_time__.timestampValue);
  return new ut(e.seconds, e.nanos);
}
var ie = class {
  constructor(t2, e, n, s, i, r, o, u) {
    this.databaseId = t2, this.appId = e, this.persistenceKey = n, this.host = s, this.ssl = i, this.forceLongPolling = r, this.autoDetectLongPolling = o, this.useFetchStreams = u;
  }
};
var re = class {
  constructor(t2, e) {
    this.projectId = t2, this.database = e || "(default)";
  }
  static empty() {
    return new re("", "");
  }
  get isDefaultDatabase() {
    return this.database === "(default)";
  }
  isEqual(t2) {
    return t2 instanceof re && t2.projectId === this.projectId && t2.database === this.database;
  }
};
function oe(t2) {
  return t2 == null;
}
function ue(t2) {
  return t2 === 0 && 1 / t2 == -1 / 0;
}
function ce(t2) {
  return typeof t2 == "number" && Number.isInteger(t2) && !ue(t2) && t2 <= Number.MAX_SAFE_INTEGER && t2 >= Number.MIN_SAFE_INTEGER;
}
var ae = {
  mapValue: {
    fields: {
      __type__: {
        stringValue: "__max__"
      }
    }
  }
};
var he = {
  nullValue: "NULL_VALUE"
};
function le(t2) {
  return "nullValue" in t2 ? 0 : "booleanValue" in t2 ? 1 : "integerValue" in t2 || "doubleValue" in t2 ? 2 : "timestampValue" in t2 ? 3 : "stringValue" in t2 ? 5 : "bytesValue" in t2 ? 6 : "referenceValue" in t2 ? 7 : "geoPointValue" in t2 ? 8 : "arrayValue" in t2 ? 9 : "mapValue" in t2 ? ee(t2) ? 4 : be(t2) ? 9007199254740991 : 10 : L2();
}
function fe(t2, e) {
  if (t2 === e)
    return true;
  const n = le(t2);
  if (n !== le(e))
    return false;
  switch (n) {
    case 0:
    case 9007199254740991:
      return true;
    case 1:
      return t2.booleanValue === e.booleanValue;
    case 4:
      return se(t2).isEqual(se(e));
    case 3:
      return function(t3, e2) {
        if (typeof t3.timestampValue == "string" && typeof e2.timestampValue == "string" && t3.timestampValue.length === e2.timestampValue.length)
          return t3.timestampValue === e2.timestampValue;
        const n2 = Xt(t3.timestampValue), s = Xt(e2.timestampValue);
        return n2.seconds === s.seconds && n2.nanos === s.nanos;
      }(t2, e);
    case 5:
      return t2.stringValue === e.stringValue;
    case 6:
      return function(t3, e2) {
        return te(t3.bytesValue).isEqual(te(e2.bytesValue));
      }(t2, e);
    case 7:
      return t2.referenceValue === e.referenceValue;
    case 8:
      return function(t3, e2) {
        return Zt(t3.geoPointValue.latitude) === Zt(e2.geoPointValue.latitude) && Zt(t3.geoPointValue.longitude) === Zt(e2.geoPointValue.longitude);
      }(t2, e);
    case 2:
      return function(t3, e2) {
        if ("integerValue" in t3 && "integerValue" in e2)
          return Zt(t3.integerValue) === Zt(e2.integerValue);
        if ("doubleValue" in t3 && "doubleValue" in e2) {
          const n2 = Zt(t3.doubleValue), s = Zt(e2.doubleValue);
          return n2 === s ? ue(n2) === ue(s) : isNaN(n2) && isNaN(s);
        }
        return false;
      }(t2, e);
    case 9:
      return rt(t2.arrayValue.values || [], e.arrayValue.values || [], fe);
    case 10:
      return function(t3, e2) {
        const n2 = t3.mapValue.fields || {}, s = e2.mapValue.fields || {};
        if (Bt(n2) !== Bt(s))
          return false;
        for (const t4 in n2)
          if (n2.hasOwnProperty(t4) && (s[t4] === void 0 || !fe(n2[t4], s[t4])))
            return false;
        return true;
      }(t2, e);
    default:
      return L2();
  }
}
function de(t2, e) {
  return (t2.values || []).find((t3) => fe(t3, e)) !== void 0;
}
function _e(t2, e) {
  if (t2 === e)
    return 0;
  const n = le(t2), s = le(e);
  if (n !== s)
    return it(n, s);
  switch (n) {
    case 0:
    case 9007199254740991:
      return 0;
    case 1:
      return it(t2.booleanValue, e.booleanValue);
    case 2:
      return function(t3, e2) {
        const n2 = Zt(t3.integerValue || t3.doubleValue), s2 = Zt(e2.integerValue || e2.doubleValue);
        return n2 < s2 ? -1 : n2 > s2 ? 1 : n2 === s2 ? 0 : isNaN(n2) ? isNaN(s2) ? 0 : -1 : 1;
      }(t2, e);
    case 3:
      return we(t2.timestampValue, e.timestampValue);
    case 4:
      return we(se(t2), se(e));
    case 5:
      return it(t2.stringValue, e.stringValue);
    case 6:
      return function(t3, e2) {
        const n2 = te(t3), s2 = te(e2);
        return n2.compareTo(s2);
      }(t2.bytesValue, e.bytesValue);
    case 7:
      return function(t3, e2) {
        const n2 = t3.split("/"), s2 = e2.split("/");
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; t4++) {
          const e3 = it(n2[t4], s2[t4]);
          if (e3 !== 0)
            return e3;
        }
        return it(n2.length, s2.length);
      }(t2.referenceValue, e.referenceValue);
    case 8:
      return function(t3, e2) {
        const n2 = it(Zt(t3.latitude), Zt(e2.latitude));
        if (n2 !== 0)
          return n2;
        return it(Zt(t3.longitude), Zt(e2.longitude));
      }(t2.geoPointValue, e.geoPointValue);
    case 9:
      return function(t3, e2) {
        const n2 = t3.values || [], s2 = e2.values || [];
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; ++t4) {
          const e3 = _e(n2[t4], s2[t4]);
          if (e3)
            return e3;
        }
        return it(n2.length, s2.length);
      }(t2.arrayValue, e.arrayValue);
    case 10:
      return function(t3, e2) {
        if (t3 === ae.mapValue && e2 === ae.mapValue)
          return 0;
        if (t3 === ae.mapValue)
          return 1;
        if (e2 === ae.mapValue)
          return -1;
        const n2 = t3.fields || {}, s2 = Object.keys(n2), i = e2.fields || {}, r = Object.keys(i);
        s2.sort(), r.sort();
        for (let t4 = 0; t4 < s2.length && t4 < r.length; ++t4) {
          const e3 = it(s2[t4], r[t4]);
          if (e3 !== 0)
            return e3;
          const o = _e(n2[s2[t4]], i[r[t4]]);
          if (o !== 0)
            return o;
        }
        return it(s2.length, r.length);
      }(t2.mapValue, e.mapValue);
    default:
      throw L2();
  }
}
function we(t2, e) {
  if (typeof t2 == "string" && typeof e == "string" && t2.length === e.length)
    return it(t2, e);
  const n = Xt(t2), s = Xt(e), i = it(n.seconds, s.seconds);
  return i !== 0 ? i : it(n.nanos, s.nanos);
}
function me(t2) {
  return ge(t2);
}
function ge(t2) {
  return "nullValue" in t2 ? "null" : "booleanValue" in t2 ? "" + t2.booleanValue : "integerValue" in t2 ? "" + t2.integerValue : "doubleValue" in t2 ? "" + t2.doubleValue : "timestampValue" in t2 ? function(t3) {
    const e2 = Xt(t3);
    return `time(${e2.seconds},${e2.nanos})`;
  }(t2.timestampValue) : "stringValue" in t2 ? t2.stringValue : "bytesValue" in t2 ? te(t2.bytesValue).toBase64() : "referenceValue" in t2 ? (n = t2.referenceValue, dt.fromName(n).toString()) : "geoPointValue" in t2 ? `geo(${(e = t2.geoPointValue).latitude},${e.longitude})` : "arrayValue" in t2 ? function(t3) {
    let e2 = "[", n2 = true;
    for (const s of t3.values || [])
      n2 ? n2 = false : e2 += ",", e2 += ge(s);
    return e2 + "]";
  }(t2.arrayValue) : "mapValue" in t2 ? function(t3) {
    const e2 = Object.keys(t3.fields || {}).sort();
    let n2 = "{", s = true;
    for (const i of e2)
      s ? s = false : n2 += ",", n2 += `${i}:${ge(t3.fields[i])}`;
    return n2 + "}";
  }(t2.mapValue) : L2();
  var e, n;
}
function ye(t2, e) {
  return {
    referenceValue: `projects/${t2.projectId}/databases/${t2.database}/documents/${e.path.canonicalString()}`
  };
}
function pe(t2) {
  return !!t2 && "integerValue" in t2;
}
function Ie(t2) {
  return !!t2 && "arrayValue" in t2;
}
function Te(t2) {
  return !!t2 && "nullValue" in t2;
}
function Ee(t2) {
  return !!t2 && "doubleValue" in t2 && isNaN(Number(t2.doubleValue));
}
function Ae(t2) {
  return !!t2 && "mapValue" in t2;
}
function Re(t2) {
  if (t2.geoPointValue)
    return {
      geoPointValue: Object.assign({}, t2.geoPointValue)
    };
  if (t2.timestampValue && typeof t2.timestampValue == "object")
    return {
      timestampValue: Object.assign({}, t2.timestampValue)
    };
  if (t2.mapValue) {
    const e = {
      mapValue: {
        fields: {}
      }
    };
    return Lt(t2.mapValue.fields, (t3, n) => e.mapValue.fields[t3] = Re(n)), e;
  }
  if (t2.arrayValue) {
    const e = {
      arrayValue: {
        values: []
      }
    };
    for (let n = 0; n < (t2.arrayValue.values || []).length; ++n)
      e.arrayValue.values[n] = Re(t2.arrayValue.values[n]);
    return e;
  }
  return Object.assign({}, t2);
}
function be(t2) {
  return (((t2.mapValue || {}).fields || {}).__type__ || {}).stringValue === "__max__";
}
function Pe(t2) {
  return "nullValue" in t2 ? he : "booleanValue" in t2 ? {
    booleanValue: false
  } : "integerValue" in t2 || "doubleValue" in t2 ? {
    doubleValue: NaN
  } : "timestampValue" in t2 ? {
    timestampValue: {
      seconds: Number.MIN_SAFE_INTEGER
    }
  } : "stringValue" in t2 ? {
    stringValue: ""
  } : "bytesValue" in t2 ? {
    bytesValue: ""
  } : "referenceValue" in t2 ? ye(re.empty(), dt.empty()) : "geoPointValue" in t2 ? {
    geoPointValue: {
      latitude: -90,
      longitude: -180
    }
  } : "arrayValue" in t2 ? {
    arrayValue: {}
  } : "mapValue" in t2 ? {
    mapValue: {}
  } : L2();
}
function ve(t2) {
  return "nullValue" in t2 ? {
    booleanValue: false
  } : "booleanValue" in t2 ? {
    doubleValue: NaN
  } : "integerValue" in t2 || "doubleValue" in t2 ? {
    timestampValue: {
      seconds: Number.MIN_SAFE_INTEGER
    }
  } : "timestampValue" in t2 ? {
    stringValue: ""
  } : "stringValue" in t2 ? {
    bytesValue: ""
  } : "bytesValue" in t2 ? ye(re.empty(), dt.empty()) : "referenceValue" in t2 ? {
    geoPointValue: {
      latitude: -90,
      longitude: -180
    }
  } : "geoPointValue" in t2 ? {
    arrayValue: {}
  } : "arrayValue" in t2 ? {
    mapValue: {}
  } : "mapValue" in t2 ? ae : L2();
}
function Ve(t2, e) {
  const n = _e(t2.value, e.value);
  return n !== 0 ? n : t2.inclusive && !e.inclusive ? -1 : !t2.inclusive && e.inclusive ? 1 : 0;
}
function Se(t2, e) {
  const n = _e(t2.value, e.value);
  return n !== 0 ? n : t2.inclusive && !e.inclusive ? 1 : !t2.inclusive && e.inclusive ? -1 : 0;
}
var De = class {
  constructor(t2) {
    this.value = t2;
  }
  static empty() {
    return new De({
      mapValue: {}
    });
  }
  field(t2) {
    if (t2.isEmpty())
      return this.value;
    {
      let e = this.value;
      for (let n = 0; n < t2.length - 1; ++n)
        if (e = (e.mapValue.fields || {})[t2.get(n)], !Ae(e))
          return null;
      return e = (e.mapValue.fields || {})[t2.lastSegment()], e || null;
    }
  }
  set(t2, e) {
    this.getFieldsMap(t2.popLast())[t2.lastSegment()] = Re(e);
  }
  setAll(t2) {
    let e = ft.emptyPath(), n = {}, s = [];
    t2.forEach((t3, i2) => {
      if (!e.isImmediateParentOf(i2)) {
        const t4 = this.getFieldsMap(e);
        this.applyChanges(t4, n, s), n = {}, s = [], e = i2.popLast();
      }
      t3 ? n[i2.lastSegment()] = Re(t3) : s.push(i2.lastSegment());
    });
    const i = this.getFieldsMap(e);
    this.applyChanges(i, n, s);
  }
  delete(t2) {
    const e = this.field(t2.popLast());
    Ae(e) && e.mapValue.fields && delete e.mapValue.fields[t2.lastSegment()];
  }
  isEqual(t2) {
    return fe(this.value, t2.value);
  }
  getFieldsMap(t2) {
    let e = this.value;
    e.mapValue.fields || (e.mapValue = {
      fields: {}
    });
    for (let n = 0; n < t2.length; ++n) {
      let s = e.mapValue.fields[t2.get(n)];
      Ae(s) && s.mapValue.fields || (s = {
        mapValue: {
          fields: {}
        }
      }, e.mapValue.fields[t2.get(n)] = s), e = s;
    }
    return e.mapValue.fields;
  }
  applyChanges(t2, e, n) {
    Lt(e, (e2, n2) => t2[e2] = n2);
    for (const e2 of n)
      delete t2[e2];
  }
  clone() {
    return new De(Re(this.value));
  }
};
function Ce(t2) {
  const e = [];
  return Lt(t2.fields, (t3, n) => {
    const s = new ft([t3]);
    if (Ae(n)) {
      const t4 = Ce(n.mapValue).fields;
      if (t4.length === 0)
        e.push(s);
      else
        for (const n2 of t4)
          e.push(s.child(n2));
    } else
      e.push(s);
  }), new zt(e);
}
var xe = class {
  constructor(t2, e, n, s, i, r) {
    this.key = t2, this.documentType = e, this.version = n, this.readTime = s, this.data = i, this.documentState = r;
  }
  static newInvalidDocument(t2) {
    return new xe(t2, 0, ct.min(), ct.min(), De.empty(), 0);
  }
  static newFoundDocument(t2, e, n) {
    return new xe(t2, 1, e, ct.min(), n, 0);
  }
  static newNoDocument(t2, e) {
    return new xe(t2, 2, e, ct.min(), De.empty(), 0);
  }
  static newUnknownDocument(t2, e) {
    return new xe(t2, 3, e, ct.min(), De.empty(), 2);
  }
  convertToFoundDocument(t2, e) {
    return this.version = t2, this.documentType = 1, this.data = e, this.documentState = 0, this;
  }
  convertToNoDocument(t2) {
    return this.version = t2, this.documentType = 2, this.data = De.empty(), this.documentState = 0, this;
  }
  convertToUnknownDocument(t2) {
    return this.version = t2, this.documentType = 3, this.data = De.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this.version = ct.min(), this;
  }
  setReadTime(t2) {
    return this.readTime = t2, this;
  }
  get hasLocalMutations() {
    return this.documentState === 1;
  }
  get hasCommittedMutations() {
    return this.documentState === 2;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return this.documentType !== 0;
  }
  isFoundDocument() {
    return this.documentType === 1;
  }
  isNoDocument() {
    return this.documentType === 2;
  }
  isUnknownDocument() {
    return this.documentType === 3;
  }
  isEqual(t2) {
    return t2 instanceof xe && this.key.isEqual(t2.key) && this.version.isEqual(t2.version) && this.documentType === t2.documentType && this.documentState === t2.documentState && this.data.isEqual(t2.data);
  }
  mutableCopy() {
    return new xe(this.key, this.documentType, this.version, this.readTime, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
};
var Ne = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
    this.path = t2, this.collectionGroup = e, this.orderBy = n, this.filters = s, this.limit = i, this.startAt = r, this.endAt = o, this.ut = null;
  }
};
function ke(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
  return new Ne(t2, e, n, s, i, r, o);
}
function Oe(t2) {
  const e = K2(t2);
  if (e.ut === null) {
    let t3 = e.path.canonicalString();
    e.collectionGroup !== null && (t3 += "|cg:" + e.collectionGroup), t3 += "|f:", t3 += e.filters.map((t4) => {
      return (e2 = t4).field.canonicalString() + e2.op.toString() + me(e2.value);
      var e2;
    }).join(","), t3 += "|ob:", t3 += e.orderBy.map((t4) => function(t5) {
      return t5.field.canonicalString() + t5.dir;
    }(t4)).join(","), oe(e.limit) || (t3 += "|l:", t3 += e.limit), e.startAt && (t3 += "|lb:", t3 += e.startAt.inclusive ? "b:" : "a:", t3 += e.startAt.position.map((t4) => me(t4)).join(",")), e.endAt && (t3 += "|ub:", t3 += e.endAt.inclusive ? "a:" : "b:", t3 += e.endAt.position.map((t4) => me(t4)).join(",")), e.ut = t3;
  }
  return e.ut;
}
function Me(t2) {
  let e = t2.path.canonicalString();
  return t2.collectionGroup !== null && (e += " collectionGroup=" + t2.collectionGroup), t2.filters.length > 0 && (e += `, filters: [${t2.filters.map((t3) => {
    return `${(e2 = t3).field.canonicalString()} ${e2.op} ${me(e2.value)}`;
    var e2;
  }).join(", ")}]`), oe(t2.limit) || (e += ", limit: " + t2.limit), t2.orderBy.length > 0 && (e += `, orderBy: [${t2.orderBy.map((t3) => function(t4) {
    return `${t4.field.canonicalString()} (${t4.dir})`;
  }(t3)).join(", ")}]`), t2.startAt && (e += ", startAt: ", e += t2.startAt.inclusive ? "b:" : "a:", e += t2.startAt.position.map((t3) => me(t3)).join(",")), t2.endAt && (e += ", endAt: ", e += t2.endAt.inclusive ? "a:" : "b:", e += t2.endAt.position.map((t3) => me(t3)).join(",")), `Target(${e})`;
}
function Fe(t2, e) {
  if (t2.limit !== e.limit)
    return false;
  if (t2.orderBy.length !== e.orderBy.length)
    return false;
  for (let n2 = 0; n2 < t2.orderBy.length; n2++)
    if (!Ze(t2.orderBy[n2], e.orderBy[n2]))
      return false;
  if (t2.filters.length !== e.filters.length)
    return false;
  for (let i = 0; i < t2.filters.length; i++)
    if (n = t2.filters[i], s = e.filters[i], n.op !== s.op || !n.field.isEqual(s.field) || !fe(n.value, s.value))
      return false;
  var n, s;
  return t2.collectionGroup === e.collectionGroup && (!!t2.path.isEqual(e.path) && (!!en(t2.startAt, e.startAt) && en(t2.endAt, e.endAt)));
}
function $e(t2) {
  return dt.isDocumentKey(t2.path) && t2.collectionGroup === null && t2.filters.length === 0;
}
function Be(t2, e) {
  return t2.filters.filter((t3) => t3 instanceof qe && t3.field.isEqual(e));
}
function Le(t2, e, n) {
  let s = he, i = true;
  for (const n2 of Be(t2, e)) {
    let t3 = he, e2 = true;
    switch (n2.op) {
      case "<":
      case "<=":
        t3 = Pe(n2.value);
        break;
      case "==":
      case "in":
      case ">=":
        t3 = n2.value;
        break;
      case ">":
        t3 = n2.value, e2 = false;
        break;
      case "!=":
      case "not-in":
        t3 = he;
    }
    Ve({
      value: s,
      inclusive: i
    }, {
      value: t3,
      inclusive: e2
    }) < 0 && (s = t3, i = e2);
  }
  if (n !== null)
    for (let r = 0; r < t2.orderBy.length; ++r) {
      if (t2.orderBy[r].field.isEqual(e)) {
        const t3 = n.position[r];
        Ve({
          value: s,
          inclusive: i
        }, {
          value: t3,
          inclusive: n.inclusive
        }) < 0 && (s = t3, i = n.inclusive);
        break;
      }
    }
  return {
    value: s,
    inclusive: i
  };
}
function Ue(t2, e, n) {
  let s = ae, i = true;
  for (const n2 of Be(t2, e)) {
    let t3 = ae, e2 = true;
    switch (n2.op) {
      case ">=":
      case ">":
        t3 = ve(n2.value), e2 = false;
        break;
      case "==":
      case "in":
      case "<=":
        t3 = n2.value;
        break;
      case "<":
        t3 = n2.value, e2 = false;
        break;
      case "!=":
      case "not-in":
        t3 = ae;
    }
    Se({
      value: s,
      inclusive: i
    }, {
      value: t3,
      inclusive: e2
    }) > 0 && (s = t3, i = e2);
  }
  if (n !== null)
    for (let r = 0; r < t2.orderBy.length; ++r) {
      if (t2.orderBy[r].field.isEqual(e)) {
        const t3 = n.position[r];
        Se({
          value: s,
          inclusive: i
        }, {
          value: t3,
          inclusive: n.inclusive
        }) > 0 && (s = t3, i = n.inclusive);
        break;
      }
    }
  return {
    value: s,
    inclusive: i
  };
}
var qe = class extends class {
} {
  constructor(t2, e, n) {
    super(), this.field = t2, this.op = e, this.value = n;
  }
  static create(t2, e, n) {
    return t2.isKeyField() ? e === "in" || e === "not-in" ? this.ct(t2, e, n) : new Ke(t2, e, n) : e === "array-contains" ? new We(t2, n) : e === "in" ? new ze(t2, n) : e === "not-in" ? new He(t2, n) : e === "array-contains-any" ? new Je(t2, n) : new qe(t2, e, n);
  }
  static ct(t2, e, n) {
    return e === "in" ? new Ge(t2, n) : new Qe(t2, n);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return this.op === "!=" ? e !== null && this.at(_e(e, this.value)) : e !== null && le(this.value) === le(e) && this.at(_e(e, this.value));
  }
  at(t2) {
    switch (this.op) {
      case "<":
        return t2 < 0;
      case "<=":
        return t2 <= 0;
      case "==":
        return t2 === 0;
      case "!=":
        return t2 !== 0;
      case ">":
        return t2 > 0;
      case ">=":
        return t2 >= 0;
      default:
        return L2();
    }
  }
  ht() {
    return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0;
  }
};
var Ke = class extends qe {
  constructor(t2, e, n) {
    super(t2, e, n), this.key = dt.fromName(n.referenceValue);
  }
  matches(t2) {
    const e = dt.comparator(t2.key, this.key);
    return this.at(e);
  }
};
var Ge = class extends qe {
  constructor(t2, e) {
    super(t2, "in", e), this.keys = je("in", e);
  }
  matches(t2) {
    return this.keys.some((e) => e.isEqual(t2.key));
  }
};
var Qe = class extends qe {
  constructor(t2, e) {
    super(t2, "not-in", e), this.keys = je("not-in", e);
  }
  matches(t2) {
    return !this.keys.some((e) => e.isEqual(t2.key));
  }
};
function je(t2, e) {
  var n;
  return (((n = e.arrayValue) === null || n === void 0 ? void 0 : n.values) || []).map((t3) => dt.fromName(t3.referenceValue));
}
var We = class extends qe {
  constructor(t2, e) {
    super(t2, "array-contains", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return Ie(e) && de(e.arrayValue, this.value);
  }
};
var ze = class extends qe {
  constructor(t2, e) {
    super(t2, "in", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return e !== null && de(this.value.arrayValue, e);
  }
};
var He = class extends qe {
  constructor(t2, e) {
    super(t2, "not-in", e);
  }
  matches(t2) {
    if (de(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    }))
      return false;
    const e = t2.data.field(this.field);
    return e !== null && !de(this.value.arrayValue, e);
  }
};
var Je = class extends qe {
  constructor(t2, e) {
    super(t2, "array-contains-any", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return !(!Ie(e) || !e.arrayValue.values) && e.arrayValue.values.some((t3) => de(this.value.arrayValue, t3));
  }
};
var Ye = class {
  constructor(t2, e) {
    this.position = t2, this.inclusive = e;
  }
};
var Xe = class {
  constructor(t2, e = "asc") {
    this.field = t2, this.dir = e;
  }
};
function Ze(t2, e) {
  return t2.dir === e.dir && t2.field.isEqual(e.field);
}
function tn(t2, e, n) {
  let s = 0;
  for (let i = 0; i < t2.position.length; i++) {
    const r = e[i], o = t2.position[i];
    if (r.field.isKeyField())
      s = dt.comparator(dt.fromName(o.referenceValue), n.key);
    else {
      s = _e(o, n.data.field(r.field));
    }
    if (r.dir === "desc" && (s *= -1), s !== 0)
      break;
  }
  return s;
}
function en(t2, e) {
  if (t2 === null)
    return e === null;
  if (e === null)
    return false;
  if (t2.inclusive !== e.inclusive || t2.position.length !== e.position.length)
    return false;
  for (let n = 0; n < t2.position.length; n++) {
    if (!fe(t2.position[n], e.position[n]))
      return false;
  }
  return true;
}
var nn = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = "F", o = null, u = null) {
    this.path = t2, this.collectionGroup = e, this.explicitOrderBy = n, this.filters = s, this.limit = i, this.limitType = r, this.startAt = o, this.endAt = u, this.lt = null, this.ft = null, this.startAt, this.endAt;
  }
};
function sn(t2, e, n, s, i, r, o, u) {
  return new nn(t2, e, n, s, i, r, o, u);
}
function rn(t2) {
  return new nn(t2);
}
function on(t2) {
  return t2.filters.length === 0 && t2.limit === null && t2.startAt == null && t2.endAt == null && (t2.explicitOrderBy.length === 0 || t2.explicitOrderBy.length === 1 && t2.explicitOrderBy[0].field.isKeyField());
}
function un(t2) {
  return t2.explicitOrderBy.length > 0 ? t2.explicitOrderBy[0].field : null;
}
function cn(t2) {
  for (const e of t2.filters)
    if (e.ht())
      return e.field;
  return null;
}
function an(t2) {
  return t2.collectionGroup !== null;
}
function hn(t2) {
  const e = K2(t2);
  if (e.lt === null) {
    e.lt = [];
    const t3 = cn(e), n = un(e);
    if (t3 !== null && n === null)
      t3.isKeyField() || e.lt.push(new Xe(t3)), e.lt.push(new Xe(ft.keyField(), "asc"));
    else {
      let t4 = false;
      for (const n2 of e.explicitOrderBy)
        e.lt.push(n2), n2.field.isKeyField() && (t4 = true);
      if (!t4) {
        const t5 = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        e.lt.push(new Xe(ft.keyField(), t5));
      }
    }
  }
  return e.lt;
}
function ln(t2) {
  const e = K2(t2);
  if (!e.ft)
    if (e.limitType === "F")
      e.ft = ke(e.path, e.collectionGroup, hn(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      const t3 = [];
      for (const n2 of hn(e)) {
        const e2 = n2.dir === "desc" ? "asc" : "desc";
        t3.push(new Xe(n2.field, e2));
      }
      const n = e.endAt ? new Ye(e.endAt.position, e.endAt.inclusive) : null, s = e.startAt ? new Ye(e.startAt.position, e.startAt.inclusive) : null;
      e.ft = ke(e.path, e.collectionGroup, t3, e.filters, e.limit, n, s);
    }
  return e.ft;
}
function fn(t2, e, n) {
  return new nn(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), e, n, t2.startAt, t2.endAt);
}
function dn(t2, e) {
  return Fe(ln(t2), ln(e)) && t2.limitType === e.limitType;
}
function _n(t2) {
  return `${Oe(ln(t2))}|lt:${t2.limitType}`;
}
function wn(t2) {
  return `Query(target=${Me(ln(t2))}; limitType=${t2.limitType})`;
}
function mn(t2, e) {
  return e.isFoundDocument() && function(t3, e2) {
    const n = e2.key.path;
    return t3.collectionGroup !== null ? e2.key.hasCollectionId(t3.collectionGroup) && t3.path.isPrefixOf(n) : dt.isDocumentKey(t3.path) ? t3.path.isEqual(n) : t3.path.isImmediateParentOf(n);
  }(t2, e) && function(t3, e2) {
    for (const n of t3.explicitOrderBy)
      if (!n.field.isKeyField() && e2.data.field(n.field) === null)
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    for (const n of t3.filters)
      if (!n.matches(e2))
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    if (t3.startAt && !function(t4, e3, n) {
      const s = tn(t4, e3, n);
      return t4.inclusive ? s <= 0 : s < 0;
    }(t3.startAt, hn(t3), e2))
      return false;
    if (t3.endAt && !function(t4, e3, n) {
      const s = tn(t4, e3, n);
      return t4.inclusive ? s >= 0 : s > 0;
    }(t3.endAt, hn(t3), e2))
      return false;
    return true;
  }(t2, e);
}
function gn(t2) {
  return t2.collectionGroup || (t2.path.length % 2 == 1 ? t2.path.lastSegment() : t2.path.get(t2.path.length - 2));
}
function yn(t2) {
  return (e, n) => {
    let s = false;
    for (const i of hn(t2)) {
      const t3 = pn(i, e, n);
      if (t3 !== 0)
        return t3;
      s = s || i.field.isKeyField();
    }
    return 0;
  };
}
function pn(t2, e, n) {
  const s = t2.field.isKeyField() ? dt.comparator(e.key, n.key) : function(t3, e2, n2) {
    const s2 = e2.data.field(t3), i = n2.data.field(t3);
    return s2 !== null && i !== null ? _e(s2, i) : L2();
  }(t2.field, e, n);
  switch (t2.dir) {
    case "asc":
      return s;
    case "desc":
      return -1 * s;
    default:
      return L2();
  }
}
function In(t2, e) {
  if (t2.dt) {
    if (isNaN(e))
      return {
        doubleValue: "NaN"
      };
    if (e === 1 / 0)
      return {
        doubleValue: "Infinity"
      };
    if (e === -1 / 0)
      return {
        doubleValue: "-Infinity"
      };
  }
  return {
    doubleValue: ue(e) ? "-0" : e
  };
}
function Tn(t2) {
  return {
    integerValue: "" + t2
  };
}
function En(t2, e) {
  return ce(e) ? Tn(e) : In(t2, e);
}
var An = class {
  constructor() {
    this._ = void 0;
  }
};
function Rn(t2, e, n) {
  return t2 instanceof vn ? function(t3, e2) {
    const n2 = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: t3.seconds,
            nanos: t3.nanoseconds
          }
        }
      }
    };
    return e2 && (n2.fields.__previous_value__ = e2), {
      mapValue: n2
    };
  }(n, e) : t2 instanceof Vn ? Sn(t2, e) : t2 instanceof Dn ? Cn(t2, e) : function(t3, e2) {
    const n2 = Pn(t3, e2), s = Nn(n2) + Nn(t3._t);
    return pe(n2) && pe(t3._t) ? Tn(s) : In(t3.wt, s);
  }(t2, e);
}
function bn(t2, e, n) {
  return t2 instanceof Vn ? Sn(t2, e) : t2 instanceof Dn ? Cn(t2, e) : n;
}
function Pn(t2, e) {
  return t2 instanceof xn ? pe(n = e) || function(t3) {
    return !!t3 && "doubleValue" in t3;
  }(n) ? e : {
    integerValue: 0
  } : null;
  var n;
}
var vn = class extends An {
};
var Vn = class extends An {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function Sn(t2, e) {
  const n = kn(e);
  for (const e2 of t2.elements)
    n.some((t3) => fe(t3, e2)) || n.push(e2);
  return {
    arrayValue: {
      values: n
    }
  };
}
var Dn = class extends An {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function Cn(t2, e) {
  let n = kn(e);
  for (const e2 of t2.elements)
    n = n.filter((t3) => !fe(t3, e2));
  return {
    arrayValue: {
      values: n
    }
  };
}
var xn = class extends An {
  constructor(t2, e) {
    super(), this.wt = t2, this._t = e;
  }
};
function Nn(t2) {
  return Zt(t2.integerValue || t2.doubleValue);
}
function kn(t2) {
  return Ie(t2) && t2.arrayValue.values ? t2.arrayValue.values.slice() : [];
}
var On = class {
  constructor(t2, e) {
    this.field = t2, this.transform = e;
  }
};
function Mn(t2, e) {
  return t2.field.isEqual(e.field) && function(t3, e2) {
    return t3 instanceof Vn && e2 instanceof Vn || t3 instanceof Dn && e2 instanceof Dn ? rt(t3.elements, e2.elements, fe) : t3 instanceof xn && e2 instanceof xn ? fe(t3._t, e2._t) : t3 instanceof vn && e2 instanceof vn;
  }(t2.transform, e.transform);
}
var Fn = class {
  constructor(t2, e) {
    this.version = t2, this.transformResults = e;
  }
};
var $n = class {
  constructor(t2, e) {
    this.updateTime = t2, this.exists = e;
  }
  static none() {
    return new $n();
  }
  static exists(t2) {
    return new $n(void 0, t2);
  }
  static updateTime(t2) {
    return new $n(t2);
  }
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0;
  }
  isEqual(t2) {
    return this.exists === t2.exists && (this.updateTime ? !!t2.updateTime && this.updateTime.isEqual(t2.updateTime) : !t2.updateTime);
  }
};
function Bn(t2, e) {
  return t2.updateTime !== void 0 ? e.isFoundDocument() && e.version.isEqual(t2.updateTime) : t2.exists === void 0 || t2.exists === e.isFoundDocument();
}
var Ln = class {
};
function Un(t2, e) {
  if (!t2.hasLocalMutations || e && e.fields.length === 0)
    return null;
  if (e === null)
    return t2.isNoDocument() ? new Yn(t2.key, $n.none()) : new jn(t2.key, t2.data, $n.none());
  {
    const n = t2.data, s = De.empty();
    let i = new Qt(ft.comparator);
    for (let t3 of e.fields)
      if (!i.has(t3)) {
        let e2 = n.field(t3);
        e2 === null && t3.length > 1 && (t3 = t3.popLast(), e2 = n.field(t3)), e2 === null ? s.delete(t3) : s.set(t3, e2), i = i.add(t3);
      }
    return new Wn(t2.key, s, new zt(i.toArray()), $n.none());
  }
}
function qn(t2, e, n) {
  t2 instanceof jn ? function(t3, e2, n2) {
    const s = t3.value.clone(), i = Hn(t3.fieldTransforms, e2, n2.transformResults);
    s.setAll(i), e2.convertToFoundDocument(n2.version, s).setHasCommittedMutations();
  }(t2, e, n) : t2 instanceof Wn ? function(t3, e2, n2) {
    if (!Bn(t3.precondition, e2))
      return void e2.convertToUnknownDocument(n2.version);
    const s = Hn(t3.fieldTransforms, e2, n2.transformResults), i = e2.data;
    i.setAll(zn(t3)), i.setAll(s), e2.convertToFoundDocument(n2.version, i).setHasCommittedMutations();
  }(t2, e, n) : function(t3, e2, n2) {
    e2.convertToNoDocument(n2.version).setHasCommittedMutations();
  }(0, e, n);
}
function Kn(t2, e, n, s) {
  return t2 instanceof jn ? function(t3, e2, n2, s2) {
    if (!Bn(t3.precondition, e2))
      return n2;
    const i = t3.value.clone(), r = Jn(t3.fieldTransforms, s2, e2);
    return i.setAll(r), e2.convertToFoundDocument(e2.version, i).setHasLocalMutations(), null;
  }(t2, e, n, s) : t2 instanceof Wn ? function(t3, e2, n2, s2) {
    if (!Bn(t3.precondition, e2))
      return n2;
    const i = Jn(t3.fieldTransforms, s2, e2), r = e2.data;
    if (r.setAll(zn(t3)), r.setAll(i), e2.convertToFoundDocument(e2.version, r).setHasLocalMutations(), n2 === null)
      return null;
    return n2.unionWith(t3.fieldMask.fields).unionWith(t3.fieldTransforms.map((t4) => t4.field));
  }(t2, e, n, s) : function(t3, e2, n2) {
    if (Bn(t3.precondition, e2))
      return e2.convertToNoDocument(e2.version).setHasLocalMutations(), null;
    return n2;
  }(t2, e, n);
}
function Gn(t2, e) {
  let n = null;
  for (const s of t2.fieldTransforms) {
    const t3 = e.data.field(s.field), i = Pn(s.transform, t3 || null);
    i != null && (n === null && (n = De.empty()), n.set(s.field, i));
  }
  return n || null;
}
function Qn(t2, e) {
  return t2.type === e.type && (!!t2.key.isEqual(e.key) && (!!t2.precondition.isEqual(e.precondition) && (!!function(t3, e2) {
    return t3 === void 0 && e2 === void 0 || !(!t3 || !e2) && rt(t3, e2, (t4, e3) => Mn(t4, e3));
  }(t2.fieldTransforms, e.fieldTransforms) && (t2.type === 0 ? t2.value.isEqual(e.value) : t2.type !== 1 || t2.data.isEqual(e.data) && t2.fieldMask.isEqual(e.fieldMask)))));
}
var jn = class extends Ln {
  constructor(t2, e, n, s = []) {
    super(), this.key = t2, this.value = e, this.precondition = n, this.fieldTransforms = s, this.type = 0;
  }
  getFieldMask() {
    return null;
  }
};
var Wn = class extends Ln {
  constructor(t2, e, n, s, i = []) {
    super(), this.key = t2, this.data = e, this.fieldMask = n, this.precondition = s, this.fieldTransforms = i, this.type = 1;
  }
  getFieldMask() {
    return this.fieldMask;
  }
};
function zn(t2) {
  const e = /* @__PURE__ */ new Map();
  return t2.fieldMask.fields.forEach((n) => {
    if (!n.isEmpty()) {
      const s = t2.data.field(n);
      e.set(n, s);
    }
  }), e;
}
function Hn(t2, e, n) {
  const s = /* @__PURE__ */ new Map();
  U2(t2.length === n.length);
  for (let i = 0; i < n.length; i++) {
    const r = t2[i], o = r.transform, u = e.data.field(r.field);
    s.set(r.field, bn(o, u, n[i]));
  }
  return s;
}
function Jn(t2, e, n) {
  const s = /* @__PURE__ */ new Map();
  for (const i of t2) {
    const t3 = i.transform, r = n.data.field(i.field);
    s.set(i.field, Rn(t3, r, e));
  }
  return s;
}
var Yn = class extends Ln {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 2, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
};
var Xn = class extends Ln {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 3, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
};
var Zn = class {
  constructor(t2) {
    this.count = t2;
  }
};
var ts;
var es;
function ns(t2) {
  switch (t2) {
    default:
      return L2();
    case G.CANCELLED:
    case G.UNKNOWN:
    case G.DEADLINE_EXCEEDED:
    case G.RESOURCE_EXHAUSTED:
    case G.INTERNAL:
    case G.UNAVAILABLE:
    case G.UNAUTHENTICATED:
      return false;
    case G.INVALID_ARGUMENT:
    case G.NOT_FOUND:
    case G.ALREADY_EXISTS:
    case G.PERMISSION_DENIED:
    case G.FAILED_PRECONDITION:
    case G.ABORTED:
    case G.OUT_OF_RANGE:
    case G.UNIMPLEMENTED:
    case G.DATA_LOSS:
      return true;
  }
}
function ss(t2) {
  if (t2 === void 0)
    return F2("GRPC error has no .code"), G.UNKNOWN;
  switch (t2) {
    case ts.OK:
      return G.OK;
    case ts.CANCELLED:
      return G.CANCELLED;
    case ts.UNKNOWN:
      return G.UNKNOWN;
    case ts.DEADLINE_EXCEEDED:
      return G.DEADLINE_EXCEEDED;
    case ts.RESOURCE_EXHAUSTED:
      return G.RESOURCE_EXHAUSTED;
    case ts.INTERNAL:
      return G.INTERNAL;
    case ts.UNAVAILABLE:
      return G.UNAVAILABLE;
    case ts.UNAUTHENTICATED:
      return G.UNAUTHENTICATED;
    case ts.INVALID_ARGUMENT:
      return G.INVALID_ARGUMENT;
    case ts.NOT_FOUND:
      return G.NOT_FOUND;
    case ts.ALREADY_EXISTS:
      return G.ALREADY_EXISTS;
    case ts.PERMISSION_DENIED:
      return G.PERMISSION_DENIED;
    case ts.FAILED_PRECONDITION:
      return G.FAILED_PRECONDITION;
    case ts.ABORTED:
      return G.ABORTED;
    case ts.OUT_OF_RANGE:
      return G.OUT_OF_RANGE;
    case ts.UNIMPLEMENTED:
      return G.UNIMPLEMENTED;
    case ts.DATA_LOSS:
      return G.DATA_LOSS;
    default:
      return L2();
  }
}
(es = ts || (ts = {}))[es.OK = 0] = "OK", es[es.CANCELLED = 1] = "CANCELLED", es[es.UNKNOWN = 2] = "UNKNOWN", es[es.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", es[es.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", es[es.NOT_FOUND = 5] = "NOT_FOUND", es[es.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", es[es.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", es[es.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", es[es.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", es[es.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", es[es.ABORTED = 10] = "ABORTED", es[es.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", es[es.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", es[es.INTERNAL = 13] = "INTERNAL", es[es.UNAVAILABLE = 14] = "UNAVAILABLE", es[es.DATA_LOSS = 15] = "DATA_LOSS";
var is = class {
  constructor(t2, e) {
    this.mapKeyFn = t2, this.equalsFn = e, this.inner = {}, this.innerSize = 0;
  }
  get(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (n !== void 0) {
      for (const [e2, s] of n)
        if (this.equalsFn(e2, t2))
          return s;
    }
  }
  has(t2) {
    return this.get(t2) !== void 0;
  }
  set(t2, e) {
    const n = this.mapKeyFn(t2), s = this.inner[n];
    if (s === void 0)
      return this.inner[n] = [[t2, e]], void this.innerSize++;
    for (let n2 = 0; n2 < s.length; n2++)
      if (this.equalsFn(s[n2][0], t2))
        return void (s[n2] = [t2, e]);
    s.push([t2, e]), this.innerSize++;
  }
  delete(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (n === void 0)
      return false;
    for (let s = 0; s < n.length; s++)
      if (this.equalsFn(n[s][0], t2))
        return n.length === 1 ? delete this.inner[e] : n.splice(s, 1), this.innerSize--, true;
    return false;
  }
  forEach(t2) {
    Lt(this.inner, (e, n) => {
      for (const [e2, s] of n)
        t2(e2, s);
    });
  }
  isEmpty() {
    return Ut(this.inner);
  }
  size() {
    return this.innerSize;
  }
};
var rs = new qt(dt.comparator);
function os() {
  return rs;
}
var us = new qt(dt.comparator);
function cs(...t2) {
  let e = us;
  for (const n of t2)
    e = e.insert(n.key, n);
  return e;
}
function as(t2) {
  let e = us;
  return t2.forEach((t3, n) => e = e.insert(t3, n.overlayedDocument)), e;
}
function hs() {
  return fs();
}
function ls() {
  return fs();
}
function fs() {
  return new is((t2) => t2.toString(), (t2, e) => t2.isEqual(e));
}
var ds = new qt(dt.comparator);
var _s = new Qt(dt.comparator);
function ws(...t2) {
  let e = _s;
  for (const n of t2)
    e = e.add(n);
  return e;
}
var ms = new Qt(it);
function gs() {
  return ms;
}
var ys = class {
  constructor(t2, e, n, s, i) {
    this.snapshotVersion = t2, this.targetChanges = e, this.targetMismatches = n, this.documentUpdates = s, this.resolvedLimboDocuments = i;
  }
  static createSynthesizedRemoteEventForCurrentChange(t2, e) {
    const n = /* @__PURE__ */ new Map();
    return n.set(t2, ps.createSynthesizedTargetChangeForCurrentChange(t2, e)), new ys(ct.min(), n, gs(), os(), ws());
  }
};
var ps = class {
  constructor(t2, e, n, s, i) {
    this.resumeToken = t2, this.current = e, this.addedDocuments = n, this.modifiedDocuments = s, this.removedDocuments = i;
  }
  static createSynthesizedTargetChangeForCurrentChange(t2, e) {
    return new ps(Jt.EMPTY_BYTE_STRING, e, ws(), ws(), ws());
  }
};
var Is = class {
  constructor(t2, e, n, s) {
    this.gt = t2, this.removedTargetIds = e, this.key = n, this.yt = s;
  }
};
var Ts = class {
  constructor(t2, e) {
    this.targetId = t2, this.It = e;
  }
};
var Es = class {
  constructor(t2, e, n = Jt.EMPTY_BYTE_STRING, s = null) {
    this.state = t2, this.targetIds = e, this.resumeToken = n, this.cause = s;
  }
};
var As = class {
  constructor() {
    this.Tt = 0, this.Et = Ps(), this.At = Jt.EMPTY_BYTE_STRING, this.Rt = false, this.bt = true;
  }
  get current() {
    return this.Rt;
  }
  get resumeToken() {
    return this.At;
  }
  get Pt() {
    return this.Tt !== 0;
  }
  get vt() {
    return this.bt;
  }
  Vt(t2) {
    t2.approximateByteSize() > 0 && (this.bt = true, this.At = t2);
  }
  St() {
    let t2 = ws(), e = ws(), n = ws();
    return this.Et.forEach((s, i) => {
      switch (i) {
        case 0:
          t2 = t2.add(s);
          break;
        case 2:
          e = e.add(s);
          break;
        case 1:
          n = n.add(s);
          break;
        default:
          L2();
      }
    }), new ps(this.At, this.Rt, t2, e, n);
  }
  Dt() {
    this.bt = false, this.Et = Ps();
  }
  Ct(t2, e) {
    this.bt = true, this.Et = this.Et.insert(t2, e);
  }
  xt(t2) {
    this.bt = true, this.Et = this.Et.remove(t2);
  }
  Nt() {
    this.Tt += 1;
  }
  kt() {
    this.Tt -= 1;
  }
  Ot() {
    this.bt = true, this.Rt = true;
  }
};
var Rs = class {
  constructor(t2) {
    this.Mt = t2, this.Ft = /* @__PURE__ */ new Map(), this.$t = os(), this.Bt = bs(), this.Lt = new Qt(it);
  }
  Ut(t2) {
    for (const e of t2.gt)
      t2.yt && t2.yt.isFoundDocument() ? this.qt(e, t2.yt) : this.Kt(e, t2.key, t2.yt);
    for (const e of t2.removedTargetIds)
      this.Kt(e, t2.key, t2.yt);
  }
  Gt(t2) {
    this.forEachTarget(t2, (e) => {
      const n = this.Qt(e);
      switch (t2.state) {
        case 0:
          this.jt(e) && n.Vt(t2.resumeToken);
          break;
        case 1:
          n.kt(), n.Pt || n.Dt(), n.Vt(t2.resumeToken);
          break;
        case 2:
          n.kt(), n.Pt || this.removeTarget(e);
          break;
        case 3:
          this.jt(e) && (n.Ot(), n.Vt(t2.resumeToken));
          break;
        case 4:
          this.jt(e) && (this.Wt(e), n.Vt(t2.resumeToken));
          break;
        default:
          L2();
      }
    });
  }
  forEachTarget(t2, e) {
    t2.targetIds.length > 0 ? t2.targetIds.forEach(e) : this.Ft.forEach((t3, n) => {
      this.jt(n) && e(n);
    });
  }
  zt(t2) {
    const e = t2.targetId, n = t2.It.count, s = this.Ht(e);
    if (s) {
      const t3 = s.target;
      if ($e(t3))
        if (n === 0) {
          const n2 = new dt(t3.path);
          this.Kt(e, n2, xe.newNoDocument(n2, ct.min()));
        } else
          U2(n === 1);
      else {
        this.Jt(e) !== n && (this.Wt(e), this.Lt = this.Lt.add(e));
      }
    }
  }
  Yt(t2) {
    const e = /* @__PURE__ */ new Map();
    this.Ft.forEach((n2, s2) => {
      const i = this.Ht(s2);
      if (i) {
        if (n2.current && $e(i.target)) {
          const e2 = new dt(i.target.path);
          this.$t.get(e2) !== null || this.Xt(s2, e2) || this.Kt(s2, e2, xe.newNoDocument(e2, t2));
        }
        n2.vt && (e.set(s2, n2.St()), n2.Dt());
      }
    });
    let n = ws();
    this.Bt.forEach((t3, e2) => {
      let s2 = true;
      e2.forEachWhile((t4) => {
        const e3 = this.Ht(t4);
        return !e3 || e3.purpose === 2 || (s2 = false, false);
      }), s2 && (n = n.add(t3));
    }), this.$t.forEach((e2, n2) => n2.setReadTime(t2));
    const s = new ys(t2, e, this.Lt, this.$t, n);
    return this.$t = os(), this.Bt = bs(), this.Lt = new Qt(it), s;
  }
  qt(t2, e) {
    if (!this.jt(t2))
      return;
    const n = this.Xt(t2, e.key) ? 2 : 0;
    this.Qt(t2).Ct(e.key, n), this.$t = this.$t.insert(e.key, e), this.Bt = this.Bt.insert(e.key, this.Zt(e.key).add(t2));
  }
  Kt(t2, e, n) {
    if (!this.jt(t2))
      return;
    const s = this.Qt(t2);
    this.Xt(t2, e) ? s.Ct(e, 1) : s.xt(e), this.Bt = this.Bt.insert(e, this.Zt(e).delete(t2)), n && (this.$t = this.$t.insert(e, n));
  }
  removeTarget(t2) {
    this.Ft.delete(t2);
  }
  Jt(t2) {
    const e = this.Qt(t2).St();
    return this.Mt.getRemoteKeysForTarget(t2).size + e.addedDocuments.size - e.removedDocuments.size;
  }
  Nt(t2) {
    this.Qt(t2).Nt();
  }
  Qt(t2) {
    let e = this.Ft.get(t2);
    return e || (e = new As(), this.Ft.set(t2, e)), e;
  }
  Zt(t2) {
    let e = this.Bt.get(t2);
    return e || (e = new Qt(it), this.Bt = this.Bt.insert(t2, e)), e;
  }
  jt(t2) {
    const e = this.Ht(t2) !== null;
    return e || M2("WatchChangeAggregator", "Detected inactive target", t2), e;
  }
  Ht(t2) {
    const e = this.Ft.get(t2);
    return e && e.Pt ? null : this.Mt.te(t2);
  }
  Wt(t2) {
    this.Ft.set(t2, new As());
    this.Mt.getRemoteKeysForTarget(t2).forEach((e) => {
      this.Kt(t2, e, null);
    });
  }
  Xt(t2, e) {
    return this.Mt.getRemoteKeysForTarget(t2).has(e);
  }
};
function bs() {
  return new qt(dt.comparator);
}
function Ps() {
  return new qt(dt.comparator);
}
var vs = (() => {
  const t2 = {
    asc: "ASCENDING",
    desc: "DESCENDING"
  };
  return t2;
})();
var Vs = (() => {
  const t2 = {
    "<": "LESS_THAN",
    "<=": "LESS_THAN_OR_EQUAL",
    ">": "GREATER_THAN",
    ">=": "GREATER_THAN_OR_EQUAL",
    "==": "EQUAL",
    "!=": "NOT_EQUAL",
    "array-contains": "ARRAY_CONTAINS",
    in: "IN",
    "not-in": "NOT_IN",
    "array-contains-any": "ARRAY_CONTAINS_ANY"
  };
  return t2;
})();
var Ss = class {
  constructor(t2, e) {
    this.databaseId = t2, this.dt = e;
  }
};
function Ds(t2, e) {
  if (t2.dt) {
    return `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z`;
  }
  return {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function Cs(t2, e) {
  return t2.dt ? e.toBase64() : e.toUint8Array();
}
function xs(t2, e) {
  return Ds(t2, e.toTimestamp());
}
function Ns(t2) {
  return U2(!!t2), ct.fromTimestamp(function(t3) {
    const e = Xt(t3);
    return new ut(e.seconds, e.nanos);
  }(t2));
}
function ks(t2, e) {
  return function(t3) {
    return new ht(["projects", t3.projectId, "databases", t3.database]);
  }(t2).child("documents").child(e).canonicalString();
}
function Os(t2) {
  const e = ht.fromString(t2);
  return U2(ui(e)), e;
}
function Ms(t2, e) {
  return ks(t2.databaseId, e.path);
}
function Fs(t2, e) {
  const n = Os(e);
  if (n.get(1) !== t2.databaseId.projectId)
    throw new Q2(G.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n.get(1) + " vs " + t2.databaseId.projectId);
  if (n.get(3) !== t2.databaseId.database)
    throw new Q2(G.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n.get(3) + " vs " + t2.databaseId.database);
  return new dt(Us(n));
}
function $s(t2, e) {
  return ks(t2.databaseId, e);
}
function Bs(t2) {
  const e = Os(t2);
  return e.length === 4 ? ht.emptyPath() : Us(e);
}
function Ls(t2) {
  return new ht(["projects", t2.databaseId.projectId, "databases", t2.databaseId.database]).canonicalString();
}
function Us(t2) {
  return U2(t2.length > 4 && t2.get(4) === "documents"), t2.popFirst(5);
}
function qs(t2, e, n) {
  return {
    name: Ms(t2, e),
    fields: n.value.mapValue.fields
  };
}
function Ks(t2, e, n) {
  const s = Fs(t2, e.name), i = Ns(e.updateTime), r = new De({
    mapValue: {
      fields: e.fields
    }
  }), o = xe.newFoundDocument(s, i, r);
  return n && o.setHasCommittedMutations(), n ? o.setHasCommittedMutations() : o;
}
function Gs(t2, e) {
  return "found" in e ? function(t3, e2) {
    U2(!!e2.found), e2.found.name, e2.found.updateTime;
    const n = Fs(t3, e2.found.name), s = Ns(e2.found.updateTime), i = new De({
      mapValue: {
        fields: e2.found.fields
      }
    });
    return xe.newFoundDocument(n, s, i);
  }(t2, e) : "missing" in e ? function(t3, e2) {
    U2(!!e2.missing), U2(!!e2.readTime);
    const n = Fs(t3, e2.missing), s = Ns(e2.readTime);
    return xe.newNoDocument(n, s);
  }(t2, e) : L2();
}
function Qs(t2, e) {
  let n;
  if ("targetChange" in e) {
    e.targetChange;
    const s = function(t3) {
      return t3 === "NO_CHANGE" ? 0 : t3 === "ADD" ? 1 : t3 === "REMOVE" ? 2 : t3 === "CURRENT" ? 3 : t3 === "RESET" ? 4 : L2();
    }(e.targetChange.targetChangeType || "NO_CHANGE"), i = e.targetChange.targetIds || [], r = function(t3, e2) {
      return t3.dt ? (U2(e2 === void 0 || typeof e2 == "string"), Jt.fromBase64String(e2 || "")) : (U2(e2 === void 0 || e2 instanceof Uint8Array), Jt.fromUint8Array(e2 || new Uint8Array()));
    }(t2, e.targetChange.resumeToken), o = e.targetChange.cause, u = o && function(t3) {
      const e2 = t3.code === void 0 ? G.UNKNOWN : ss(t3.code);
      return new Q2(e2, t3.message || "");
    }(o);
    n = new Es(s, i, r, u || null);
  } else if ("documentChange" in e) {
    e.documentChange;
    const s = e.documentChange;
    s.document, s.document.name, s.document.updateTime;
    const i = Fs(t2, s.document.name), r = Ns(s.document.updateTime), o = new De({
      mapValue: {
        fields: s.document.fields
      }
    }), u = xe.newFoundDocument(i, r, o), c = s.targetIds || [], a = s.removedTargetIds || [];
    n = new Is(c, a, u.key, u);
  } else if ("documentDelete" in e) {
    e.documentDelete;
    const s = e.documentDelete;
    s.document;
    const i = Fs(t2, s.document), r = s.readTime ? Ns(s.readTime) : ct.min(), o = xe.newNoDocument(i, r), u = s.removedTargetIds || [];
    n = new Is([], u, o.key, o);
  } else if ("documentRemove" in e) {
    e.documentRemove;
    const s = e.documentRemove;
    s.document;
    const i = Fs(t2, s.document), r = s.removedTargetIds || [];
    n = new Is([], r, i, null);
  } else {
    if (!("filter" in e))
      return L2();
    {
      e.filter;
      const t3 = e.filter;
      t3.targetId;
      const s = t3.count || 0, i = new Zn(s), r = t3.targetId;
      n = new Ts(r, i);
    }
  }
  return n;
}
function js(t2, e) {
  let n;
  if (e instanceof jn)
    n = {
      update: qs(t2, e.key, e.value)
    };
  else if (e instanceof Yn)
    n = {
      delete: Ms(t2, e.key)
    };
  else if (e instanceof Wn)
    n = {
      update: qs(t2, e.key, e.data),
      updateMask: oi(e.fieldMask)
    };
  else {
    if (!(e instanceof Xn))
      return L2();
    n = {
      verify: Ms(t2, e.key)
    };
  }
  return e.fieldTransforms.length > 0 && (n.updateTransforms = e.fieldTransforms.map((t3) => function(t4, e2) {
    const n2 = e2.transform;
    if (n2 instanceof vn)
      return {
        fieldPath: e2.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (n2 instanceof Vn)
      return {
        fieldPath: e2.field.canonicalString(),
        appendMissingElements: {
          values: n2.elements
        }
      };
    if (n2 instanceof Dn)
      return {
        fieldPath: e2.field.canonicalString(),
        removeAllFromArray: {
          values: n2.elements
        }
      };
    if (n2 instanceof xn)
      return {
        fieldPath: e2.field.canonicalString(),
        increment: n2._t
      };
    throw L2();
  }(0, t3))), e.precondition.isNone || (n.currentDocument = function(t3, e2) {
    return e2.updateTime !== void 0 ? {
      updateTime: xs(t3, e2.updateTime)
    } : e2.exists !== void 0 ? {
      exists: e2.exists
    } : L2();
  }(t2, e.precondition)), n;
}
function Ws(t2, e) {
  const n = e.currentDocument ? function(t3) {
    return t3.updateTime !== void 0 ? $n.updateTime(Ns(t3.updateTime)) : t3.exists !== void 0 ? $n.exists(t3.exists) : $n.none();
  }(e.currentDocument) : $n.none(), s = e.updateTransforms ? e.updateTransforms.map((e2) => function(t3, e3) {
    let n2 = null;
    if ("setToServerValue" in e3)
      U2(e3.setToServerValue === "REQUEST_TIME"), n2 = new vn();
    else if ("appendMissingElements" in e3) {
      const t4 = e3.appendMissingElements.values || [];
      n2 = new Vn(t4);
    } else if ("removeAllFromArray" in e3) {
      const t4 = e3.removeAllFromArray.values || [];
      n2 = new Dn(t4);
    } else
      "increment" in e3 ? n2 = new xn(t3, e3.increment) : L2();
    const s2 = ft.fromServerFormat(e3.fieldPath);
    return new On(s2, n2);
  }(t2, e2)) : [];
  if (e.update) {
    e.update.name;
    const i = Fs(t2, e.update.name), r = new De({
      mapValue: {
        fields: e.update.fields
      }
    });
    if (e.updateMask) {
      const t3 = function(t4) {
        const e2 = t4.fieldPaths || [];
        return new zt(e2.map((t5) => ft.fromServerFormat(t5)));
      }(e.updateMask);
      return new Wn(i, r, t3, n, s);
    }
    return new jn(i, r, n, s);
  }
  if (e.delete) {
    const s2 = Fs(t2, e.delete);
    return new Yn(s2, n);
  }
  if (e.verify) {
    const s2 = Fs(t2, e.verify);
    return new Xn(s2, n);
  }
  return L2();
}
function zs(t2, e) {
  return t2 && t2.length > 0 ? (U2(e !== void 0), t2.map((t3) => function(t4, e2) {
    let n = t4.updateTime ? Ns(t4.updateTime) : Ns(e2);
    return n.isEqual(ct.min()) && (n = Ns(e2)), new Fn(n, t4.transformResults || []);
  }(t3, e))) : [];
}
function Hs(t2, e) {
  return {
    documents: [$s(t2, e.path)]
  };
}
function Js(t2, e) {
  const n = {
    structuredQuery: {}
  }, s = e.path;
  e.collectionGroup !== null ? (n.parent = $s(t2, s), n.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: true
  }]) : (n.parent = $s(t2, s.popLast()), n.structuredQuery.from = [{
    collectionId: s.lastSegment()
  }]);
  const i = function(t3) {
    if (t3.length === 0)
      return;
    const e2 = t3.map((t4) => function(t5) {
      if (t5.op === "==") {
        if (Ee(t5.value))
          return {
            unaryFilter: {
              field: ni(t5.field),
              op: "IS_NAN"
            }
          };
        if (Te(t5.value))
          return {
            unaryFilter: {
              field: ni(t5.field),
              op: "IS_NULL"
            }
          };
      } else if (t5.op === "!=") {
        if (Ee(t5.value))
          return {
            unaryFilter: {
              field: ni(t5.field),
              op: "IS_NOT_NAN"
            }
          };
        if (Te(t5.value))
          return {
            unaryFilter: {
              field: ni(t5.field),
              op: "IS_NOT_NULL"
            }
          };
      }
      return {
        fieldFilter: {
          field: ni(t5.field),
          op: ei(t5.op),
          value: t5.value
        }
      };
    }(t4));
    if (e2.length === 1)
      return e2[0];
    return {
      compositeFilter: {
        op: "AND",
        filters: e2
      }
    };
  }(e.filters);
  i && (n.structuredQuery.where = i);
  const r = function(t3) {
    if (t3.length === 0)
      return;
    return t3.map((t4) => function(t5) {
      return {
        field: ni(t5.field),
        direction: ti(t5.dir)
      };
    }(t4));
  }(e.orderBy);
  r && (n.structuredQuery.orderBy = r);
  const o = function(t3, e2) {
    return t3.dt || oe(e2) ? e2 : {
      value: e2
    };
  }(t2, e.limit);
  var u;
  return o !== null && (n.structuredQuery.limit = o), e.startAt && (n.structuredQuery.startAt = {
    before: (u = e.startAt).inclusive,
    values: u.position
  }), e.endAt && (n.structuredQuery.endAt = function(t3) {
    return {
      before: !t3.inclusive,
      values: t3.position
    };
  }(e.endAt)), n;
}
function Ys(t2) {
  let e = Bs(t2.parent);
  const n = t2.structuredQuery, s = n.from ? n.from.length : 0;
  let i = null;
  if (s > 0) {
    U2(s === 1);
    const t3 = n.from[0];
    t3.allDescendants ? i = t3.collectionId : e = e.child(t3.collectionId);
  }
  let r = [];
  n.where && (r = Zs(n.where));
  let o = [];
  n.orderBy && (o = n.orderBy.map((t3) => function(t4) {
    return new Xe(si(t4.field), function(t5) {
      switch (t5) {
        case "ASCENDING":
          return "asc";
        case "DESCENDING":
          return "desc";
        default:
          return;
      }
    }(t4.direction));
  }(t3)));
  let u = null;
  n.limit && (u = function(t3) {
    let e2;
    return e2 = typeof t3 == "object" ? t3.value : t3, oe(e2) ? null : e2;
  }(n.limit));
  let c = null;
  n.startAt && (c = function(t3) {
    const e2 = !!t3.before, n2 = t3.values || [];
    return new Ye(n2, e2);
  }(n.startAt));
  let a = null;
  return n.endAt && (a = function(t3) {
    const e2 = !t3.before, n2 = t3.values || [];
    return new Ye(n2, e2);
  }(n.endAt)), sn(e, i, o, r, u, "F", c, a);
}
function Xs(t2, e) {
  const n = function(t3, e2) {
    switch (e2) {
      case 0:
        return null;
      case 1:
        return "existence-filter-mismatch";
      case 2:
        return "limbo-document";
      default:
        return L2();
    }
  }(0, e.purpose);
  return n == null ? null : {
    "goog-listen-tags": n
  };
}
function Zs(t2) {
  return t2 ? t2.unaryFilter !== void 0 ? [ri(t2)] : t2.fieldFilter !== void 0 ? [ii(t2)] : t2.compositeFilter !== void 0 ? t2.compositeFilter.filters.map((t3) => Zs(t3)).reduce((t3, e) => t3.concat(e)) : L2() : [];
}
function ti(t2) {
  return vs[t2];
}
function ei(t2) {
  return Vs[t2];
}
function ni(t2) {
  return {
    fieldPath: t2.canonicalString()
  };
}
function si(t2) {
  return ft.fromServerFormat(t2.fieldPath);
}
function ii(t2) {
  return qe.create(si(t2.fieldFilter.field), function(t3) {
    switch (t3) {
      case "EQUAL":
        return "==";
      case "NOT_EQUAL":
        return "!=";
      case "GREATER_THAN":
        return ">";
      case "GREATER_THAN_OR_EQUAL":
        return ">=";
      case "LESS_THAN":
        return "<";
      case "LESS_THAN_OR_EQUAL":
        return "<=";
      case "ARRAY_CONTAINS":
        return "array-contains";
      case "IN":
        return "in";
      case "NOT_IN":
        return "not-in";
      case "ARRAY_CONTAINS_ANY":
        return "array-contains-any";
      default:
        return L2();
    }
  }(t2.fieldFilter.op), t2.fieldFilter.value);
}
function ri(t2) {
  switch (t2.unaryFilter.op) {
    case "IS_NAN":
      const e = si(t2.unaryFilter.field);
      return qe.create(e, "==", {
        doubleValue: NaN
      });
    case "IS_NULL":
      const n = si(t2.unaryFilter.field);
      return qe.create(n, "==", {
        nullValue: "NULL_VALUE"
      });
    case "IS_NOT_NAN":
      const s = si(t2.unaryFilter.field);
      return qe.create(s, "!=", {
        doubleValue: NaN
      });
    case "IS_NOT_NULL":
      const i = si(t2.unaryFilter.field);
      return qe.create(i, "!=", {
        nullValue: "NULL_VALUE"
      });
    default:
      return L2();
  }
}
function oi(t2) {
  const e = [];
  return t2.fields.forEach((t3) => e.push(t3.canonicalString())), {
    fieldPaths: e
  };
}
function ui(t2) {
  return t2.length >= 4 && t2.get(0) === "projects" && t2.get(2) === "databases";
}
function ci(t2) {
  let e = "";
  for (let n = 0; n < t2.length; n++)
    e.length > 0 && (e = hi(e)), e = ai(t2.get(n), e);
  return hi(e);
}
function ai(t2, e) {
  let n = e;
  const s = t2.length;
  for (let e2 = 0; e2 < s; e2++) {
    const s2 = t2.charAt(e2);
    switch (s2) {
      case "\0":
        n += "";
        break;
      case "":
        n += "";
        break;
      default:
        n += s2;
    }
  }
  return n;
}
function hi(t2) {
  return t2 + "";
}
function li(t2) {
  const e = t2.length;
  if (U2(e >= 2), e === 2)
    return U2(t2.charAt(0) === "" && t2.charAt(1) === ""), ht.emptyPath();
  const n = e - 2, s = [];
  let i = "";
  for (let r = 0; r < e; ) {
    const e2 = t2.indexOf("", r);
    (e2 < 0 || e2 > n) && L2();
    switch (t2.charAt(e2 + 1)) {
      case "":
        const n2 = t2.substring(r, e2);
        let o;
        i.length === 0 ? o = n2 : (i += n2, o = i, i = ""), s.push(o);
        break;
      case "":
        i += t2.substring(r, e2), i += "\0";
        break;
      case "":
        i += t2.substring(r, e2 + 1);
        break;
      default:
        L2();
    }
    r = e2 + 2;
  }
  return new ht(s);
}
var fi = ["userId", "batchId"];
function di(t2, e) {
  return [t2, ci(e)];
}
function _i(t2, e, n) {
  return [t2, ci(e), n];
}
var wi = {};
var mi = ["prefixPath", "collectionGroup", "readTime", "documentId"];
var gi = ["prefixPath", "collectionGroup", "documentId"];
var yi = ["collectionGroup", "readTime", "prefixPath", "documentId"];
var pi = ["canonicalId", "targetId"];
var Ii = ["targetId", "path"];
var Ti = ["path", "targetId"];
var Ei = ["collectionId", "parent"];
var Ai = ["indexId", "uid"];
var Ri = ["uid", "sequenceNumber"];
var bi = ["indexId", "uid", "arrayValue", "directionalValue", "orderedDocumentKey", "documentKey"];
var Pi = ["indexId", "uid", "orderedDocumentKey"];
var vi = ["userId", "collectionPath", "documentId"];
var Vi = ["userId", "collectionPath", "largestBatchId"];
var Si = ["userId", "collectionGroup", "largestBatchId"];
var Di = [...[...[...[...["mutationQueues", "mutations", "documentMutations", "remoteDocuments", "targets", "owner", "targetGlobal", "targetDocuments"], "clientMetadata"], "remoteDocumentGlobal"], "collectionParents"], "bundles", "namedQueries"];
var Ci = [...Di, "documentOverlays"];
var xi = ["mutationQueues", "mutations", "documentMutations", "remoteDocumentsV14", "targets", "owner", "targetGlobal", "targetDocuments", "clientMetadata", "remoteDocumentGlobal", "collectionParents", "bundles", "namedQueries", "documentOverlays"];
var Ni = xi;
var ki = [...Ni, "indexConfiguration", "indexState", "indexEntries"];
var Oi = class extends Rt {
  constructor(t2, e) {
    super(), this.ee = t2, this.currentSequenceNumber = e;
  }
};
function Mi(t2, e) {
  const n = K2(t2);
  return Vt.N(n.ee, e);
}
var Fi = class {
  constructor(t2, e, n, s) {
    this.batchId = t2, this.localWriteTime = e, this.baseMutations = n, this.mutations = s;
  }
  applyToRemoteDocument(t2, e) {
    const n = e.mutationResults;
    for (let e2 = 0; e2 < this.mutations.length; e2++) {
      const s = this.mutations[e2];
      if (s.key.isEqual(t2.key)) {
        qn(s, t2, n[e2]);
      }
    }
  }
  applyToLocalView(t2, e) {
    for (const n of this.baseMutations)
      n.key.isEqual(t2.key) && (e = Kn(n, t2, e, this.localWriteTime));
    for (const n of this.mutations)
      n.key.isEqual(t2.key) && (e = Kn(n, t2, e, this.localWriteTime));
    return e;
  }
  applyToLocalDocumentSet(t2, e) {
    const n = ls();
    return this.mutations.forEach((s) => {
      const i = t2.get(s.key), r = i.overlayedDocument;
      let o = this.applyToLocalView(r, i.mutatedFields);
      o = e.has(s.key) ? null : o;
      const u = Un(r, o);
      u !== null && n.set(s.key, u), r.isValidDocument() || r.convertToNoDocument(ct.min());
    }), n;
  }
  keys() {
    return this.mutations.reduce((t2, e) => t2.add(e.key), ws());
  }
  isEqual(t2) {
    return this.batchId === t2.batchId && rt(this.mutations, t2.mutations, (t3, e) => Qn(t3, e)) && rt(this.baseMutations, t2.baseMutations, (t3, e) => Qn(t3, e));
  }
};
var $i = class {
  constructor(t2, e, n, s) {
    this.batch = t2, this.commitVersion = e, this.mutationResults = n, this.docVersions = s;
  }
  static from(t2, e, n) {
    U2(t2.mutations.length === n.length);
    let s = ds;
    const i = t2.mutations;
    for (let t3 = 0; t3 < i.length; t3++)
      s = s.insert(i[t3].key, n[t3].version);
    return new $i(t2, e, n, s);
  }
};
var Bi = class {
  constructor(t2, e) {
    this.largestBatchId = t2, this.mutation = e;
  }
  getKey() {
    return this.mutation.key;
  }
  isEqual(t2) {
    return t2 !== null && this.mutation === t2.mutation;
  }
  toString() {
    return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`;
  }
};
var Li = class {
  constructor(t2, e, n, s, i = ct.min(), r = ct.min(), o = Jt.EMPTY_BYTE_STRING) {
    this.target = t2, this.targetId = e, this.purpose = n, this.sequenceNumber = s, this.snapshotVersion = i, this.lastLimboFreeSnapshotVersion = r, this.resumeToken = o;
  }
  withSequenceNumber(t2) {
    return new Li(this.target, this.targetId, this.purpose, t2, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);
  }
  withResumeToken(t2, e) {
    return new Li(this.target, this.targetId, this.purpose, this.sequenceNumber, e, this.lastLimboFreeSnapshotVersion, t2);
  }
  withLastLimboFreeSnapshotVersion(t2) {
    return new Li(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t2, this.resumeToken);
  }
};
var Ui = class {
  constructor(t2) {
    this.ne = t2;
  }
};
function qi(t2, e) {
  let n;
  if (e.document)
    n = Ks(t2.ne, e.document, !!e.hasCommittedMutations);
  else if (e.noDocument) {
    const t3 = dt.fromSegments(e.noDocument.path), s = ji(e.noDocument.readTime);
    n = xe.newNoDocument(t3, s), e.hasCommittedMutations && n.setHasCommittedMutations();
  } else {
    if (!e.unknownDocument)
      return L2();
    {
      const t3 = dt.fromSegments(e.unknownDocument.path), s = ji(e.unknownDocument.version);
      n = xe.newUnknownDocument(t3, s);
    }
  }
  return e.readTime && n.setReadTime(function(t3) {
    const e2 = new ut(t3[0], t3[1]);
    return ct.fromTimestamp(e2);
  }(e.readTime)), n;
}
function Ki(t2, e) {
  const n = e.key, s = {
    prefixPath: n.getCollectionPath().popLast().toArray(),
    collectionGroup: n.collectionGroup,
    documentId: n.path.lastSegment(),
    readTime: Gi(e.readTime),
    hasCommittedMutations: e.hasCommittedMutations
  };
  if (e.isFoundDocument())
    s.document = function(t3, e2) {
      return {
        name: Ms(t3, e2.key),
        fields: e2.data.value.mapValue.fields,
        updateTime: Ds(t3, e2.version.toTimestamp())
      };
    }(t2.ne, e);
  else if (e.isNoDocument())
    s.noDocument = {
      path: n.path.toArray(),
      readTime: Qi(e.version)
    };
  else {
    if (!e.isUnknownDocument())
      return L2();
    s.unknownDocument = {
      path: n.path.toArray(),
      version: Qi(e.version)
    };
  }
  return s;
}
function Gi(t2) {
  const e = t2.toTimestamp();
  return [e.seconds, e.nanoseconds];
}
function Qi(t2) {
  const e = t2.toTimestamp();
  return {
    seconds: e.seconds,
    nanoseconds: e.nanoseconds
  };
}
function ji(t2) {
  const e = new ut(t2.seconds, t2.nanoseconds);
  return ct.fromTimestamp(e);
}
function Wi(t2, e) {
  const n = (e.baseMutations || []).map((e2) => Ws(t2.ne, e2));
  for (let t3 = 0; t3 < e.mutations.length - 1; ++t3) {
    const n2 = e.mutations[t3];
    if (t3 + 1 < e.mutations.length && e.mutations[t3 + 1].transform !== void 0) {
      const s2 = e.mutations[t3 + 1];
      n2.updateTransforms = s2.transform.fieldTransforms, e.mutations.splice(t3 + 1, 1), ++t3;
    }
  }
  const s = e.mutations.map((e2) => Ws(t2.ne, e2)), i = ut.fromMillis(e.localWriteTimeMs);
  return new Fi(e.batchId, i, n, s);
}
function zi(t2) {
  const e = ji(t2.readTime), n = t2.lastLimboFreeSnapshotVersion !== void 0 ? ji(t2.lastLimboFreeSnapshotVersion) : ct.min();
  let s;
  var i;
  return t2.query.documents !== void 0 ? (U2((i = t2.query).documents.length === 1), s = ln(rn(Bs(i.documents[0])))) : s = function(t3) {
    return ln(Ys(t3));
  }(t2.query), new Li(s, t2.targetId, 0, t2.lastListenSequenceNumber, e, n, Jt.fromBase64String(t2.resumeToken));
}
function Hi(t2, e) {
  const n = Qi(e.snapshotVersion), s = Qi(e.lastLimboFreeSnapshotVersion);
  let i;
  i = $e(e.target) ? Hs(t2.ne, e.target) : Js(t2.ne, e.target);
  const r = e.resumeToken.toBase64();
  return {
    targetId: e.targetId,
    canonicalId: Oe(e.target),
    readTime: n,
    resumeToken: r,
    lastListenSequenceNumber: e.sequenceNumber,
    lastLimboFreeSnapshotVersion: s,
    query: i
  };
}
function Ji(t2) {
  const e = Ys({
    parent: t2.parent,
    structuredQuery: t2.structuredQuery
  });
  return t2.limitType === "LAST" ? fn(e, e.limit, "L") : e;
}
function Yi(t2, e) {
  return new Bi(e.largestBatchId, Ws(t2.ne, e.overlayMutation));
}
function Xi(t2, e) {
  const n = e.path.lastSegment();
  return [t2, ci(e.path.popLast()), n];
}
function Zi(t2, e, n, s) {
  return {
    indexId: t2,
    uid: e.uid || "",
    sequenceNumber: n,
    readTime: Qi(s.readTime),
    documentKey: ci(s.documentKey.path),
    largestBatchId: s.largestBatchId
  };
}
var tr = class {
  getBundleMetadata(t2, e) {
    return er(t2).get(e).next((t3) => {
      if (t3)
        return {
          id: (e2 = t3).bundleId,
          createTime: ji(e2.createTime),
          version: e2.version
        };
      var e2;
    });
  }
  saveBundleMetadata(t2, e) {
    return er(t2).put({
      bundleId: (n = e).id,
      createTime: Qi(Ns(n.createTime)),
      version: n.version
    });
    var n;
  }
  getNamedQuery(t2, e) {
    return nr(t2).get(e).next((t3) => {
      if (t3)
        return {
          name: (e2 = t3).name,
          query: Ji(e2.bundledQuery),
          readTime: ji(e2.readTime)
        };
      var e2;
    });
  }
  saveNamedQuery(t2, e) {
    return nr(t2).put(function(t3) {
      return {
        name: t3.name,
        readTime: Qi(Ns(t3.readTime)),
        bundledQuery: t3.bundledQuery
      };
    }(e));
  }
};
function er(t2) {
  return Mi(t2, "bundles");
}
function nr(t2) {
  return Mi(t2, "namedQueries");
}
var sr = class {
  constructor(t2, e) {
    this.wt = t2, this.userId = e;
  }
  static se(t2, e) {
    const n = e.uid || "";
    return new sr(t2, n);
  }
  getOverlay(t2, e) {
    return ir(t2).get(Xi(this.userId, e)).next((t3) => t3 ? Yi(this.wt, t3) : null);
  }
  getOverlays(t2, e) {
    const n = hs();
    return Pt.forEach(e, (e2) => this.getOverlay(t2, e2).next((t3) => {
      t3 !== null && n.set(e2, t3);
    })).next(() => n);
  }
  saveOverlays(t2, e, n) {
    const s = [];
    return n.forEach((n2, i) => {
      const r = new Bi(e, i);
      s.push(this.ie(t2, r));
    }), Pt.waitFor(s);
  }
  removeOverlaysForBatchId(t2, e, n) {
    const s = /* @__PURE__ */ new Set();
    e.forEach((t3) => s.add(ci(t3.getCollectionPath())));
    const i = [];
    return s.forEach((e2) => {
      const s2 = IDBKeyRange.bound([this.userId, e2, n], [this.userId, e2, n + 1], false, true);
      i.push(ir(t2).W("collectionPathOverlayIndex", s2));
    }), Pt.waitFor(i);
  }
  getOverlaysForCollection(t2, e, n) {
    const s = hs(), i = ci(e), r = IDBKeyRange.bound([this.userId, i, n], [this.userId, i, Number.POSITIVE_INFINITY], true);
    return ir(t2).K("collectionPathOverlayIndex", r).next((t3) => {
      for (const e2 of t3) {
        const t4 = Yi(this.wt, e2);
        s.set(t4.getKey(), t4);
      }
      return s;
    });
  }
  getOverlaysForCollectionGroup(t2, e, n, s) {
    const i = hs();
    let r;
    const o = IDBKeyRange.bound([this.userId, e, n], [this.userId, e, Number.POSITIVE_INFINITY], true);
    return ir(t2).J({
      index: "collectionGroupOverlayIndex",
      range: o
    }, (t3, e2, n2) => {
      const o2 = Yi(this.wt, e2);
      i.size() < s || o2.largestBatchId === r ? (i.set(o2.getKey(), o2), r = o2.largestBatchId) : n2.done();
    }).next(() => i);
  }
  ie(t2, e) {
    return ir(t2).put(function(t3, e2, n) {
      const [s, i, r] = Xi(e2, n.mutation.key);
      return {
        userId: e2,
        collectionPath: i,
        documentId: r,
        collectionGroup: n.mutation.key.getCollectionGroup(),
        largestBatchId: n.largestBatchId,
        overlayMutation: js(t3.ne, n.mutation)
      };
    }(this.wt, this.userId, e));
  }
};
function ir(t2) {
  return Mi(t2, "documentOverlays");
}
var rr = class {
  constructor() {
  }
  re(t2, e) {
    this.oe(t2, e), e.ue();
  }
  oe(t2, e) {
    if ("nullValue" in t2)
      this.ce(e, 5);
    else if ("booleanValue" in t2)
      this.ce(e, 10), e.ae(t2.booleanValue ? 1 : 0);
    else if ("integerValue" in t2)
      this.ce(e, 15), e.ae(Zt(t2.integerValue));
    else if ("doubleValue" in t2) {
      const n = Zt(t2.doubleValue);
      isNaN(n) ? this.ce(e, 13) : (this.ce(e, 15), ue(n) ? e.ae(0) : e.ae(n));
    } else if ("timestampValue" in t2) {
      const n = t2.timestampValue;
      this.ce(e, 20), typeof n == "string" ? e.he(n) : (e.he(`${n.seconds || ""}`), e.ae(n.nanos || 0));
    } else if ("stringValue" in t2)
      this.le(t2.stringValue, e), this.fe(e);
    else if ("bytesValue" in t2)
      this.ce(e, 30), e.de(te(t2.bytesValue)), this.fe(e);
    else if ("referenceValue" in t2)
      this._e(t2.referenceValue, e);
    else if ("geoPointValue" in t2) {
      const n = t2.geoPointValue;
      this.ce(e, 45), e.ae(n.latitude || 0), e.ae(n.longitude || 0);
    } else
      "mapValue" in t2 ? be(t2) ? this.ce(e, Number.MAX_SAFE_INTEGER) : (this.we(t2.mapValue, e), this.fe(e)) : "arrayValue" in t2 ? (this.me(t2.arrayValue, e), this.fe(e)) : L2();
  }
  le(t2, e) {
    this.ce(e, 25), this.ge(t2, e);
  }
  ge(t2, e) {
    e.he(t2);
  }
  we(t2, e) {
    const n = t2.fields || {};
    this.ce(e, 55);
    for (const t3 of Object.keys(n))
      this.le(t3, e), this.oe(n[t3], e);
  }
  me(t2, e) {
    const n = t2.values || [];
    this.ce(e, 50);
    for (const t3 of n)
      this.oe(t3, e);
  }
  _e(t2, e) {
    this.ce(e, 37);
    dt.fromName(t2).path.forEach((t3) => {
      this.ce(e, 60), this.ge(t3, e);
    });
  }
  ce(t2, e) {
    t2.ae(e);
  }
  fe(t2) {
    t2.ae(2);
  }
};
rr.ye = new rr();
function or(t2) {
  if (t2 === 0)
    return 8;
  let e = 0;
  return t2 >> 4 == 0 && (e += 4, t2 <<= 4), t2 >> 6 == 0 && (e += 2, t2 <<= 2), t2 >> 7 == 0 && (e += 1), e;
}
function ur(t2) {
  const e = 64 - function(t3) {
    let e2 = 0;
    for (let n = 0; n < 8; ++n) {
      const s = or(255 & t3[n]);
      if (e2 += s, s !== 8)
        break;
    }
    return e2;
  }(t2);
  return Math.ceil(e / 8);
}
var cr = class {
  constructor() {
    this.buffer = new Uint8Array(1024), this.position = 0;
  }
  pe(t2) {
    const e = t2[Symbol.iterator]();
    let n = e.next();
    for (; !n.done; )
      this.Ie(n.value), n = e.next();
    this.Te();
  }
  Ee(t2) {
    const e = t2[Symbol.iterator]();
    let n = e.next();
    for (; !n.done; )
      this.Ae(n.value), n = e.next();
    this.Re();
  }
  be(t2) {
    for (const e of t2) {
      const t3 = e.charCodeAt(0);
      if (t3 < 128)
        this.Ie(t3);
      else if (t3 < 2048)
        this.Ie(960 | t3 >>> 6), this.Ie(128 | 63 & t3);
      else if (e < "\uD800" || "\uDBFF" < e)
        this.Ie(480 | t3 >>> 12), this.Ie(128 | 63 & t3 >>> 6), this.Ie(128 | 63 & t3);
      else {
        const t4 = e.codePointAt(0);
        this.Ie(240 | t4 >>> 18), this.Ie(128 | 63 & t4 >>> 12), this.Ie(128 | 63 & t4 >>> 6), this.Ie(128 | 63 & t4);
      }
    }
    this.Te();
  }
  Pe(t2) {
    for (const e of t2) {
      const t3 = e.charCodeAt(0);
      if (t3 < 128)
        this.Ae(t3);
      else if (t3 < 2048)
        this.Ae(960 | t3 >>> 6), this.Ae(128 | 63 & t3);
      else if (e < "\uD800" || "\uDBFF" < e)
        this.Ae(480 | t3 >>> 12), this.Ae(128 | 63 & t3 >>> 6), this.Ae(128 | 63 & t3);
      else {
        const t4 = e.codePointAt(0);
        this.Ae(240 | t4 >>> 18), this.Ae(128 | 63 & t4 >>> 12), this.Ae(128 | 63 & t4 >>> 6), this.Ae(128 | 63 & t4);
      }
    }
    this.Re();
  }
  ve(t2) {
    const e = this.Ve(t2), n = ur(e);
    this.Se(1 + n), this.buffer[this.position++] = 255 & n;
    for (let t3 = e.length - n; t3 < e.length; ++t3)
      this.buffer[this.position++] = 255 & e[t3];
  }
  De(t2) {
    const e = this.Ve(t2), n = ur(e);
    this.Se(1 + n), this.buffer[this.position++] = ~(255 & n);
    for (let t3 = e.length - n; t3 < e.length; ++t3)
      this.buffer[this.position++] = ~(255 & e[t3]);
  }
  Ce() {
    this.xe(255), this.xe(255);
  }
  Ne() {
    this.ke(255), this.ke(255);
  }
  reset() {
    this.position = 0;
  }
  seed(t2) {
    this.Se(t2.length), this.buffer.set(t2, this.position), this.position += t2.length;
  }
  Oe() {
    return this.buffer.slice(0, this.position);
  }
  Ve(t2) {
    const e = function(t3) {
      const e2 = new DataView(new ArrayBuffer(8));
      return e2.setFloat64(0, t3, false), new Uint8Array(e2.buffer);
    }(t2), n = (128 & e[0]) != 0;
    e[0] ^= n ? 255 : 128;
    for (let t3 = 1; t3 < e.length; ++t3)
      e[t3] ^= n ? 255 : 0;
    return e;
  }
  Ie(t2) {
    const e = 255 & t2;
    e === 0 ? (this.xe(0), this.xe(255)) : e === 255 ? (this.xe(255), this.xe(0)) : this.xe(e);
  }
  Ae(t2) {
    const e = 255 & t2;
    e === 0 ? (this.ke(0), this.ke(255)) : e === 255 ? (this.ke(255), this.ke(0)) : this.ke(t2);
  }
  Te() {
    this.xe(0), this.xe(1);
  }
  Re() {
    this.ke(0), this.ke(1);
  }
  xe(t2) {
    this.Se(1), this.buffer[this.position++] = t2;
  }
  ke(t2) {
    this.Se(1), this.buffer[this.position++] = ~t2;
  }
  Se(t2) {
    const e = t2 + this.position;
    if (e <= this.buffer.length)
      return;
    let n = 2 * this.buffer.length;
    n < e && (n = e);
    const s = new Uint8Array(n);
    s.set(this.buffer), this.buffer = s;
  }
};
var ar = class {
  constructor(t2) {
    this.Me = t2;
  }
  de(t2) {
    this.Me.pe(t2);
  }
  he(t2) {
    this.Me.be(t2);
  }
  ae(t2) {
    this.Me.ve(t2);
  }
  ue() {
    this.Me.Ce();
  }
};
var hr = class {
  constructor(t2) {
    this.Me = t2;
  }
  de(t2) {
    this.Me.Ee(t2);
  }
  he(t2) {
    this.Me.Pe(t2);
  }
  ae(t2) {
    this.Me.De(t2);
  }
  ue() {
    this.Me.Ne();
  }
};
var lr = class {
  constructor() {
    this.Me = new cr(), this.Fe = new ar(this.Me), this.$e = new hr(this.Me);
  }
  seed(t2) {
    this.Me.seed(t2);
  }
  Be(t2) {
    return t2 === 0 ? this.Fe : this.$e;
  }
  Oe() {
    return this.Me.Oe();
  }
  reset() {
    this.Me.reset();
  }
};
var fr = class {
  constructor(t2, e, n, s) {
    this.indexId = t2, this.documentKey = e, this.arrayValue = n, this.directionalValue = s;
  }
  Le() {
    const t2 = this.directionalValue.length, e = t2 === 0 || this.directionalValue[t2 - 1] === 255 ? t2 + 1 : t2, n = new Uint8Array(e);
    return n.set(this.directionalValue, 0), e !== t2 ? n.set([0], this.directionalValue.length) : ++n[n.length - 1], new fr(this.indexId, this.documentKey, this.arrayValue, n);
  }
};
function dr(t2, e) {
  let n = t2.indexId - e.indexId;
  return n !== 0 ? n : (n = _r(t2.arrayValue, e.arrayValue), n !== 0 ? n : (n = _r(t2.directionalValue, e.directionalValue), n !== 0 ? n : dt.comparator(t2.documentKey, e.documentKey)));
}
function _r(t2, e) {
  for (let n = 0; n < t2.length && n < e.length; ++n) {
    const s = t2[n] - e[n];
    if (s !== 0)
      return s;
  }
  return t2.length - e.length;
}
var wr = class {
  constructor(t2) {
    this.collectionId = t2.collectionGroup != null ? t2.collectionGroup : t2.path.lastSegment(), this.Ue = t2.orderBy, this.qe = [];
    for (const e of t2.filters) {
      const t3 = e;
      t3.ht() ? this.Ke = t3 : this.qe.push(t3);
    }
  }
  Ge(t2) {
    const e = wt(t2);
    if (e !== void 0 && !this.Qe(e))
      return false;
    const n = mt(t2);
    let s = 0, i = 0;
    for (; s < n.length && this.Qe(n[s]); ++s)
      ;
    if (s === n.length)
      return true;
    if (this.Ke !== void 0) {
      const t3 = n[s];
      if (!this.je(this.Ke, t3) || !this.We(this.Ue[i++], t3))
        return false;
      ++s;
    }
    for (; s < n.length; ++s) {
      const t3 = n[s];
      if (i >= this.Ue.length || !this.We(this.Ue[i++], t3))
        return false;
    }
    return true;
  }
  Qe(t2) {
    for (const e of this.qe)
      if (this.je(e, t2))
        return true;
    return false;
  }
  je(t2, e) {
    if (t2 === void 0 || !t2.field.isEqual(e.fieldPath))
      return false;
    const n = t2.op === "array-contains" || t2.op === "array-contains-any";
    return e.kind === 2 === n;
  }
  We(t2, e) {
    return !!t2.field.isEqual(e.fieldPath) && (e.kind === 0 && t2.dir === "asc" || e.kind === 1 && t2.dir === "desc");
  }
};
var mr = class {
  constructor() {
    this.ze = new gr();
  }
  addToCollectionParentIndex(t2, e) {
    return this.ze.add(e), Pt.resolve();
  }
  getCollectionParents(t2, e) {
    return Pt.resolve(this.ze.getEntries(e));
  }
  addFieldIndex(t2, e) {
    return Pt.resolve();
  }
  deleteFieldIndex(t2, e) {
    return Pt.resolve();
  }
  getDocumentsMatchingTarget(t2, e) {
    return Pt.resolve(null);
  }
  getIndexType(t2, e) {
    return Pt.resolve(0);
  }
  getFieldIndexes(t2, e) {
    return Pt.resolve([]);
  }
  getNextCollectionGroupToUpdate(t2) {
    return Pt.resolve(null);
  }
  getMinOffset(t2, e) {
    return Pt.resolve(Tt.min());
  }
  getMinOffsetFromCollectionGroup(t2, e) {
    return Pt.resolve(Tt.min());
  }
  updateCollectionGroup(t2, e, n) {
    return Pt.resolve();
  }
  updateIndexEntries(t2, e) {
    return Pt.resolve();
  }
};
var gr = class {
  constructor() {
    this.index = {};
  }
  add(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e] || new Qt(ht.comparator), i = !s.has(n);
    return this.index[e] = s.add(n), i;
  }
  has(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e];
    return s && s.has(n);
  }
  getEntries(t2) {
    return (this.index[t2] || new Qt(ht.comparator)).toArray();
  }
};
var yr = new Uint8Array(0);
var pr = class {
  constructor(t2, e) {
    this.user = t2, this.databaseId = e, this.He = new gr(), this.Je = new is((t3) => Oe(t3), (t3, e2) => Fe(t3, e2)), this.uid = t2.uid || "";
  }
  addToCollectionParentIndex(t2, e) {
    if (!this.He.has(e)) {
      const n = e.lastSegment(), s = e.popLast();
      t2.addOnCommittedListener(() => {
        this.He.add(e);
      });
      const i = {
        collectionId: n,
        parent: ci(s)
      };
      return Ir(t2).put(i);
    }
    return Pt.resolve();
  }
  getCollectionParents(t2, e) {
    const n = [], s = IDBKeyRange.bound([e, ""], [ot(e), ""], false, true);
    return Ir(t2).K(s).next((t3) => {
      for (const s2 of t3) {
        if (s2.collectionId !== e)
          break;
        n.push(li(s2.parent));
      }
      return n;
    });
  }
  addFieldIndex(t2, e) {
    const n = Er(t2), s = function(t3) {
      return {
        indexId: t3.indexId,
        collectionGroup: t3.collectionGroup,
        fields: t3.fields.map((t4) => [t4.fieldPath.canonicalString(), t4.kind])
      };
    }(e);
    delete s.indexId;
    const i = n.add(s);
    if (e.indexState) {
      const n2 = Ar(t2);
      return i.next((t3) => {
        n2.put(Zi(t3, this.user, e.indexState.sequenceNumber, e.indexState.offset));
      });
    }
    return i.next();
  }
  deleteFieldIndex(t2, e) {
    const n = Er(t2), s = Ar(t2), i = Tr(t2);
    return n.delete(e.indexId).next(() => s.delete(IDBKeyRange.bound([e.indexId], [e.indexId + 1], false, true))).next(() => i.delete(IDBKeyRange.bound([e.indexId], [e.indexId + 1], false, true)));
  }
  getDocumentsMatchingTarget(t2, e) {
    const n = Tr(t2);
    let s = true;
    const i = /* @__PURE__ */ new Map();
    return Pt.forEach(this.Ye(e), (e2) => this.Xe(t2, e2).next((t3) => {
      s && (s = !!t3), i.set(e2, t3);
    })).next(() => {
      if (s) {
        let t3 = ws();
        const s2 = [];
        return Pt.forEach(i, (i2, r) => {
          var o;
          M2("IndexedDbIndexManager", `Using index ${o = i2, `id=${o.indexId}|cg=${o.collectionGroup}|f=${o.fields.map((t4) => `${t4.fieldPath}:${t4.kind}`).join(",")}`} to execute ${Oe(e)}`);
          const u = function(t4, e2) {
            const n2 = wt(e2);
            if (n2 === void 0)
              return null;
            for (const e3 of Be(t4, n2.fieldPath))
              switch (e3.op) {
                case "array-contains-any":
                  return e3.value.arrayValue.values || [];
                case "array-contains":
                  return [e3.value];
              }
            return null;
          }(r, i2), c = function(t4, e2) {
            const n2 = /* @__PURE__ */ new Map();
            for (const s3 of mt(e2))
              for (const e3 of Be(t4, s3.fieldPath))
                switch (e3.op) {
                  case "==":
                  case "in":
                    n2.set(s3.fieldPath.canonicalString(), e3.value);
                    break;
                  case "not-in":
                  case "!=":
                    return n2.set(s3.fieldPath.canonicalString(), e3.value), Array.from(n2.values());
                }
            return null;
          }(r, i2), a = function(t4, e2) {
            const n2 = [];
            let s3 = true;
            for (const i3 of mt(e2)) {
              const e3 = i3.kind === 0 ? Le(t4, i3.fieldPath, t4.startAt) : Ue(t4, i3.fieldPath, t4.startAt);
              n2.push(e3.value), s3 && (s3 = e3.inclusive);
            }
            return new Ye(n2, s3);
          }(r, i2), h = function(t4, e2) {
            const n2 = [];
            let s3 = true;
            for (const i3 of mt(e2)) {
              const e3 = i3.kind === 0 ? Ue(t4, i3.fieldPath, t4.endAt) : Le(t4, i3.fieldPath, t4.endAt);
              n2.push(e3.value), s3 && (s3 = e3.inclusive);
            }
            return new Ye(n2, s3);
          }(r, i2), l2 = this.Ze(i2, r, a), f = this.Ze(i2, r, h), d = this.tn(i2, r, c), _ = this.en(i2.indexId, u, l2, a.inclusive, f, h.inclusive, d);
          return Pt.forEach(_, (i3) => n.j(i3, e.limit).next((e2) => {
            e2.forEach((e3) => {
              const n2 = dt.fromSegments(e3.documentKey);
              t3.has(n2) || (t3 = t3.add(n2), s2.push(n2));
            });
          }));
        }).next(() => s2);
      }
      return Pt.resolve(null);
    });
  }
  Ye(t2) {
    let e = this.Je.get(t2);
    return e || (e = [t2], this.Je.set(t2, e), e);
  }
  en(t2, e, n, s, i, r, o) {
    const u = (e != null ? e.length : 1) * Math.max(n.length, i.length), c = u / (e != null ? e.length : 1), a = [];
    for (let h = 0; h < u; ++h) {
      const u2 = e ? this.nn(e[h / c]) : yr, l2 = this.sn(t2, u2, n[h % c], s), f = this.rn(t2, u2, i[h % c], r), d = o.map((e2) => this.sn(t2, u2, e2, true));
      a.push(...this.createRange(l2, f, d));
    }
    return a;
  }
  sn(t2, e, n, s) {
    const i = new fr(t2, dt.empty(), e, n);
    return s ? i : i.Le();
  }
  rn(t2, e, n, s) {
    const i = new fr(t2, dt.empty(), e, n);
    return s ? i.Le() : i;
  }
  Xe(t2, e) {
    const n = new wr(e), s = e.collectionGroup != null ? e.collectionGroup : e.path.lastSegment();
    return this.getFieldIndexes(t2, s).next((t3) => {
      let e2 = null;
      for (const s2 of t3) {
        n.Ge(s2) && (!e2 || s2.fields.length > e2.fields.length) && (e2 = s2);
      }
      return e2;
    });
  }
  getIndexType(t2, e) {
    let n = 2;
    return Pt.forEach(this.Ye(e), (e2) => this.Xe(t2, e2).next((t3) => {
      t3 ? n !== 0 && t3.fields.length < function(t4) {
        let e3 = new Qt(ft.comparator), n2 = false;
        for (const s of t4.filters) {
          const t5 = s;
          t5.field.isKeyField() || (t5.op === "array-contains" || t5.op === "array-contains-any" ? n2 = true : e3 = e3.add(t5.field));
        }
        for (const n3 of t4.orderBy)
          n3.field.isKeyField() || (e3 = e3.add(n3.field));
        return e3.size + (n2 ? 1 : 0);
      }(e2) && (n = 1) : n = 0;
    })).next(() => n);
  }
  on(t2, e) {
    const n = new lr();
    for (const s of mt(t2)) {
      const t3 = e.data.field(s.fieldPath);
      if (t3 == null)
        return null;
      const i = n.Be(s.kind);
      rr.ye.re(t3, i);
    }
    return n.Oe();
  }
  nn(t2) {
    const e = new lr();
    return rr.ye.re(t2, e.Be(0)), e.Oe();
  }
  un(t2, e) {
    const n = new lr();
    return rr.ye.re(ye(this.databaseId, e), n.Be(function(t3) {
      const e2 = mt(t3);
      return e2.length === 0 ? 0 : e2[e2.length - 1].kind;
    }(t2))), n.Oe();
  }
  tn(t2, e, n) {
    if (n === null)
      return [];
    let s = [];
    s.push(new lr());
    let i = 0;
    for (const r of mt(t2)) {
      const t3 = n[i++];
      for (const n2 of s)
        if (this.cn(e, r.fieldPath) && Ie(t3))
          s = this.an(s, r, t3);
        else {
          const e2 = n2.Be(r.kind);
          rr.ye.re(t3, e2);
        }
    }
    return this.hn(s);
  }
  Ze(t2, e, n) {
    return this.tn(t2, e, n.position);
  }
  hn(t2) {
    const e = [];
    for (let n = 0; n < t2.length; ++n)
      e[n] = t2[n].Oe();
    return e;
  }
  an(t2, e, n) {
    const s = [...t2], i = [];
    for (const t3 of n.arrayValue.values || [])
      for (const n2 of s) {
        const s2 = new lr();
        s2.seed(n2.Oe()), rr.ye.re(t3, s2.Be(e.kind)), i.push(s2);
      }
    return i;
  }
  cn(t2, e) {
    return !!t2.filters.find((t3) => t3 instanceof qe && t3.field.isEqual(e) && (t3.op === "in" || t3.op === "not-in"));
  }
  getFieldIndexes(t2, e) {
    const n = Er(t2), s = Ar(t2);
    return (e ? n.K("collectionGroupIndex", IDBKeyRange.bound(e, e)) : n.K()).next((t3) => {
      const e2 = [];
      return Pt.forEach(t3, (t4) => s.get([t4.indexId, this.uid]).next((n2) => {
        e2.push(function(t5, e3) {
          const n3 = e3 ? new yt(e3.sequenceNumber, new Tt(ji(e3.readTime), new dt(li(e3.documentKey)), e3.largestBatchId)) : yt.empty(), s2 = t5.fields.map(([t6, e4]) => new gt(ft.fromServerFormat(t6), e4));
          return new _t(t5.indexId, t5.collectionGroup, s2, n3);
        }(t4, n2));
      })).next(() => e2);
    });
  }
  getNextCollectionGroupToUpdate(t2) {
    return this.getFieldIndexes(t2).next((t3) => t3.length === 0 ? null : (t3.sort((t4, e) => {
      const n = t4.indexState.sequenceNumber - e.indexState.sequenceNumber;
      return n !== 0 ? n : it(t4.collectionGroup, e.collectionGroup);
    }), t3[0].collectionGroup));
  }
  updateCollectionGroup(t2, e, n) {
    const s = Er(t2), i = Ar(t2);
    return this.ln(t2).next((t3) => s.K("collectionGroupIndex", IDBKeyRange.bound(e, e)).next((e2) => Pt.forEach(e2, (e3) => i.put(Zi(e3.indexId, this.user, t3, n)))));
  }
  updateIndexEntries(t2, e) {
    const n = /* @__PURE__ */ new Map();
    return Pt.forEach(e, (e2, s) => {
      const i = n.get(e2.collectionGroup);
      return (i ? Pt.resolve(i) : this.getFieldIndexes(t2, e2.collectionGroup)).next((i2) => (n.set(e2.collectionGroup, i2), Pt.forEach(i2, (n2) => this.fn(t2, e2, n2).next((e3) => {
        const i3 = this.dn(s, n2);
        return e3.isEqual(i3) ? Pt.resolve() : this._n(t2, s, n2, e3, i3);
      }))));
    });
  }
  wn(t2, e, n, s) {
    return Tr(t2).put({
      indexId: s.indexId,
      uid: this.uid,
      arrayValue: s.arrayValue,
      directionalValue: s.directionalValue,
      orderedDocumentKey: this.un(n, e.key),
      documentKey: e.key.path.toArray()
    });
  }
  mn(t2, e, n, s) {
    return Tr(t2).delete([s.indexId, this.uid, s.arrayValue, s.directionalValue, this.un(n, e.key), e.key.path.toArray()]);
  }
  fn(t2, e, n) {
    const s = Tr(t2);
    let i = new Qt(dr);
    return s.J({
      index: "documentKeyIndex",
      range: IDBKeyRange.only([n.indexId, this.uid, this.un(n, e)])
    }, (t3, s2) => {
      i = i.add(new fr(n.indexId, e, s2.arrayValue, s2.directionalValue));
    }).next(() => i);
  }
  dn(t2, e) {
    let n = new Qt(dr);
    const s = this.on(e, t2);
    if (s == null)
      return n;
    const i = wt(e);
    if (i != null) {
      const r = t2.data.field(i.fieldPath);
      if (Ie(r))
        for (const i2 of r.arrayValue.values || [])
          n = n.add(new fr(e.indexId, t2.key, this.nn(i2), s));
    } else
      n = n.add(new fr(e.indexId, t2.key, yr, s));
    return n;
  }
  _n(t2, e, n, s, i) {
    M2("IndexedDbIndexManager", "Updating index entries for document '%s'", e.key);
    const r = [];
    return function(t3, e2, n2, s2, i2) {
      const r2 = t3.getIterator(), o = e2.getIterator();
      let u = Wt(r2), c = Wt(o);
      for (; u || c; ) {
        let t4 = false, e3 = false;
        if (u && c) {
          const s3 = n2(u, c);
          s3 < 0 ? e3 = true : s3 > 0 && (t4 = true);
        } else
          u != null ? e3 = true : t4 = true;
        t4 ? (s2(c), c = Wt(o)) : e3 ? (i2(u), u = Wt(r2)) : (u = Wt(r2), c = Wt(o));
      }
    }(s, i, dr, (s2) => {
      r.push(this.wn(t2, e, n, s2));
    }, (s2) => {
      r.push(this.mn(t2, e, n, s2));
    }), Pt.waitFor(r);
  }
  ln(t2) {
    let e = 1;
    return Ar(t2).J({
      index: "sequenceNumberIndex",
      reverse: true,
      range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER])
    }, (t3, n, s) => {
      s.done(), e = n.sequenceNumber + 1;
    }).next(() => e);
  }
  createRange(t2, e, n) {
    n = n.sort((t3, e2) => dr(t3, e2)).filter((t3, e2, n2) => !e2 || dr(t3, n2[e2 - 1]) !== 0);
    const s = [];
    s.push(t2);
    for (const i2 of n) {
      const n2 = dr(i2, t2), r = dr(i2, e);
      if (n2 === 0)
        s[0] = t2.Le();
      else if (n2 > 0 && r < 0)
        s.push(i2), s.push(i2.Le());
      else if (r > 0)
        break;
    }
    s.push(e);
    const i = [];
    for (let t3 = 0; t3 < s.length; t3 += 2)
      i.push(IDBKeyRange.bound([s[t3].indexId, this.uid, s[t3].arrayValue, s[t3].directionalValue, yr, []], [s[t3 + 1].indexId, this.uid, s[t3 + 1].arrayValue, s[t3 + 1].directionalValue, yr, []]));
    return i;
  }
  getMinOffsetFromCollectionGroup(t2, e) {
    return this.getFieldIndexes(t2, e).next(Rr);
  }
  getMinOffset(t2, e) {
    return Pt.mapArray(this.Ye(e), (e2) => this.Xe(t2, e2).next((t3) => t3 || L2())).next(Rr);
  }
};
function Ir(t2) {
  return Mi(t2, "collectionParents");
}
function Tr(t2) {
  return Mi(t2, "indexEntries");
}
function Er(t2) {
  return Mi(t2, "indexConfiguration");
}
function Ar(t2) {
  return Mi(t2, "indexState");
}
function Rr(t2) {
  U2(t2.length !== 0);
  let e = t2[0].indexState.offset, n = e.largestBatchId;
  for (let s = 1; s < t2.length; s++) {
    const i = t2[s].indexState.offset;
    Et(i, e) < 0 && (e = i), n < i.largestBatchId && (n = i.largestBatchId);
  }
  return new Tt(e.readTime, e.documentKey, n);
}
var br = {
  didRun: false,
  sequenceNumbersCollected: 0,
  targetsRemoved: 0,
  documentsRemoved: 0
};
var Pr = class {
  constructor(t2, e, n) {
    this.cacheSizeCollectionThreshold = t2, this.percentileToCollect = e, this.maximumSequenceNumbersToCollect = n;
  }
  static withCacheSize(t2) {
    return new Pr(t2, Pr.DEFAULT_COLLECTION_PERCENTILE, Pr.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
  }
};
function vr(t2, e, n) {
  const s = t2.store("mutations"), i = t2.store("documentMutations"), r = [], o = IDBKeyRange.only(n.batchId);
  let u = 0;
  const c = s.J({
    range: o
  }, (t3, e2, n2) => (u++, n2.delete()));
  r.push(c.next(() => {
    U2(u === 1);
  }));
  const a = [];
  for (const t3 of n.mutations) {
    const s2 = _i(e, t3.key.path, n.batchId);
    r.push(i.delete(s2)), a.push(t3.key);
  }
  return Pt.waitFor(r).next(() => a);
}
function Vr(t2) {
  if (!t2)
    return 0;
  let e;
  if (t2.document)
    e = t2.document;
  else if (t2.unknownDocument)
    e = t2.unknownDocument;
  else {
    if (!t2.noDocument)
      throw L2();
    e = t2.noDocument;
  }
  return JSON.stringify(e).length;
}
Pr.DEFAULT_COLLECTION_PERCENTILE = 10, Pr.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, Pr.DEFAULT = new Pr(41943040, Pr.DEFAULT_COLLECTION_PERCENTILE, Pr.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), Pr.DISABLED = new Pr(-1, 0, 0);
var Sr = class {
  constructor(t2, e, n, s) {
    this.userId = t2, this.wt = e, this.indexManager = n, this.referenceDelegate = s, this.gn = {};
  }
  static se(t2, e, n, s) {
    U2(t2.uid !== "");
    const i = t2.isAuthenticated() ? t2.uid : "";
    return new Sr(i, e, n, s);
  }
  checkEmpty(t2) {
    let e = true;
    const n = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
    return Cr(t2).J({
      index: "userMutationsIndex",
      range: n
    }, (t3, n2, s) => {
      e = false, s.done();
    }).next(() => e);
  }
  addMutationBatch(t2, e, n, s) {
    const i = xr(t2), r = Cr(t2);
    return r.add({}).next((o) => {
      U2(typeof o == "number");
      const u = new Fi(o, e, n, s), c = function(t3, e2, n2) {
        const s2 = n2.baseMutations.map((e3) => js(t3.ne, e3)), i2 = n2.mutations.map((e3) => js(t3.ne, e3));
        return {
          userId: e2,
          batchId: n2.batchId,
          localWriteTimeMs: n2.localWriteTime.toMillis(),
          baseMutations: s2,
          mutations: i2
        };
      }(this.wt, this.userId, u), a = [];
      let h = new Qt((t3, e2) => it(t3.canonicalString(), e2.canonicalString()));
      for (const t3 of s) {
        const e2 = _i(this.userId, t3.key.path, o);
        h = h.add(t3.key.path.popLast()), a.push(r.put(c)), a.push(i.put(e2, wi));
      }
      return h.forEach((e2) => {
        a.push(this.indexManager.addToCollectionParentIndex(t2, e2));
      }), t2.addOnCommittedListener(() => {
        this.gn[o] = u.keys();
      }), Pt.waitFor(a).next(() => u);
    });
  }
  lookupMutationBatch(t2, e) {
    return Cr(t2).get(e).next((t3) => t3 ? (U2(t3.userId === this.userId), Wi(this.wt, t3)) : null);
  }
  yn(t2, e) {
    return this.gn[e] ? Pt.resolve(this.gn[e]) : this.lookupMutationBatch(t2, e).next((t3) => {
      if (t3) {
        const n = t3.keys();
        return this.gn[e] = n, n;
      }
      return null;
    });
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = IDBKeyRange.lowerBound([this.userId, n]);
    let i = null;
    return Cr(t2).J({
      index: "userMutationsIndex",
      range: s
    }, (t3, e2, s2) => {
      e2.userId === this.userId && (U2(e2.batchId >= n), i = Wi(this.wt, e2)), s2.done();
    }).next(() => i);
  }
  getHighestUnacknowledgedBatchId(t2) {
    const e = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]);
    let n = -1;
    return Cr(t2).J({
      index: "userMutationsIndex",
      range: e,
      reverse: true
    }, (t3, e2, s) => {
      n = e2.batchId, s.done();
    }).next(() => n);
  }
  getAllMutationBatches(t2) {
    const e = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
    return Cr(t2).K("userMutationsIndex", e).next((t3) => t3.map((t4) => Wi(this.wt, t4)));
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = di(this.userId, e.path), s = IDBKeyRange.lowerBound(n), i = [];
    return xr(t2).J({
      range: s
    }, (n2, s2, r) => {
      const [o, u, c] = n2, a = li(u);
      if (o === this.userId && e.path.isEqual(a))
        return Cr(t2).get(c).next((t3) => {
          if (!t3)
            throw L2();
          U2(t3.userId === this.userId), i.push(Wi(this.wt, t3));
        });
      r.done();
    }).next(() => i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new Qt(it);
    const s = [];
    return e.forEach((e2) => {
      const i = di(this.userId, e2.path), r = IDBKeyRange.lowerBound(i), o = xr(t2).J({
        range: r
      }, (t3, s2, i2) => {
        const [r2, o2, u] = t3, c = li(o2);
        r2 === this.userId && e2.path.isEqual(c) ? n = n.add(u) : i2.done();
      });
      s.push(o);
    }), Pt.waitFor(s).next(() => this.pn(t2, n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1, i = di(this.userId, n), r = IDBKeyRange.lowerBound(i);
    let o = new Qt(it);
    return xr(t2).J({
      range: r
    }, (t3, e2, i2) => {
      const [r2, u, c] = t3, a = li(u);
      r2 === this.userId && n.isPrefixOf(a) ? a.length === s && (o = o.add(c)) : i2.done();
    }).next(() => this.pn(t2, o));
  }
  pn(t2, e) {
    const n = [], s = [];
    return e.forEach((e2) => {
      s.push(Cr(t2).get(e2).next((t3) => {
        if (t3 === null)
          throw L2();
        U2(t3.userId === this.userId), n.push(Wi(this.wt, t3));
      }));
    }), Pt.waitFor(s).next(() => n);
  }
  removeMutationBatch(t2, e) {
    return vr(t2.ee, this.userId, e).next((n) => (t2.addOnCommittedListener(() => {
      this.In(e.batchId);
    }), Pt.forEach(n, (e2) => this.referenceDelegate.markPotentiallyOrphaned(t2, e2))));
  }
  In(t2) {
    delete this.gn[t2];
  }
  performConsistencyCheck(t2) {
    return this.checkEmpty(t2).next((e) => {
      if (!e)
        return Pt.resolve();
      const n = IDBKeyRange.lowerBound([this.userId]);
      const s = [];
      return xr(t2).J({
        range: n
      }, (t3, e2, n2) => {
        if (t3[0] === this.userId) {
          const e3 = li(t3[1]);
          s.push(e3);
        } else
          n2.done();
      }).next(() => {
        U2(s.length === 0);
      });
    });
  }
  containsKey(t2, e) {
    return Dr(t2, this.userId, e);
  }
  Tn(t2) {
    return Nr(t2).get(this.userId).next((t3) => t3 || {
      userId: this.userId,
      lastAcknowledgedBatchId: -1,
      lastStreamToken: ""
    });
  }
};
function Dr(t2, e, n) {
  const s = di(e, n.path), i = s[1], r = IDBKeyRange.lowerBound(s);
  let o = false;
  return xr(t2).J({
    range: r,
    H: true
  }, (t3, n2, s2) => {
    const [r2, u, c] = t3;
    r2 === e && u === i && (o = true), s2.done();
  }).next(() => o);
}
function Cr(t2) {
  return Mi(t2, "mutations");
}
function xr(t2) {
  return Mi(t2, "documentMutations");
}
function Nr(t2) {
  return Mi(t2, "mutationQueues");
}
var kr = class {
  constructor(t2) {
    this.En = t2;
  }
  next() {
    return this.En += 2, this.En;
  }
  static An() {
    return new kr(0);
  }
  static Rn() {
    return new kr(-1);
  }
};
var Or = class {
  constructor(t2, e) {
    this.referenceDelegate = t2, this.wt = e;
  }
  allocateTargetId(t2) {
    return this.bn(t2).next((e) => {
      const n = new kr(e.highestTargetId);
      return e.highestTargetId = n.next(), this.Pn(t2, e).next(() => e.highestTargetId);
    });
  }
  getLastRemoteSnapshotVersion(t2) {
    return this.bn(t2).next((t3) => ct.fromTimestamp(new ut(t3.lastRemoteSnapshotVersion.seconds, t3.lastRemoteSnapshotVersion.nanoseconds)));
  }
  getHighestSequenceNumber(t2) {
    return this.bn(t2).next((t3) => t3.highestListenSequenceNumber);
  }
  setTargetsMetadata(t2, e, n) {
    return this.bn(t2).next((s) => (s.highestListenSequenceNumber = e, n && (s.lastRemoteSnapshotVersion = n.toTimestamp()), e > s.highestListenSequenceNumber && (s.highestListenSequenceNumber = e), this.Pn(t2, s)));
  }
  addTargetData(t2, e) {
    return this.vn(t2, e).next(() => this.bn(t2).next((n) => (n.targetCount += 1, this.Vn(e, n), this.Pn(t2, n))));
  }
  updateTargetData(t2, e) {
    return this.vn(t2, e);
  }
  removeTargetData(t2, e) {
    return this.removeMatchingKeysForTargetId(t2, e.targetId).next(() => Mr(t2).delete(e.targetId)).next(() => this.bn(t2)).next((e2) => (U2(e2.targetCount > 0), e2.targetCount -= 1, this.Pn(t2, e2)));
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return Mr(t2).J((r, o) => {
      const u = zi(o);
      u.sequenceNumber <= e && n.get(u.targetId) === null && (s++, i.push(this.removeTargetData(t2, u)));
    }).next(() => Pt.waitFor(i)).next(() => s);
  }
  forEachTarget(t2, e) {
    return Mr(t2).J((t3, n) => {
      const s = zi(n);
      e(s);
    });
  }
  bn(t2) {
    return Fr(t2).get("targetGlobalKey").next((t3) => (U2(t3 !== null), t3));
  }
  Pn(t2, e) {
    return Fr(t2).put("targetGlobalKey", e);
  }
  vn(t2, e) {
    return Mr(t2).put(Hi(this.wt, e));
  }
  Vn(t2, e) {
    let n = false;
    return t2.targetId > e.highestTargetId && (e.highestTargetId = t2.targetId, n = true), t2.sequenceNumber > e.highestListenSequenceNumber && (e.highestListenSequenceNumber = t2.sequenceNumber, n = true), n;
  }
  getTargetCount(t2) {
    return this.bn(t2).next((t3) => t3.targetCount);
  }
  getTargetData(t2, e) {
    const n = Oe(e), s = IDBKeyRange.bound([n, Number.NEGATIVE_INFINITY], [n, Number.POSITIVE_INFINITY]);
    let i = null;
    return Mr(t2).J({
      range: s,
      index: "queryTargetsIndex"
    }, (t3, n2, s2) => {
      const r = zi(n2);
      Fe(e, r.target) && (i = r, s2.done());
    }).next(() => i);
  }
  addMatchingKeys(t2, e, n) {
    const s = [], i = $r(t2);
    return e.forEach((e2) => {
      const r = ci(e2.path);
      s.push(i.put({
        targetId: n,
        path: r
      })), s.push(this.referenceDelegate.addReference(t2, n, e2));
    }), Pt.waitFor(s);
  }
  removeMatchingKeys(t2, e, n) {
    const s = $r(t2);
    return Pt.forEach(e, (e2) => {
      const i = ci(e2.path);
      return Pt.waitFor([s.delete([n, i]), this.referenceDelegate.removeReference(t2, n, e2)]);
    });
  }
  removeMatchingKeysForTargetId(t2, e) {
    const n = $r(t2), s = IDBKeyRange.bound([e], [e + 1], false, true);
    return n.delete(s);
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = IDBKeyRange.bound([e], [e + 1], false, true), s = $r(t2);
    let i = ws();
    return s.J({
      range: n,
      H: true
    }, (t3, e2, n2) => {
      const s2 = li(t3[1]), r = new dt(s2);
      i = i.add(r);
    }).next(() => i);
  }
  containsKey(t2, e) {
    const n = ci(e.path), s = IDBKeyRange.bound([n], [ot(n)], false, true);
    let i = 0;
    return $r(t2).J({
      index: "documentTargetsIndex",
      H: true,
      range: s
    }, ([t3, e2], n2, s2) => {
      t3 !== 0 && (i++, s2.done());
    }).next(() => i > 0);
  }
  te(t2, e) {
    return Mr(t2).get(e).next((t3) => t3 ? zi(t3) : null);
  }
};
function Mr(t2) {
  return Mi(t2, "targets");
}
function Fr(t2) {
  return Mi(t2, "targetGlobal");
}
function $r(t2) {
  return Mi(t2, "targetDocuments");
}
function Br([t2, e], [n, s]) {
  const i = it(t2, n);
  return i === 0 ? it(e, s) : i;
}
var Lr = class {
  constructor(t2) {
    this.Sn = t2, this.buffer = new Qt(Br), this.Dn = 0;
  }
  Cn() {
    return ++this.Dn;
  }
  xn(t2) {
    const e = [t2, this.Cn()];
    if (this.buffer.size < this.Sn)
      this.buffer = this.buffer.add(e);
    else {
      const t3 = this.buffer.last();
      Br(e, t3) < 0 && (this.buffer = this.buffer.delete(t3).add(e));
    }
  }
  get maxValue() {
    return this.buffer.last()[0];
  }
};
var Ur = class {
  constructor(t2, e, n) {
    this.garbageCollector = t2, this.asyncQueue = e, this.localStore = n, this.Nn = null;
  }
  start() {
    this.garbageCollector.params.cacheSizeCollectionThreshold !== -1 && this.kn(6e4);
  }
  stop() {
    this.Nn && (this.Nn.cancel(), this.Nn = null);
  }
  get started() {
    return this.Nn !== null;
  }
  kn(t2) {
    M2("LruGarbageCollector", `Garbage collection scheduled in ${t2}ms`), this.Nn = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", t2, async () => {
      this.Nn = null;
      try {
        await this.localStore.collectGarbage(this.garbageCollector);
      } catch (t3) {
        Ct(t3) ? M2("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", t3) : await bt(t3);
      }
      await this.kn(3e5);
    });
  }
};
var qr = class {
  constructor(t2, e) {
    this.On = t2, this.params = e;
  }
  calculateTargetCount(t2, e) {
    return this.On.Mn(t2).next((t3) => Math.floor(e / 100 * t3));
  }
  nthSequenceNumber(t2, e) {
    if (e === 0)
      return Pt.resolve($t.ot);
    const n = new Lr(e);
    return this.On.forEachTarget(t2, (t3) => n.xn(t3.sequenceNumber)).next(() => this.On.Fn(t2, (t3) => n.xn(t3))).next(() => n.maxValue);
  }
  removeTargets(t2, e, n) {
    return this.On.removeTargets(t2, e, n);
  }
  removeOrphanedDocuments(t2, e) {
    return this.On.removeOrphanedDocuments(t2, e);
  }
  collect(t2, e) {
    return this.params.cacheSizeCollectionThreshold === -1 ? (M2("LruGarbageCollector", "Garbage collection skipped; disabled"), Pt.resolve(br)) : this.getCacheSize(t2).next((n) => n < this.params.cacheSizeCollectionThreshold ? (M2("LruGarbageCollector", `Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), br) : this.$n(t2, e));
  }
  getCacheSize(t2) {
    return this.On.getCacheSize(t2);
  }
  $n(t2, e) {
    let n, s, i, r, o, c, a;
    const h = Date.now();
    return this.calculateTargetCount(t2, this.params.percentileToCollect).next((e2) => (e2 > this.params.maximumSequenceNumbersToCollect ? (M2("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${e2}`), s = this.params.maximumSequenceNumbersToCollect) : s = e2, r = Date.now(), this.nthSequenceNumber(t2, s))).next((s2) => (n = s2, o = Date.now(), this.removeTargets(t2, n, e))).next((e2) => (i = e2, c = Date.now(), this.removeOrphanedDocuments(t2, n))).next((t3) => {
      if (a = Date.now(), k2() <= LogLevel.DEBUG) {
        M2("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${r - h}ms
	Determined least recently used ${s} in ` + (o - r) + `ms
	Removed ${i} targets in ` + (c - o) + `ms
	Removed ${t3} documents in ` + (a - c) + `ms
Total Duration: ${a - h}ms`);
      }
      return Pt.resolve({
        didRun: true,
        sequenceNumbersCollected: s,
        targetsRemoved: i,
        documentsRemoved: t3
      });
    });
  }
};
var Kr = class {
  constructor(t2, e) {
    this.db = t2, this.garbageCollector = function(t3, e2) {
      return new qr(t3, e2);
    }(this, e);
  }
  Mn(t2) {
    const e = this.Bn(t2);
    return this.db.getTargetCache().getTargetCount(t2).next((t3) => e.next((e2) => t3 + e2));
  }
  Bn(t2) {
    let e = 0;
    return this.Fn(t2, (t3) => {
      e++;
    }).next(() => e);
  }
  forEachTarget(t2, e) {
    return this.db.getTargetCache().forEachTarget(t2, e);
  }
  Fn(t2, e) {
    return this.Ln(t2, (t3, n) => e(n));
  }
  addReference(t2, e, n) {
    return Gr(t2, n);
  }
  removeReference(t2, e, n) {
    return Gr(t2, n);
  }
  removeTargets(t2, e, n) {
    return this.db.getTargetCache().removeTargets(t2, e, n);
  }
  markPotentiallyOrphaned(t2, e) {
    return Gr(t2, e);
  }
  Un(t2, e) {
    return function(t3, e2) {
      let n = false;
      return Nr(t3).Y((s) => Dr(t3, s, e2).next((t4) => (t4 && (n = true), Pt.resolve(!t4)))).next(() => n);
    }(t2, e);
  }
  removeOrphanedDocuments(t2, e) {
    const n = this.db.getRemoteDocumentCache().newChangeBuffer(), s = [];
    let i = 0;
    return this.Ln(t2, (r, o) => {
      if (o <= e) {
        const e2 = this.Un(t2, r).next((e3) => {
          if (!e3)
            return i++, n.getEntry(t2, r).next(() => (n.removeEntry(r, ct.min()), $r(t2).delete([0, ci(r.path)])));
        });
        s.push(e2);
      }
    }).next(() => Pt.waitFor(s)).next(() => n.apply(t2)).next(() => i);
  }
  removeTarget(t2, e) {
    const n = e.withSequenceNumber(t2.currentSequenceNumber);
    return this.db.getTargetCache().updateTargetData(t2, n);
  }
  updateLimboDocument(t2, e) {
    return Gr(t2, e);
  }
  Ln(t2, e) {
    const n = $r(t2);
    let s, i = $t.ot;
    return n.J({
      index: "documentTargetsIndex"
    }, ([t3, n2], { path: r, sequenceNumber: o }) => {
      t3 === 0 ? (i !== $t.ot && e(new dt(li(s)), i), i = o, s = r) : i = $t.ot;
    }).next(() => {
      i !== $t.ot && e(new dt(li(s)), i);
    });
  }
  getCacheSize(t2) {
    return this.db.getRemoteDocumentCache().getSize(t2);
  }
};
function Gr(t2, e) {
  return $r(t2).put(function(t3, e2) {
    return {
      targetId: 0,
      path: ci(t3.path),
      sequenceNumber: e2
    };
  }(e, t2.currentSequenceNumber));
}
var Qr = class {
  constructor() {
    this.changes = new is((t2) => t2.toString(), (t2, e) => t2.isEqual(e)), this.changesApplied = false;
  }
  addEntry(t2) {
    this.assertNotApplied(), this.changes.set(t2.key, t2);
  }
  removeEntry(t2, e) {
    this.assertNotApplied(), this.changes.set(t2, xe.newInvalidDocument(t2).setReadTime(e));
  }
  getEntry(t2, e) {
    this.assertNotApplied();
    const n = this.changes.get(e);
    return n !== void 0 ? Pt.resolve(n) : this.getFromCache(t2, e);
  }
  getEntries(t2, e) {
    return this.getAllFromCache(t2, e);
  }
  apply(t2) {
    return this.assertNotApplied(), this.changesApplied = true, this.applyChanges(t2);
  }
  assertNotApplied() {
  }
};
var jr = class {
  constructor(t2) {
    this.wt = t2;
  }
  setIndexManager(t2) {
    this.indexManager = t2;
  }
  addEntry(t2, e, n) {
    return Jr(t2).put(n);
  }
  removeEntry(t2, e, n) {
    return Jr(t2).delete(function(t3, e2) {
      const n2 = t3.path.toArray();
      return [
        n2.slice(0, n2.length - 2),
        n2[n2.length - 2],
        Gi(e2),
        n2[n2.length - 1]
      ];
    }(e, n));
  }
  updateMetadata(t2, e) {
    return this.getMetadata(t2).next((n) => (n.byteSize += e, this.qn(t2, n)));
  }
  getEntry(t2, e) {
    let n = xe.newInvalidDocument(e);
    return Jr(t2).J({
      index: "documentKeyIndex",
      range: IDBKeyRange.only(Yr(e))
    }, (t3, s) => {
      n = this.Kn(e, s);
    }).next(() => n);
  }
  Gn(t2, e) {
    let n = {
      size: 0,
      document: xe.newInvalidDocument(e)
    };
    return Jr(t2).J({
      index: "documentKeyIndex",
      range: IDBKeyRange.only(Yr(e))
    }, (t3, s) => {
      n = {
        document: this.Kn(e, s),
        size: Vr(s)
      };
    }).next(() => n);
  }
  getEntries(t2, e) {
    let n = os();
    return this.Qn(t2, e, (t3, e2) => {
      const s = this.Kn(t3, e2);
      n = n.insert(t3, s);
    }).next(() => n);
  }
  jn(t2, e) {
    let n = os(), s = new qt(dt.comparator);
    return this.Qn(t2, e, (t3, e2) => {
      const i = this.Kn(t3, e2);
      n = n.insert(t3, i), s = s.insert(t3, Vr(e2));
    }).next(() => ({
      documents: n,
      Wn: s
    }));
  }
  Qn(t2, e, n) {
    if (e.isEmpty())
      return Pt.resolve();
    let s = new Qt(Zr);
    e.forEach((t3) => s = s.add(t3));
    const i = IDBKeyRange.bound(Yr(s.first()), Yr(s.last())), r = s.getIterator();
    let o = r.getNext();
    return Jr(t2).J({
      index: "documentKeyIndex",
      range: i
    }, (t3, e2, s2) => {
      const i2 = dt.fromSegments([...e2.prefixPath, e2.collectionGroup, e2.documentId]);
      for (; o && Zr(o, i2) < 0; )
        n(o, null), o = r.getNext();
      o && o.isEqual(i2) && (n(o, e2), o = r.hasNext() ? r.getNext() : null), o ? s2.q(Yr(o)) : s2.done();
    }).next(() => {
      for (; o; )
        n(o, null), o = r.hasNext() ? r.getNext() : null;
    });
  }
  getAllFromCollection(t2, e, n) {
    const s = [e.popLast().toArray(), e.lastSegment(), Gi(n.readTime), n.documentKey.path.isEmpty() ? "" : n.documentKey.path.lastSegment()], i = [e.popLast().toArray(), e.lastSegment(), [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], ""];
    return Jr(t2).K(IDBKeyRange.bound(s, i, true)).next((t3) => {
      let e2 = os();
      for (const n2 of t3) {
        const t4 = this.Kn(dt.fromSegments(n2.prefixPath.concat(n2.collectionGroup, n2.documentId)), n2);
        e2 = e2.insert(t4.key, t4);
      }
      return e2;
    });
  }
  getAllFromCollectionGroup(t2, e, n, s) {
    let i = os();
    const r = Xr(e, n), o = Xr(e, Tt.max());
    return Jr(t2).J({
      index: "collectionGroupIndex",
      range: IDBKeyRange.bound(r, o, true)
    }, (t3, e2, n2) => {
      const r2 = this.Kn(dt.fromSegments(e2.prefixPath.concat(e2.collectionGroup, e2.documentId)), e2);
      i = i.insert(r2.key, r2), i.size === s && n2.done();
    }).next(() => i);
  }
  newChangeBuffer(t2) {
    return new zr(this, !!t2 && t2.trackRemovals);
  }
  getSize(t2) {
    return this.getMetadata(t2).next((t3) => t3.byteSize);
  }
  getMetadata(t2) {
    return Hr(t2).get("remoteDocumentGlobalKey").next((t3) => (U2(!!t3), t3));
  }
  qn(t2, e) {
    return Hr(t2).put("remoteDocumentGlobalKey", e);
  }
  Kn(t2, e) {
    if (e) {
      const t3 = qi(this.wt, e);
      if (!(t3.isNoDocument() && t3.version.isEqual(ct.min())))
        return t3;
    }
    return xe.newInvalidDocument(t2);
  }
};
function Wr(t2) {
  return new jr(t2);
}
var zr = class extends Qr {
  constructor(t2, e) {
    super(), this.zn = t2, this.trackRemovals = e, this.Hn = new is((t3) => t3.toString(), (t3, e2) => t3.isEqual(e2));
  }
  applyChanges(t2) {
    const e = [];
    let n = 0, s = new Qt((t3, e2) => it(t3.canonicalString(), e2.canonicalString()));
    return this.changes.forEach((i, r) => {
      const o = this.Hn.get(i);
      if (e.push(this.zn.removeEntry(t2, i, o.readTime)), r.isValidDocument()) {
        const u = Ki(this.zn.wt, r);
        s = s.add(i.path.popLast());
        const c = Vr(u);
        n += c - o.size, e.push(this.zn.addEntry(t2, i, u));
      } else if (n -= o.size, this.trackRemovals) {
        const n2 = Ki(this.zn.wt, r.convertToNoDocument(ct.min()));
        e.push(this.zn.addEntry(t2, i, n2));
      }
    }), s.forEach((n2) => {
      e.push(this.zn.indexManager.addToCollectionParentIndex(t2, n2));
    }), e.push(this.zn.updateMetadata(t2, n)), Pt.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.zn.Gn(t2, e).next((t3) => (this.Hn.set(e, {
      size: t3.size,
      readTime: t3.document.readTime
    }), t3.document));
  }
  getAllFromCache(t2, e) {
    return this.zn.jn(t2, e).next(({ documents: t3, Wn: e2 }) => (e2.forEach((e3, n) => {
      this.Hn.set(e3, {
        size: n,
        readTime: t3.get(e3).readTime
      });
    }), t3));
  }
};
function Hr(t2) {
  return Mi(t2, "remoteDocumentGlobal");
}
function Jr(t2) {
  return Mi(t2, "remoteDocumentsV14");
}
function Yr(t2) {
  const e = t2.path.toArray();
  return [
    e.slice(0, e.length - 2),
    e[e.length - 2],
    e[e.length - 1]
  ];
}
function Xr(t2, e) {
  const n = e.documentKey.path.toArray();
  return [
    t2,
    Gi(e.readTime),
    n.slice(0, n.length - 2),
    n.length > 0 ? n[n.length - 1] : ""
  ];
}
function Zr(t2, e) {
  const n = t2.path.toArray(), s = e.path.toArray();
  let i = 0;
  for (let t3 = 0; t3 < n.length - 2 && t3 < s.length - 2; ++t3)
    if (i = it(n[t3], s[t3]), i)
      return i;
  return i = it(n.length, s.length), i || (i = it(n[n.length - 2], s[s.length - 2]), i || it(n[n.length - 1], s[s.length - 1]));
}
var to = class {
  constructor(t2, e) {
    this.overlayedDocument = t2, this.mutatedFields = e;
  }
};
var eo = class {
  constructor(t2, e, n, s) {
    this.remoteDocumentCache = t2, this.mutationQueue = e, this.documentOverlayCache = n, this.indexManager = s;
  }
  getDocument(t2, e) {
    let n = null;
    return this.documentOverlayCache.getOverlay(t2, e).next((s) => (n = s, this.getBaseDocument(t2, e, n))).next((t3) => (n !== null && Kn(n.mutation, t3, zt.empty(), ut.now()), t3));
  }
  getDocuments(t2, e) {
    return this.remoteDocumentCache.getEntries(t2, e).next((e2) => this.getLocalViewOfDocuments(t2, e2, ws()).next(() => e2));
  }
  getLocalViewOfDocuments(t2, e, n = ws()) {
    const s = hs();
    return this.populateOverlays(t2, s, e).next(() => this.computeViews(t2, e, s, n).next((t3) => {
      let e2 = cs();
      return t3.forEach((t4, n2) => {
        e2 = e2.insert(t4, n2.overlayedDocument);
      }), e2;
    }));
  }
  getOverlayedDocuments(t2, e) {
    const n = hs();
    return this.populateOverlays(t2, n, e).next(() => this.computeViews(t2, e, n, ws()));
  }
  populateOverlays(t2, e, n) {
    const s = [];
    return n.forEach((t3) => {
      e.has(t3) || s.push(t3);
    }), this.documentOverlayCache.getOverlays(t2, s).next((t3) => {
      t3.forEach((t4, n2) => {
        e.set(t4, n2);
      });
    });
  }
  computeViews(t2, e, n, s) {
    let i = os();
    const r = fs(), o = fs();
    return e.forEach((t3, e2) => {
      const o2 = n.get(e2.key);
      s.has(e2.key) && (o2 === void 0 || o2.mutation instanceof Wn) ? i = i.insert(e2.key, e2) : o2 !== void 0 && (r.set(e2.key, o2.mutation.getFieldMask()), Kn(o2.mutation, e2, o2.mutation.getFieldMask(), ut.now()));
    }), this.recalculateAndSaveOverlays(t2, i).next((t3) => (t3.forEach((t4, e2) => r.set(t4, e2)), e.forEach((t4, e2) => {
      var n2;
      return o.set(t4, new to(e2, (n2 = r.get(t4)) !== null && n2 !== void 0 ? n2 : null));
    }), o));
  }
  recalculateAndSaveOverlays(t2, e) {
    const n = fs();
    let s = new qt((t3, e2) => t3 - e2), i = ws();
    return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(t2, e).next((t3) => {
      for (const i2 of t3)
        i2.keys().forEach((t4) => {
          const r = e.get(t4);
          if (r === null)
            return;
          let o = n.get(t4) || zt.empty();
          o = i2.applyToLocalView(r, o), n.set(t4, o);
          const u = (s.get(i2.batchId) || ws()).add(t4);
          s = s.insert(i2.batchId, u);
        });
    }).next(() => {
      const r = [], o = s.getReverseIterator();
      for (; o.hasNext(); ) {
        const s2 = o.getNext(), u = s2.key, c = s2.value, a = ls();
        c.forEach((t3) => {
          if (!i.has(t3)) {
            const s3 = Un(e.get(t3), n.get(t3));
            s3 !== null && a.set(t3, s3), i = i.add(t3);
          }
        }), r.push(this.documentOverlayCache.saveOverlays(t2, u, a));
      }
      return Pt.waitFor(r);
    }).next(() => n);
  }
  recalculateAndSaveOverlaysForDocumentKeys(t2, e) {
    return this.remoteDocumentCache.getEntries(t2, e).next((e2) => this.recalculateAndSaveOverlays(t2, e2));
  }
  getDocumentsMatchingQuery(t2, e, n) {
    return function(t3) {
      return dt.isDocumentKey(t3.path) && t3.collectionGroup === null && t3.filters.length === 0;
    }(e) ? this.getDocumentsMatchingDocumentQuery(t2, e.path) : an(e) ? this.getDocumentsMatchingCollectionGroupQuery(t2, e, n) : this.getDocumentsMatchingCollectionQuery(t2, e, n);
  }
  getNextDocuments(t2, e, n, s) {
    return this.remoteDocumentCache.getAllFromCollectionGroup(t2, e, n, s).next((i) => {
      const r = s - i.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(t2, e, n.largestBatchId, s - i.size) : Pt.resolve(hs());
      let o = -1, u = i;
      return r.next((e2) => Pt.forEach(e2, (e3, n2) => (o < n2.largestBatchId && (o = n2.largestBatchId), i.get(e3) ? Pt.resolve() : this.getBaseDocument(t2, e3, n2).next((t3) => {
        u = u.insert(e3, t3);
      }))).next(() => this.populateOverlays(t2, e2, i)).next(() => this.computeViews(t2, u, e2, ws())).next((t3) => ({
        batchId: o,
        changes: as(t3)
      })));
    });
  }
  getDocumentsMatchingDocumentQuery(t2, e) {
    return this.getDocument(t2, new dt(e)).next((t3) => {
      let e2 = cs();
      return t3.isFoundDocument() && (e2 = e2.insert(t3.key, t3)), e2;
    });
  }
  getDocumentsMatchingCollectionGroupQuery(t2, e, n) {
    const s = e.collectionGroup;
    let i = cs();
    return this.indexManager.getCollectionParents(t2, s).next((r) => Pt.forEach(r, (r2) => {
      const o = function(t3, e2) {
        return new nn(e2, null, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
      }(e, r2.child(s));
      return this.getDocumentsMatchingCollectionQuery(t2, o, n).next((t3) => {
        t3.forEach((t4, e2) => {
          i = i.insert(t4, e2);
        });
      });
    }).next(() => i));
  }
  getDocumentsMatchingCollectionQuery(t2, e, n) {
    let s;
    return this.remoteDocumentCache.getAllFromCollection(t2, e.path, n).next((i) => (s = i, this.documentOverlayCache.getOverlaysForCollection(t2, e.path, n.largestBatchId))).next((t3) => {
      t3.forEach((t4, e2) => {
        const n3 = e2.getKey();
        s.get(n3) === null && (s = s.insert(n3, xe.newInvalidDocument(n3)));
      });
      let n2 = cs();
      return s.forEach((s2, i) => {
        const r = t3.get(s2);
        r !== void 0 && Kn(r.mutation, i, zt.empty(), ut.now()), mn(e, i) && (n2 = n2.insert(s2, i));
      }), n2;
    });
  }
  getBaseDocument(t2, e, n) {
    return n === null || n.mutation.type === 1 ? this.remoteDocumentCache.getEntry(t2, e) : Pt.resolve(xe.newInvalidDocument(e));
  }
};
var no = class {
  constructor(t2) {
    this.wt = t2, this.Jn = /* @__PURE__ */ new Map(), this.Yn = /* @__PURE__ */ new Map();
  }
  getBundleMetadata(t2, e) {
    return Pt.resolve(this.Jn.get(e));
  }
  saveBundleMetadata(t2, e) {
    var n;
    return this.Jn.set(e.id, {
      id: (n = e).id,
      version: n.version,
      createTime: Ns(n.createTime)
    }), Pt.resolve();
  }
  getNamedQuery(t2, e) {
    return Pt.resolve(this.Yn.get(e));
  }
  saveNamedQuery(t2, e) {
    return this.Yn.set(e.name, function(t3) {
      return {
        name: t3.name,
        query: Ji(t3.bundledQuery),
        readTime: Ns(t3.readTime)
      };
    }(e)), Pt.resolve();
  }
};
var so = class {
  constructor() {
    this.overlays = new qt(dt.comparator), this.Xn = /* @__PURE__ */ new Map();
  }
  getOverlay(t2, e) {
    return Pt.resolve(this.overlays.get(e));
  }
  getOverlays(t2, e) {
    const n = hs();
    return Pt.forEach(e, (e2) => this.getOverlay(t2, e2).next((t3) => {
      t3 !== null && n.set(e2, t3);
    })).next(() => n);
  }
  saveOverlays(t2, e, n) {
    return n.forEach((n2, s) => {
      this.ie(t2, e, s);
    }), Pt.resolve();
  }
  removeOverlaysForBatchId(t2, e, n) {
    const s = this.Xn.get(n);
    return s !== void 0 && (s.forEach((t3) => this.overlays = this.overlays.remove(t3)), this.Xn.delete(n)), Pt.resolve();
  }
  getOverlaysForCollection(t2, e, n) {
    const s = hs(), i = e.length + 1, r = new dt(e.child("")), o = this.overlays.getIteratorFrom(r);
    for (; o.hasNext(); ) {
      const t3 = o.getNext().value, r2 = t3.getKey();
      if (!e.isPrefixOf(r2.path))
        break;
      r2.path.length === i && (t3.largestBatchId > n && s.set(t3.getKey(), t3));
    }
    return Pt.resolve(s);
  }
  getOverlaysForCollectionGroup(t2, e, n, s) {
    let i = new qt((t3, e2) => t3 - e2);
    const r = this.overlays.getIterator();
    for (; r.hasNext(); ) {
      const t3 = r.getNext().value;
      if (t3.getKey().getCollectionGroup() === e && t3.largestBatchId > n) {
        let e2 = i.get(t3.largestBatchId);
        e2 === null && (e2 = hs(), i = i.insert(t3.largestBatchId, e2)), e2.set(t3.getKey(), t3);
      }
    }
    const o = hs(), u = i.getIterator();
    for (; u.hasNext(); ) {
      if (u.getNext().value.forEach((t3, e2) => o.set(t3, e2)), o.size() >= s)
        break;
    }
    return Pt.resolve(o);
  }
  ie(t2, e, n) {
    const s = this.overlays.get(n.key);
    if (s !== null) {
      const t3 = this.Xn.get(s.largestBatchId).delete(n.key);
      this.Xn.set(s.largestBatchId, t3);
    }
    this.overlays = this.overlays.insert(n.key, new Bi(e, n));
    let i = this.Xn.get(e);
    i === void 0 && (i = ws(), this.Xn.set(e, i)), this.Xn.set(e, i.add(n.key));
  }
};
var io = class {
  constructor() {
    this.Zn = new Qt(ro.ts), this.es = new Qt(ro.ns);
  }
  isEmpty() {
    return this.Zn.isEmpty();
  }
  addReference(t2, e) {
    const n = new ro(t2, e);
    this.Zn = this.Zn.add(n), this.es = this.es.add(n);
  }
  ss(t2, e) {
    t2.forEach((t3) => this.addReference(t3, e));
  }
  removeReference(t2, e) {
    this.rs(new ro(t2, e));
  }
  os(t2, e) {
    t2.forEach((t3) => this.removeReference(t3, e));
  }
  us(t2) {
    const e = new dt(new ht([])), n = new ro(e, t2), s = new ro(e, t2 + 1), i = [];
    return this.es.forEachInRange([n, s], (t3) => {
      this.rs(t3), i.push(t3.key);
    }), i;
  }
  cs() {
    this.Zn.forEach((t2) => this.rs(t2));
  }
  rs(t2) {
    this.Zn = this.Zn.delete(t2), this.es = this.es.delete(t2);
  }
  hs(t2) {
    const e = new dt(new ht([])), n = new ro(e, t2), s = new ro(e, t2 + 1);
    let i = ws();
    return this.es.forEachInRange([n, s], (t3) => {
      i = i.add(t3.key);
    }), i;
  }
  containsKey(t2) {
    const e = new ro(t2, 0), n = this.Zn.firstAfterOrEqual(e);
    return n !== null && t2.isEqual(n.key);
  }
};
var ro = class {
  constructor(t2, e) {
    this.key = t2, this.ls = e;
  }
  static ts(t2, e) {
    return dt.comparator(t2.key, e.key) || it(t2.ls, e.ls);
  }
  static ns(t2, e) {
    return it(t2.ls, e.ls) || dt.comparator(t2.key, e.key);
  }
};
var oo = class {
  constructor(t2, e) {
    this.indexManager = t2, this.referenceDelegate = e, this.mutationQueue = [], this.fs = 1, this.ds = new Qt(ro.ts);
  }
  checkEmpty(t2) {
    return Pt.resolve(this.mutationQueue.length === 0);
  }
  addMutationBatch(t2, e, n, s) {
    const i = this.fs;
    this.fs++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1];
    const r = new Fi(i, e, n, s);
    this.mutationQueue.push(r);
    for (const e2 of s)
      this.ds = this.ds.add(new ro(e2.key, i)), this.indexManager.addToCollectionParentIndex(t2, e2.key.path.popLast());
    return Pt.resolve(r);
  }
  lookupMutationBatch(t2, e) {
    return Pt.resolve(this._s(e));
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = this.ws(n), i = s < 0 ? 0 : s;
    return Pt.resolve(this.mutationQueue.length > i ? this.mutationQueue[i] : null);
  }
  getHighestUnacknowledgedBatchId() {
    return Pt.resolve(this.mutationQueue.length === 0 ? -1 : this.fs - 1);
  }
  getAllMutationBatches(t2) {
    return Pt.resolve(this.mutationQueue.slice());
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = new ro(e, 0), s = new ro(e, Number.POSITIVE_INFINITY), i = [];
    return this.ds.forEachInRange([n, s], (t3) => {
      const e2 = this._s(t3.ls);
      i.push(e2);
    }), Pt.resolve(i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new Qt(it);
    return e.forEach((t3) => {
      const e2 = new ro(t3, 0), s = new ro(t3, Number.POSITIVE_INFINITY);
      this.ds.forEachInRange([e2, s], (t4) => {
        n = n.add(t4.ls);
      });
    }), Pt.resolve(this.gs(n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1;
    let i = n;
    dt.isDocumentKey(i) || (i = i.child(""));
    const r = new ro(new dt(i), 0);
    let o = new Qt(it);
    return this.ds.forEachWhile((t3) => {
      const e2 = t3.key.path;
      return !!n.isPrefixOf(e2) && (e2.length === s && (o = o.add(t3.ls)), true);
    }, r), Pt.resolve(this.gs(o));
  }
  gs(t2) {
    const e = [];
    return t2.forEach((t3) => {
      const n = this._s(t3);
      n !== null && e.push(n);
    }), e;
  }
  removeMutationBatch(t2, e) {
    U2(this.ys(e.batchId, "removed") === 0), this.mutationQueue.shift();
    let n = this.ds;
    return Pt.forEach(e.mutations, (s) => {
      const i = new ro(s.key, e.batchId);
      return n = n.delete(i), this.referenceDelegate.markPotentiallyOrphaned(t2, s.key);
    }).next(() => {
      this.ds = n;
    });
  }
  In(t2) {
  }
  containsKey(t2, e) {
    const n = new ro(e, 0), s = this.ds.firstAfterOrEqual(n);
    return Pt.resolve(e.isEqual(s && s.key));
  }
  performConsistencyCheck(t2) {
    return this.mutationQueue.length, Pt.resolve();
  }
  ys(t2, e) {
    return this.ws(t2);
  }
  ws(t2) {
    if (this.mutationQueue.length === 0)
      return 0;
    return t2 - this.mutationQueue[0].batchId;
  }
  _s(t2) {
    const e = this.ws(t2);
    if (e < 0 || e >= this.mutationQueue.length)
      return null;
    return this.mutationQueue[e];
  }
};
var uo = class {
  constructor(t2) {
    this.ps = t2, this.docs = new qt(dt.comparator), this.size = 0;
  }
  setIndexManager(t2) {
    this.indexManager = t2;
  }
  addEntry(t2, e) {
    const n = e.key, s = this.docs.get(n), i = s ? s.size : 0, r = this.ps(e);
    return this.docs = this.docs.insert(n, {
      document: e.mutableCopy(),
      size: r
    }), this.size += r - i, this.indexManager.addToCollectionParentIndex(t2, n.path.popLast());
  }
  removeEntry(t2) {
    const e = this.docs.get(t2);
    e && (this.docs = this.docs.remove(t2), this.size -= e.size);
  }
  getEntry(t2, e) {
    const n = this.docs.get(e);
    return Pt.resolve(n ? n.document.mutableCopy() : xe.newInvalidDocument(e));
  }
  getEntries(t2, e) {
    let n = os();
    return e.forEach((t3) => {
      const e2 = this.docs.get(t3);
      n = n.insert(t3, e2 ? e2.document.mutableCopy() : xe.newInvalidDocument(t3));
    }), Pt.resolve(n);
  }
  getAllFromCollection(t2, e, n) {
    let s = os();
    const i = new dt(e.child("")), r = this.docs.getIteratorFrom(i);
    for (; r.hasNext(); ) {
      const { key: t3, value: { document: i2 } } = r.getNext();
      if (!e.isPrefixOf(t3.path))
        break;
      t3.path.length > e.length + 1 || (Et(It(i2), n) <= 0 || (s = s.insert(i2.key, i2.mutableCopy())));
    }
    return Pt.resolve(s);
  }
  getAllFromCollectionGroup(t2, e, n, s) {
    L2();
  }
  Is(t2, e) {
    return Pt.forEach(this.docs, (t3) => e(t3));
  }
  newChangeBuffer(t2) {
    return new co(this);
  }
  getSize(t2) {
    return Pt.resolve(this.size);
  }
};
var co = class extends Qr {
  constructor(t2) {
    super(), this.zn = t2;
  }
  applyChanges(t2) {
    const e = [];
    return this.changes.forEach((n, s) => {
      s.isValidDocument() ? e.push(this.zn.addEntry(t2, s)) : this.zn.removeEntry(n);
    }), Pt.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.zn.getEntry(t2, e);
  }
  getAllFromCache(t2, e) {
    return this.zn.getEntries(t2, e);
  }
};
var ao = class {
  constructor(t2) {
    this.persistence = t2, this.Ts = new is((t3) => Oe(t3), Fe), this.lastRemoteSnapshotVersion = ct.min(), this.highestTargetId = 0, this.Es = 0, this.As = new io(), this.targetCount = 0, this.Rs = kr.An();
  }
  forEachTarget(t2, e) {
    return this.Ts.forEach((t3, n) => e(n)), Pt.resolve();
  }
  getLastRemoteSnapshotVersion(t2) {
    return Pt.resolve(this.lastRemoteSnapshotVersion);
  }
  getHighestSequenceNumber(t2) {
    return Pt.resolve(this.Es);
  }
  allocateTargetId(t2) {
    return this.highestTargetId = this.Rs.next(), Pt.resolve(this.highestTargetId);
  }
  setTargetsMetadata(t2, e, n) {
    return n && (this.lastRemoteSnapshotVersion = n), e > this.Es && (this.Es = e), Pt.resolve();
  }
  vn(t2) {
    this.Ts.set(t2.target, t2);
    const e = t2.targetId;
    e > this.highestTargetId && (this.Rs = new kr(e), this.highestTargetId = e), t2.sequenceNumber > this.Es && (this.Es = t2.sequenceNumber);
  }
  addTargetData(t2, e) {
    return this.vn(e), this.targetCount += 1, Pt.resolve();
  }
  updateTargetData(t2, e) {
    return this.vn(e), Pt.resolve();
  }
  removeTargetData(t2, e) {
    return this.Ts.delete(e.target), this.As.us(e.targetId), this.targetCount -= 1, Pt.resolve();
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return this.Ts.forEach((r, o) => {
      o.sequenceNumber <= e && n.get(o.targetId) === null && (this.Ts.delete(r), i.push(this.removeMatchingKeysForTargetId(t2, o.targetId)), s++);
    }), Pt.waitFor(i).next(() => s);
  }
  getTargetCount(t2) {
    return Pt.resolve(this.targetCount);
  }
  getTargetData(t2, e) {
    const n = this.Ts.get(e) || null;
    return Pt.resolve(n);
  }
  addMatchingKeys(t2, e, n) {
    return this.As.ss(e, n), Pt.resolve();
  }
  removeMatchingKeys(t2, e, n) {
    this.As.os(e, n);
    const s = this.persistence.referenceDelegate, i = [];
    return s && e.forEach((e2) => {
      i.push(s.markPotentiallyOrphaned(t2, e2));
    }), Pt.waitFor(i);
  }
  removeMatchingKeysForTargetId(t2, e) {
    return this.As.us(e), Pt.resolve();
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = this.As.hs(e);
    return Pt.resolve(n);
  }
  containsKey(t2, e) {
    return Pt.resolve(this.As.containsKey(e));
  }
};
var ho = class {
  constructor(t2, e) {
    this.bs = {}, this.overlays = {}, this.Ps = new $t(0), this.vs = false, this.vs = true, this.referenceDelegate = t2(this), this.Vs = new ao(this);
    this.indexManager = new mr(), this.remoteDocumentCache = function(t3) {
      return new uo(t3);
    }((t3) => this.referenceDelegate.Ss(t3)), this.wt = new Ui(e), this.Ds = new no(this.wt);
  }
  start() {
    return Promise.resolve();
  }
  shutdown() {
    return this.vs = false, Promise.resolve();
  }
  get started() {
    return this.vs;
  }
  setDatabaseDeletedListener() {
  }
  setNetworkEnabled() {
  }
  getIndexManager(t2) {
    return this.indexManager;
  }
  getDocumentOverlayCache(t2) {
    let e = this.overlays[t2.toKey()];
    return e || (e = new so(), this.overlays[t2.toKey()] = e), e;
  }
  getMutationQueue(t2, e) {
    let n = this.bs[t2.toKey()];
    return n || (n = new oo(e, this.referenceDelegate), this.bs[t2.toKey()] = n), n;
  }
  getTargetCache() {
    return this.Vs;
  }
  getRemoteDocumentCache() {
    return this.remoteDocumentCache;
  }
  getBundleCache() {
    return this.Ds;
  }
  runTransaction(t2, e, n) {
    M2("MemoryPersistence", "Starting transaction:", t2);
    const s = new lo(this.Ps.next());
    return this.referenceDelegate.Cs(), n(s).next((t3) => this.referenceDelegate.xs(s).next(() => t3)).toPromise().then((t3) => (s.raiseOnCommittedEvent(), t3));
  }
  Ns(t2, e) {
    return Pt.or(Object.values(this.bs).map((n) => () => n.containsKey(t2, e)));
  }
};
var lo = class extends Rt {
  constructor(t2) {
    super(), this.currentSequenceNumber = t2;
  }
};
var fo = class {
  constructor(t2) {
    this.persistence = t2, this.ks = new io(), this.Os = null;
  }
  static Ms(t2) {
    return new fo(t2);
  }
  get Fs() {
    if (this.Os)
      return this.Os;
    throw L2();
  }
  addReference(t2, e, n) {
    return this.ks.addReference(n, e), this.Fs.delete(n.toString()), Pt.resolve();
  }
  removeReference(t2, e, n) {
    return this.ks.removeReference(n, e), this.Fs.add(n.toString()), Pt.resolve();
  }
  markPotentiallyOrphaned(t2, e) {
    return this.Fs.add(e.toString()), Pt.resolve();
  }
  removeTarget(t2, e) {
    this.ks.us(e.targetId).forEach((t3) => this.Fs.add(t3.toString()));
    const n = this.persistence.getTargetCache();
    return n.getMatchingKeysForTargetId(t2, e.targetId).next((t3) => {
      t3.forEach((t4) => this.Fs.add(t4.toString()));
    }).next(() => n.removeTargetData(t2, e));
  }
  Cs() {
    this.Os = /* @__PURE__ */ new Set();
  }
  xs(t2) {
    const e = this.persistence.getRemoteDocumentCache().newChangeBuffer();
    return Pt.forEach(this.Fs, (n) => {
      const s = dt.fromPath(n);
      return this.$s(t2, s).next((t3) => {
        t3 || e.removeEntry(s, ct.min());
      });
    }).next(() => (this.Os = null, e.apply(t2)));
  }
  updateLimboDocument(t2, e) {
    return this.$s(t2, e).next((t3) => {
      t3 ? this.Fs.delete(e.toString()) : this.Fs.add(e.toString());
    });
  }
  Ss(t2) {
    return 0;
  }
  $s(t2, e) {
    return Pt.or([() => Pt.resolve(this.ks.containsKey(e)), () => this.persistence.getTargetCache().containsKey(t2, e), () => this.persistence.Ns(t2, e)]);
  }
};
var _o = class {
  constructor(t2) {
    this.wt = t2;
  }
  O(t2, e, n, s) {
    const i = new vt("createOrUpgrade", e);
    n < 1 && s >= 1 && (function(t3) {
      t3.createObjectStore("owner");
    }(t2), function(t3) {
      t3.createObjectStore("mutationQueues", {
        keyPath: "userId"
      });
      t3.createObjectStore("mutations", {
        keyPath: "batchId",
        autoIncrement: true
      }).createIndex("userMutationsIndex", fi, {
        unique: true
      }), t3.createObjectStore("documentMutations");
    }(t2), wo(t2), function(t3) {
      t3.createObjectStore("remoteDocuments");
    }(t2));
    let r = Pt.resolve();
    return n < 3 && s >= 3 && (n !== 0 && (!function(t3) {
      t3.deleteObjectStore("targetDocuments"), t3.deleteObjectStore("targets"), t3.deleteObjectStore("targetGlobal");
    }(t2), wo(t2)), r = r.next(() => function(t3) {
      const e2 = t3.store("targetGlobal"), n2 = {
        highestTargetId: 0,
        highestListenSequenceNumber: 0,
        lastRemoteSnapshotVersion: ct.min().toTimestamp(),
        targetCount: 0
      };
      return e2.put("targetGlobalKey", n2);
    }(i))), n < 4 && s >= 4 && (n !== 0 && (r = r.next(() => function(t3, e2) {
      return e2.store("mutations").K().next((n2) => {
        t3.deleteObjectStore("mutations");
        t3.createObjectStore("mutations", {
          keyPath: "batchId",
          autoIncrement: true
        }).createIndex("userMutationsIndex", fi, {
          unique: true
        });
        const s2 = e2.store("mutations"), i2 = n2.map((t4) => s2.put(t4));
        return Pt.waitFor(i2);
      });
    }(t2, i))), r = r.next(() => {
      !function(t3) {
        t3.createObjectStore("clientMetadata", {
          keyPath: "clientId"
        });
      }(t2);
    })), n < 5 && s >= 5 && (r = r.next(() => this.Bs(i))), n < 6 && s >= 6 && (r = r.next(() => (function(t3) {
      t3.createObjectStore("remoteDocumentGlobal");
    }(t2), this.Ls(i)))), n < 7 && s >= 7 && (r = r.next(() => this.Us(i))), n < 8 && s >= 8 && (r = r.next(() => this.qs(t2, i))), n < 9 && s >= 9 && (r = r.next(() => {
      !function(t3) {
        t3.objectStoreNames.contains("remoteDocumentChanges") && t3.deleteObjectStore("remoteDocumentChanges");
      }(t2);
    })), n < 10 && s >= 10 && (r = r.next(() => this.Ks(i))), n < 11 && s >= 11 && (r = r.next(() => {
      !function(t3) {
        t3.createObjectStore("bundles", {
          keyPath: "bundleId"
        });
      }(t2), function(t3) {
        t3.createObjectStore("namedQueries", {
          keyPath: "name"
        });
      }(t2);
    })), n < 12 && s >= 12 && (r = r.next(() => {
      !function(t3) {
        const e2 = t3.createObjectStore("documentOverlays", {
          keyPath: vi
        });
        e2.createIndex("collectionPathOverlayIndex", Vi, {
          unique: false
        }), e2.createIndex("collectionGroupOverlayIndex", Si, {
          unique: false
        });
      }(t2);
    })), n < 13 && s >= 13 && (r = r.next(() => function(t3) {
      const e2 = t3.createObjectStore("remoteDocumentsV14", {
        keyPath: mi
      });
      e2.createIndex("documentKeyIndex", gi), e2.createIndex("collectionGroupIndex", yi);
    }(t2)).next(() => this.Gs(t2, i)).next(() => t2.deleteObjectStore("remoteDocuments"))), n < 14 && s >= 14 && (r = r.next(() => this.Qs(t2, i))), n < 15 && s >= 15 && (r = r.next(() => function(t3) {
      t3.createObjectStore("indexConfiguration", {
        keyPath: "indexId",
        autoIncrement: true
      }).createIndex("collectionGroupIndex", "collectionGroup", {
        unique: false
      });
      t3.createObjectStore("indexState", {
        keyPath: Ai
      }).createIndex("sequenceNumberIndex", Ri, {
        unique: false
      });
      t3.createObjectStore("indexEntries", {
        keyPath: bi
      }).createIndex("documentKeyIndex", Pi, {
        unique: false
      });
    }(t2))), r;
  }
  Ls(t2) {
    let e = 0;
    return t2.store("remoteDocuments").J((t3, n) => {
      e += Vr(n);
    }).next(() => {
      const n = {
        byteSize: e
      };
      return t2.store("remoteDocumentGlobal").put("remoteDocumentGlobalKey", n);
    });
  }
  Bs(t2) {
    const e = t2.store("mutationQueues"), n = t2.store("mutations");
    return e.K().next((e2) => Pt.forEach(e2, (e3) => {
      const s = IDBKeyRange.bound([e3.userId, -1], [e3.userId, e3.lastAcknowledgedBatchId]);
      return n.K("userMutationsIndex", s).next((n2) => Pt.forEach(n2, (n3) => {
        U2(n3.userId === e3.userId);
        const s2 = Wi(this.wt, n3);
        return vr(t2, e3.userId, s2).next(() => {
        });
      }));
    }));
  }
  Us(t2) {
    const e = t2.store("targetDocuments"), n = t2.store("remoteDocuments");
    return t2.store("targetGlobal").get("targetGlobalKey").next((t3) => {
      const s = [];
      return n.J((n2, i) => {
        const r = new ht(n2), o = function(t4) {
          return [0, ci(t4)];
        }(r);
        s.push(e.get(o).next((n3) => n3 ? Pt.resolve() : ((n4) => e.put({
          targetId: 0,
          path: ci(n4),
          sequenceNumber: t3.highestListenSequenceNumber
        }))(r)));
      }).next(() => Pt.waitFor(s));
    });
  }
  qs(t2, e) {
    t2.createObjectStore("collectionParents", {
      keyPath: Ei
    });
    const n = e.store("collectionParents"), s = new gr(), i = (t3) => {
      if (s.add(t3)) {
        const e2 = t3.lastSegment(), s2 = t3.popLast();
        return n.put({
          collectionId: e2,
          parent: ci(s2)
        });
      }
    };
    return e.store("remoteDocuments").J({
      H: true
    }, (t3, e2) => {
      const n2 = new ht(t3);
      return i(n2.popLast());
    }).next(() => e.store("documentMutations").J({
      H: true
    }, ([t3, e2, n2], s2) => {
      const r = li(e2);
      return i(r.popLast());
    }));
  }
  Ks(t2) {
    const e = t2.store("targets");
    return e.J((t3, n) => {
      const s = zi(n), i = Hi(this.wt, s);
      return e.put(i);
    });
  }
  Gs(t2, e) {
    const n = e.store("remoteDocuments"), s = [];
    return n.J((t3, n2) => {
      const i = e.store("remoteDocumentsV14"), r = (o = n2, o.document ? new dt(ht.fromString(o.document.name).popFirst(5)) : o.noDocument ? dt.fromSegments(o.noDocument.path) : o.unknownDocument ? dt.fromSegments(o.unknownDocument.path) : L2()).path.toArray();
      var o;
      const u = {
        prefixPath: r.slice(0, r.length - 2),
        collectionGroup: r[r.length - 2],
        documentId: r[r.length - 1],
        readTime: n2.readTime || [0, 0],
        unknownDocument: n2.unknownDocument,
        noDocument: n2.noDocument,
        document: n2.document,
        hasCommittedMutations: !!n2.hasCommittedMutations
      };
      s.push(i.put(u));
    }).next(() => Pt.waitFor(s));
  }
  Qs(t2, e) {
    const n = e.store("mutations"), s = Wr(this.wt), i = new ho(fo.Ms, this.wt.ne);
    return n.K().next((t3) => {
      const n2 = /* @__PURE__ */ new Map();
      return t3.forEach((t4) => {
        var e2;
        let s2 = (e2 = n2.get(t4.userId)) !== null && e2 !== void 0 ? e2 : ws();
        Wi(this.wt, t4).keys().forEach((t5) => s2 = s2.add(t5)), n2.set(t4.userId, s2);
      }), Pt.forEach(n2, (t4, n3) => {
        const r = new C2(n3), o = sr.se(this.wt, r), u = i.getIndexManager(r), c = Sr.se(r, this.wt, u, i.referenceDelegate);
        return new eo(s, c, o, u).recalculateAndSaveOverlaysForDocumentKeys(new Oi(e, $t.ot), t4).next();
      });
    });
  }
};
function wo(t2) {
  t2.createObjectStore("targetDocuments", {
    keyPath: Ii
  }).createIndex("documentTargetsIndex", Ti, {
    unique: true
  });
  t2.createObjectStore("targets", {
    keyPath: "targetId"
  }).createIndex("queryTargetsIndex", pi, {
    unique: true
  }), t2.createObjectStore("targetGlobal");
}
var mo = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.";
var go = class {
  constructor(t2, e, n, s, i, r, o, u, c, a, h = 14) {
    if (this.allowTabSynchronization = t2, this.persistenceKey = e, this.clientId = n, this.js = i, this.window = r, this.document = o, this.Ws = c, this.zs = a, this.Hs = h, this.Ps = null, this.vs = false, this.isPrimary = false, this.networkEnabled = true, this.Js = null, this.inForeground = false, this.Ys = null, this.Xs = null, this.Zs = Number.NEGATIVE_INFINITY, this.ti = (t3) => Promise.resolve(), !go.V())
      throw new Q2(G.UNIMPLEMENTED, "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.");
    this.referenceDelegate = new Kr(this, s), this.ei = e + "main", this.wt = new Ui(u), this.ni = new Vt(this.ei, this.Hs, new _o(this.wt)), this.Vs = new Or(this.referenceDelegate, this.wt), this.remoteDocumentCache = Wr(this.wt), this.Ds = new tr(), this.window && this.window.localStorage ? this.si = this.window.localStorage : (this.si = null, a === false && F2("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page."));
  }
  start() {
    return this.ii().then(() => {
      if (!this.isPrimary && !this.allowTabSynchronization)
        throw new Q2(G.FAILED_PRECONDITION, mo);
      return this.ri(), this.oi(), this.ui(), this.runTransaction("getHighestListenSequenceNumber", "readonly", (t2) => this.Vs.getHighestSequenceNumber(t2));
    }).then((t2) => {
      this.Ps = new $t(t2, this.Ws);
    }).then(() => {
      this.vs = true;
    }).catch((t2) => (this.ni && this.ni.close(), Promise.reject(t2)));
  }
  ci(t2) {
    return this.ti = async (e) => {
      if (this.started)
        return t2(e);
    }, t2(this.isPrimary);
  }
  setDatabaseDeletedListener(t2) {
    this.ni.F(async (e) => {
      e.newVersion === null && await t2();
    });
  }
  setNetworkEnabled(t2) {
    this.networkEnabled !== t2 && (this.networkEnabled = t2, this.js.enqueueAndForget(async () => {
      this.started && await this.ii();
    }));
  }
  ii() {
    return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", (t2) => po(t2).put({
      clientId: this.clientId,
      updateTimeMs: Date.now(),
      networkEnabled: this.networkEnabled,
      inForeground: this.inForeground
    }).next(() => {
      if (this.isPrimary)
        return this.ai(t2).next((t3) => {
          t3 || (this.isPrimary = false, this.js.enqueueRetryable(() => this.ti(false)));
        });
    }).next(() => this.hi(t2)).next((e) => this.isPrimary && !e ? this.li(t2).next(() => false) : !!e && this.fi(t2).next(() => true))).catch((t2) => {
      if (Ct(t2))
        return M2("IndexedDbPersistence", "Failed to extend owner lease: ", t2), this.isPrimary;
      if (!this.allowTabSynchronization)
        throw t2;
      return M2("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", t2), false;
    }).then((t2) => {
      this.isPrimary !== t2 && this.js.enqueueRetryable(() => this.ti(t2)), this.isPrimary = t2;
    });
  }
  ai(t2) {
    return yo(t2).get("owner").next((t3) => Pt.resolve(this.di(t3)));
  }
  _i(t2) {
    return po(t2).delete(this.clientId);
  }
  async wi() {
    if (this.isPrimary && !this.mi(this.Zs, 18e5)) {
      this.Zs = Date.now();
      const t2 = await this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", (t3) => {
        const e = Mi(t3, "clientMetadata");
        return e.K().next((t4) => {
          const n = this.gi(t4, 18e5), s = t4.filter((t5) => n.indexOf(t5) === -1);
          return Pt.forEach(s, (t5) => e.delete(t5.clientId)).next(() => s);
        });
      }).catch(() => []);
      if (this.si)
        for (const e of t2)
          this.si.removeItem(this.yi(e.clientId));
    }
  }
  ui() {
    this.Xs = this.js.enqueueAfterDelay("client_metadata_refresh", 4e3, () => this.ii().then(() => this.wi()).then(() => this.ui()));
  }
  di(t2) {
    return !!t2 && t2.ownerId === this.clientId;
  }
  hi(t2) {
    if (this.zs)
      return Pt.resolve(true);
    return yo(t2).get("owner").next((e) => {
      if (e !== null && this.mi(e.leaseTimestampMs, 5e3) && !this.pi(e.ownerId)) {
        if (this.di(e) && this.networkEnabled)
          return true;
        if (!this.di(e)) {
          if (!e.allowTabSynchronization)
            throw new Q2(G.FAILED_PRECONDITION, mo);
          return false;
        }
      }
      return !(!this.networkEnabled || !this.inForeground) || po(t2).K().next((t3) => this.gi(t3, 5e3).find((t4) => {
        if (this.clientId !== t4.clientId) {
          const e2 = !this.networkEnabled && t4.networkEnabled, n = !this.inForeground && t4.inForeground, s = this.networkEnabled === t4.networkEnabled;
          if (e2 || n && s)
            return true;
        }
        return false;
      }) === void 0);
    }).next((t3) => (this.isPrimary !== t3 && M2("IndexedDbPersistence", `Client ${t3 ? "is" : "is not"} eligible for a primary lease.`), t3));
  }
  async shutdown() {
    this.vs = false, this.Ii(), this.Xs && (this.Xs.cancel(), this.Xs = null), this.Ti(), this.Ei(), await this.ni.runTransaction("shutdown", "readwrite", ["owner", "clientMetadata"], (t2) => {
      const e = new Oi(t2, $t.ot);
      return this.li(e).next(() => this._i(e));
    }), this.ni.close(), this.Ai();
  }
  gi(t2, e) {
    return t2.filter((t3) => this.mi(t3.updateTimeMs, e) && !this.pi(t3.clientId));
  }
  Ri() {
    return this.runTransaction("getActiveClients", "readonly", (t2) => po(t2).K().next((t3) => this.gi(t3, 18e5).map((t4) => t4.clientId)));
  }
  get started() {
    return this.vs;
  }
  getMutationQueue(t2, e) {
    return Sr.se(t2, this.wt, e, this.referenceDelegate);
  }
  getTargetCache() {
    return this.Vs;
  }
  getRemoteDocumentCache() {
    return this.remoteDocumentCache;
  }
  getIndexManager(t2) {
    return new pr(t2, this.wt.ne.databaseId);
  }
  getDocumentOverlayCache(t2) {
    return sr.se(this.wt, t2);
  }
  getBundleCache() {
    return this.Ds;
  }
  runTransaction(t2, e, n) {
    M2("IndexedDbPersistence", "Starting transaction:", t2);
    const s = e === "readonly" ? "readonly" : "readwrite", i = (r = this.Hs) === 15 ? ki : r === 14 ? Ni : r === 13 ? xi : r === 12 ? Ci : r === 11 ? Di : void L2();
    var r;
    let o;
    return this.ni.runTransaction(t2, s, i, (s2) => (o = new Oi(s2, this.Ps ? this.Ps.next() : $t.ot), e === "readwrite-primary" ? this.ai(o).next((t3) => !!t3 || this.hi(o)).next((e2) => {
      if (!e2)
        throw F2(`Failed to obtain primary lease for action '${t2}'.`), this.isPrimary = false, this.js.enqueueRetryable(() => this.ti(false)), new Q2(G.FAILED_PRECONDITION, At);
      return n(o);
    }).next((t3) => this.fi(o).next(() => t3)) : this.bi(o).next(() => n(o)))).then((t3) => (o.raiseOnCommittedEvent(), t3));
  }
  bi(t2) {
    return yo(t2).get("owner").next((t3) => {
      if (t3 !== null && this.mi(t3.leaseTimestampMs, 5e3) && !this.pi(t3.ownerId) && !this.di(t3) && !(this.zs || this.allowTabSynchronization && t3.allowTabSynchronization))
        throw new Q2(G.FAILED_PRECONDITION, mo);
    });
  }
  fi(t2) {
    const e = {
      ownerId: this.clientId,
      allowTabSynchronization: this.allowTabSynchronization,
      leaseTimestampMs: Date.now()
    };
    return yo(t2).put("owner", e);
  }
  static V() {
    return Vt.V();
  }
  li(t2) {
    const e = yo(t2);
    return e.get("owner").next((t3) => this.di(t3) ? (M2("IndexedDbPersistence", "Releasing primary lease."), e.delete("owner")) : Pt.resolve());
  }
  mi(t2, e) {
    const n = Date.now();
    return !(t2 < n - e) && (!(t2 > n) || (F2(`Detected an update time that is in the future: ${t2} > ${n}`), false));
  }
  ri() {
    this.document !== null && typeof this.document.addEventListener == "function" && (this.Ys = () => {
      this.js.enqueueAndForget(() => (this.inForeground = this.document.visibilityState === "visible", this.ii()));
    }, this.document.addEventListener("visibilitychange", this.Ys), this.inForeground = this.document.visibilityState === "visible");
  }
  Ti() {
    this.Ys && (this.document.removeEventListener("visibilitychange", this.Ys), this.Ys = null);
  }
  oi() {
    var t2;
    typeof ((t2 = this.window) === null || t2 === void 0 ? void 0 : t2.addEventListener) == "function" && (this.Js = () => {
      this.Ii(), isSafari() && navigator.appVersion.match(/Version\/1[45]/) && this.js.enterRestrictedMode(true), this.js.enqueueAndForget(() => this.shutdown());
    }, this.window.addEventListener("pagehide", this.Js));
  }
  Ei() {
    this.Js && (this.window.removeEventListener("pagehide", this.Js), this.Js = null);
  }
  pi(t2) {
    var e;
    try {
      const n = ((e = this.si) === null || e === void 0 ? void 0 : e.getItem(this.yi(t2))) !== null;
      return M2("IndexedDbPersistence", `Client '${t2}' ${n ? "is" : "is not"} zombied in LocalStorage`), n;
    } catch (t3) {
      return F2("IndexedDbPersistence", "Failed to get zombied client id.", t3), false;
    }
  }
  Ii() {
    if (this.si)
      try {
        this.si.setItem(this.yi(this.clientId), String(Date.now()));
      } catch (t2) {
        F2("Failed to set zombie client id.", t2);
      }
  }
  Ai() {
    if (this.si)
      try {
        this.si.removeItem(this.yi(this.clientId));
      } catch (t2) {
      }
  }
  yi(t2) {
    return `firestore_zombie_${this.persistenceKey}_${t2}`;
  }
};
function yo(t2) {
  return Mi(t2, "owner");
}
function po(t2) {
  return Mi(t2, "clientMetadata");
}
function Io(t2, e) {
  let n = t2.projectId;
  return t2.isDefaultDatabase || (n += "." + t2.database), "firestore/" + e + "/" + n + "/";
}
var To = class {
  constructor(t2, e, n, s) {
    this.targetId = t2, this.fromCache = e, this.Pi = n, this.vi = s;
  }
  static Vi(t2, e) {
    let n = ws(), s = ws();
    for (const t3 of e.docChanges)
      switch (t3.type) {
        case 0:
          n = n.add(t3.doc.key);
          break;
        case 1:
          s = s.add(t3.doc.key);
      }
    return new To(t2, e.fromCache, n, s);
  }
};
var Eo = class {
  constructor() {
    this.Si = false;
  }
  initialize(t2, e) {
    this.Di = t2, this.indexManager = e, this.Si = true;
  }
  getDocumentsMatchingQuery(t2, e, n, s) {
    return this.Ci(t2, e).next((i) => i || this.xi(t2, e, s, n)).next((n2) => n2 || this.Ni(t2, e));
  }
  Ci(t2, e) {
    return Pt.resolve(null);
  }
  xi(t2, e, n, s) {
    return on(e) || s.isEqual(ct.min()) ? this.Ni(t2, e) : this.Di.getDocuments(t2, n).next((i) => {
      const r = this.ki(e, i);
      return this.Oi(e, r, n, s) ? this.Ni(t2, e) : (k2() <= LogLevel.DEBUG && M2("QueryEngine", "Re-using previous result from %s to execute query: %s", s.toString(), wn(e)), this.Mi(t2, r, e, pt(s, -1)));
    });
  }
  ki(t2, e) {
    let n = new Qt(yn(t2));
    return e.forEach((e2, s) => {
      mn(t2, s) && (n = n.add(s));
    }), n;
  }
  Oi(t2, e, n, s) {
    if (t2.limit === null)
      return false;
    if (n.size !== e.size)
      return true;
    const i = t2.limitType === "F" ? e.last() : e.first();
    return !!i && (i.hasPendingWrites || i.version.compareTo(s) > 0);
  }
  Ni(t2, e) {
    return k2() <= LogLevel.DEBUG && M2("QueryEngine", "Using full collection scan to execute query:", wn(e)), this.Di.getDocumentsMatchingQuery(t2, e, Tt.min());
  }
  Mi(t2, e, n, s) {
    return this.Di.getDocumentsMatchingQuery(t2, n, s).next((t3) => (e.forEach((e2) => {
      t3 = t3.insert(e2.key, e2);
    }), t3));
  }
};
var Ao = class {
  constructor(t2, e, n, s) {
    this.persistence = t2, this.Fi = e, this.wt = s, this.$i = new qt(it), this.Bi = new is((t3) => Oe(t3), Fe), this.Li = /* @__PURE__ */ new Map(), this.Ui = t2.getRemoteDocumentCache(), this.Vs = t2.getTargetCache(), this.Ds = t2.getBundleCache(), this.qi(n);
  }
  qi(t2) {
    this.documentOverlayCache = this.persistence.getDocumentOverlayCache(t2), this.indexManager = this.persistence.getIndexManager(t2), this.mutationQueue = this.persistence.getMutationQueue(t2, this.indexManager), this.localDocuments = new eo(this.Ui, this.mutationQueue, this.documentOverlayCache, this.indexManager), this.Ui.setIndexManager(this.indexManager), this.Fi.initialize(this.localDocuments, this.indexManager);
  }
  collectGarbage(t2) {
    return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (e) => t2.collect(e, this.$i));
  }
};
function Ro(t2, e, n, s) {
  return new Ao(t2, e, n, s);
}
async function bo(t2, e) {
  const n = K2(t2);
  return await n.persistence.runTransaction("Handle user change", "readonly", (t3) => {
    let s;
    return n.mutationQueue.getAllMutationBatches(t3).next((i) => (s = i, n.qi(e), n.mutationQueue.getAllMutationBatches(t3))).next((e2) => {
      const i = [], r = [];
      let o = ws();
      for (const t4 of s) {
        i.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      for (const t4 of e2) {
        r.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      return n.localDocuments.getDocuments(t3, o).next((t4) => ({
        Ki: t4,
        removedBatchIds: i,
        addedBatchIds: r
      }));
    });
  });
}
function Po(t2, e) {
  const n = K2(t2);
  return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (t3) => {
    const s = e.batch.keys(), i = n.Ui.newChangeBuffer({
      trackRemovals: true
    });
    return function(t4, e2, n2, s2) {
      const i2 = n2.batch, r = i2.keys();
      let o = Pt.resolve();
      return r.forEach((t5) => {
        o = o.next(() => s2.getEntry(e2, t5)).next((e3) => {
          const r2 = n2.docVersions.get(t5);
          U2(r2 !== null), e3.version.compareTo(r2) < 0 && (i2.applyToRemoteDocument(e3, n2), e3.isValidDocument() && (e3.setReadTime(n2.commitVersion), s2.addEntry(e3)));
        });
      }), o.next(() => t4.mutationQueue.removeMutationBatch(e2, i2));
    }(n, t3, e, i).next(() => i.apply(t3)).next(() => n.mutationQueue.performConsistencyCheck(t3)).next(() => n.documentOverlayCache.removeOverlaysForBatchId(t3, s, e.batch.batchId)).next(() => n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(t3, function(t4) {
      let e2 = ws();
      for (let n2 = 0; n2 < t4.mutationResults.length; ++n2) {
        t4.mutationResults[n2].transformResults.length > 0 && (e2 = e2.add(t4.batch.mutations[n2].key));
      }
      return e2;
    }(e))).next(() => n.localDocuments.getDocuments(t3, s));
  });
}
function vo(t2) {
  const e = K2(t2);
  return e.persistence.runTransaction("Get last remote snapshot version", "readonly", (t3) => e.Vs.getLastRemoteSnapshotVersion(t3));
}
function Vo(t2, e) {
  const n = K2(t2), s = e.snapshotVersion;
  let i = n.$i;
  return n.persistence.runTransaction("Apply remote event", "readwrite-primary", (t3) => {
    const r = n.Ui.newChangeBuffer({
      trackRemovals: true
    });
    i = n.$i;
    const o = [];
    e.targetChanges.forEach((r2, u2) => {
      const c2 = i.get(u2);
      if (!c2)
        return;
      o.push(n.Vs.removeMatchingKeys(t3, r2.removedDocuments, u2).next(() => n.Vs.addMatchingKeys(t3, r2.addedDocuments, u2)));
      let a = c2.withSequenceNumber(t3.currentSequenceNumber);
      e.targetMismatches.has(u2) ? a = a.withResumeToken(Jt.EMPTY_BYTE_STRING, ct.min()).withLastLimboFreeSnapshotVersion(ct.min()) : r2.resumeToken.approximateByteSize() > 0 && (a = a.withResumeToken(r2.resumeToken, s)), i = i.insert(u2, a), function(t4, e2, n2) {
        if (t4.resumeToken.approximateByteSize() === 0)
          return true;
        if (e2.snapshotVersion.toMicroseconds() - t4.snapshotVersion.toMicroseconds() >= 3e8)
          return true;
        return n2.addedDocuments.size + n2.modifiedDocuments.size + n2.removedDocuments.size > 0;
      }(c2, a, r2) && o.push(n.Vs.updateTargetData(t3, a));
    });
    let u = os(), c = ws();
    if (e.documentUpdates.forEach((s2) => {
      e.resolvedLimboDocuments.has(s2) && o.push(n.persistence.referenceDelegate.updateLimboDocument(t3, s2));
    }), o.push(So(t3, r, e.documentUpdates).next((t4) => {
      u = t4.Gi, c = t4.Qi;
    })), !s.isEqual(ct.min())) {
      const e2 = n.Vs.getLastRemoteSnapshotVersion(t3).next((e3) => n.Vs.setTargetsMetadata(t3, t3.currentSequenceNumber, s));
      o.push(e2);
    }
    return Pt.waitFor(o).next(() => r.apply(t3)).next(() => n.localDocuments.getLocalViewOfDocuments(t3, u, c)).next(() => u);
  }).then((t3) => (n.$i = i, t3));
}
function So(t2, e, n) {
  let s = ws(), i = ws();
  return n.forEach((t3) => s = s.add(t3)), e.getEntries(t2, s).next((t3) => {
    let s2 = os();
    return n.forEach((n2, r) => {
      const o = t3.get(n2);
      r.isFoundDocument() !== o.isFoundDocument() && (i = i.add(n2)), r.isNoDocument() && r.version.isEqual(ct.min()) ? (e.removeEntry(n2, r.readTime), s2 = s2.insert(n2, r)) : !o.isValidDocument() || r.version.compareTo(o.version) > 0 || r.version.compareTo(o.version) === 0 && o.hasPendingWrites ? (e.addEntry(r), s2 = s2.insert(n2, r)) : M2("LocalStore", "Ignoring outdated watch update for ", n2, ". Current version:", o.version, " Watch version:", r.version);
    }), {
      Gi: s2,
      Qi: i
    };
  });
}
function Do(t2, e) {
  const n = K2(t2);
  return n.persistence.runTransaction("Get next mutation batch", "readonly", (t3) => (e === void 0 && (e = -1), n.mutationQueue.getNextMutationBatchAfterBatchId(t3, e)));
}
function Co(t2, e) {
  const n = K2(t2);
  return n.persistence.runTransaction("Allocate target", "readwrite", (t3) => {
    let s;
    return n.Vs.getTargetData(t3, e).next((i) => i ? (s = i, Pt.resolve(s)) : n.Vs.allocateTargetId(t3).next((i2) => (s = new Li(e, i2, 0, t3.currentSequenceNumber), n.Vs.addTargetData(t3, s).next(() => s))));
  }).then((t3) => {
    const s = n.$i.get(t3.targetId);
    return (s === null || t3.snapshotVersion.compareTo(s.snapshotVersion) > 0) && (n.$i = n.$i.insert(t3.targetId, t3), n.Bi.set(e, t3.targetId)), t3;
  });
}
async function xo(t2, e, n) {
  const s = K2(t2), i = s.$i.get(e), r = n ? "readwrite" : "readwrite-primary";
  try {
    n || await s.persistence.runTransaction("Release target", r, (t3) => s.persistence.referenceDelegate.removeTarget(t3, i));
  } catch (t3) {
    if (!Ct(t3))
      throw t3;
    M2("LocalStore", `Failed to update sequence numbers for target ${e}: ${t3}`);
  }
  s.$i = s.$i.remove(e), s.Bi.delete(i.target);
}
function No(t2, e, n) {
  const s = K2(t2);
  let i = ct.min(), r = ws();
  return s.persistence.runTransaction("Execute query", "readonly", (t3) => function(t4, e2, n2) {
    const s2 = K2(t4), i2 = s2.Bi.get(n2);
    return i2 !== void 0 ? Pt.resolve(s2.$i.get(i2)) : s2.Vs.getTargetData(e2, n2);
  }(s, t3, ln(e)).next((e2) => {
    if (e2)
      return i = e2.lastLimboFreeSnapshotVersion, s.Vs.getMatchingKeysForTargetId(t3, e2.targetId).next((t4) => {
        r = t4;
      });
  }).next(() => s.Fi.getDocumentsMatchingQuery(t3, e, n ? i : ct.min(), n ? r : ws())).next((t4) => (Mo(s, gn(e), t4), {
    documents: t4,
    ji: r
  })));
}
function ko(t2, e) {
  const n = K2(t2), s = K2(n.Vs), i = n.$i.get(e);
  return i ? Promise.resolve(i.target) : n.persistence.runTransaction("Get target data", "readonly", (t3) => s.te(t3, e).next((t4) => t4 ? t4.target : null));
}
function Oo(t2, e) {
  const n = K2(t2), s = n.Li.get(e) || ct.min();
  return n.persistence.runTransaction("Get new document changes", "readonly", (t3) => n.Ui.getAllFromCollectionGroup(t3, e, pt(s, -1), Number.MAX_SAFE_INTEGER)).then((t3) => (Mo(n, e, t3), t3));
}
function Mo(t2, e, n) {
  let s = ct.min();
  n.forEach((t3, e2) => {
    e2.readTime.compareTo(s) > 0 && (s = e2.readTime);
  }), t2.Li.set(e, s);
}
async function Fo(t2, e, n, s) {
  const i = K2(t2);
  let r = ws(), o = os();
  for (const t3 of n) {
    const n2 = e.Wi(t3.metadata.name);
    t3.document && (r = r.add(n2));
    const s2 = e.zi(t3);
    s2.setReadTime(e.Hi(t3.metadata.readTime)), o = o.insert(n2, s2);
  }
  const u = i.Ui.newChangeBuffer({
    trackRemovals: true
  }), c = await Co(i, function(t3) {
    return ln(rn(ht.fromString(`__bundle__/docs/${t3}`)));
  }(s));
  return i.persistence.runTransaction("Apply bundle documents", "readwrite", (t3) => So(t3, u, o).next((e2) => (u.apply(t3), e2)).next((e2) => i.Vs.removeMatchingKeysForTargetId(t3, c.targetId).next(() => i.Vs.addMatchingKeys(t3, r, c.targetId)).next(() => i.localDocuments.getLocalViewOfDocuments(t3, e2.Gi, e2.Qi)).next(() => e2.Gi)));
}
async function $o(t2, e, n = ws()) {
  const s = await Co(t2, ln(Ji(e.bundledQuery))), i = K2(t2);
  return i.persistence.runTransaction("Save named query", "readwrite", (t3) => {
    const r = Ns(e.readTime);
    if (s.snapshotVersion.compareTo(r) >= 0)
      return i.Ds.saveNamedQuery(t3, e);
    const o = s.withResumeToken(Jt.EMPTY_BYTE_STRING, r);
    return i.$i = i.$i.insert(o.targetId, o), i.Vs.updateTargetData(t3, o).next(() => i.Vs.removeMatchingKeysForTargetId(t3, s.targetId)).next(() => i.Vs.addMatchingKeys(t3, n, s.targetId)).next(() => i.Ds.saveNamedQuery(t3, e));
  });
}
function Bo(t2, e) {
  return `firestore_clients_${t2}_${e}`;
}
function Lo(t2, e, n) {
  let s = `firestore_mutations_${t2}_${n}`;
  return e.isAuthenticated() && (s += `_${e.uid}`), s;
}
function Uo(t2, e) {
  return `firestore_targets_${t2}_${e}`;
}
var qo = class {
  constructor(t2, e, n, s) {
    this.user = t2, this.batchId = e, this.state = n, this.error = s;
  }
  static Ji(t2, e, n) {
    const s = JSON.parse(n);
    let i, r = typeof s == "object" && ["pending", "acknowledged", "rejected"].indexOf(s.state) !== -1 && (s.error === void 0 || typeof s.error == "object");
    return r && s.error && (r = typeof s.error.message == "string" && typeof s.error.code == "string", r && (i = new Q2(s.error.code, s.error.message))), r ? new qo(t2, e, s.state, i) : (F2("SharedClientState", `Failed to parse mutation state for ID '${e}': ${n}`), null);
  }
  Yi() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var Ko = class {
  constructor(t2, e, n) {
    this.targetId = t2, this.state = e, this.error = n;
  }
  static Ji(t2, e) {
    const n = JSON.parse(e);
    let s, i = typeof n == "object" && ["not-current", "current", "rejected"].indexOf(n.state) !== -1 && (n.error === void 0 || typeof n.error == "object");
    return i && n.error && (i = typeof n.error.message == "string" && typeof n.error.code == "string", i && (s = new Q2(n.error.code, n.error.message))), i ? new Ko(t2, n.state, s) : (F2("SharedClientState", `Failed to parse target state for ID '${t2}': ${e}`), null);
  }
  Yi() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var Go = class {
  constructor(t2, e) {
    this.clientId = t2, this.activeTargetIds = e;
  }
  static Ji(t2, e) {
    const n = JSON.parse(e);
    let s = typeof n == "object" && n.activeTargetIds instanceof Array, i = gs();
    for (let t3 = 0; s && t3 < n.activeTargetIds.length; ++t3)
      s = ce(n.activeTargetIds[t3]), i = i.add(n.activeTargetIds[t3]);
    return s ? new Go(t2, i) : (F2("SharedClientState", `Failed to parse client data for instance '${t2}': ${e}`), null);
  }
};
var Qo = class {
  constructor(t2, e) {
    this.clientId = t2, this.onlineState = e;
  }
  static Ji(t2) {
    const e = JSON.parse(t2);
    return typeof e == "object" && ["Unknown", "Online", "Offline"].indexOf(e.onlineState) !== -1 && typeof e.clientId == "string" ? new Qo(e.clientId, e.onlineState) : (F2("SharedClientState", `Failed to parse online state: ${t2}`), null);
  }
};
var jo = class {
  constructor() {
    this.activeTargetIds = gs();
  }
  Xi(t2) {
    this.activeTargetIds = this.activeTargetIds.add(t2);
  }
  Zi(t2) {
    this.activeTargetIds = this.activeTargetIds.delete(t2);
  }
  Yi() {
    const t2 = {
      activeTargetIds: this.activeTargetIds.toArray(),
      updateTimeMs: Date.now()
    };
    return JSON.stringify(t2);
  }
};
var Wo = class {
  constructor(t2, e, n, s, i) {
    this.window = t2, this.js = e, this.persistenceKey = n, this.tr = s, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.er = this.nr.bind(this), this.sr = new qt(it), this.started = false, this.ir = [];
    const r = n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    this.storage = this.window.localStorage, this.currentUser = i, this.rr = Bo(this.persistenceKey, this.tr), this.ur = function(t3) {
      return `firestore_sequence_number_${t3}`;
    }(this.persistenceKey), this.sr = this.sr.insert(this.tr, new jo()), this.cr = new RegExp(`^firestore_clients_${r}_([^_]*)$`), this.ar = new RegExp(`^firestore_mutations_${r}_(\\d+)(?:_(.*))?$`), this.hr = new RegExp(`^firestore_targets_${r}_(\\d+)$`), this.lr = function(t3) {
      return `firestore_online_state_${t3}`;
    }(this.persistenceKey), this.dr = function(t3) {
      return `firestore_bundle_loaded_v2_${t3}`;
    }(this.persistenceKey), this.window.addEventListener("storage", this.er);
  }
  static V(t2) {
    return !(!t2 || !t2.localStorage);
  }
  async start() {
    const t2 = await this.syncEngine.Ri();
    for (const e2 of t2) {
      if (e2 === this.tr)
        continue;
      const t3 = this.getItem(Bo(this.persistenceKey, e2));
      if (t3) {
        const n = Go.Ji(e2, t3);
        n && (this.sr = this.sr.insert(n.clientId, n));
      }
    }
    this._r();
    const e = this.storage.getItem(this.lr);
    if (e) {
      const t3 = this.wr(e);
      t3 && this.mr(t3);
    }
    for (const t3 of this.ir)
      this.nr(t3);
    this.ir = [], this.window.addEventListener("pagehide", () => this.shutdown()), this.started = true;
  }
  writeSequenceNumber(t2) {
    this.setItem(this.ur, JSON.stringify(t2));
  }
  getAllActiveQueryTargets() {
    return this.gr(this.sr);
  }
  isActiveQueryTarget(t2) {
    let e = false;
    return this.sr.forEach((n, s) => {
      s.activeTargetIds.has(t2) && (e = true);
    }), e;
  }
  addPendingMutation(t2) {
    this.yr(t2, "pending");
  }
  updateMutationState(t2, e, n) {
    this.yr(t2, e, n), this.pr(t2);
  }
  addLocalQueryTarget(t2) {
    let e = "not-current";
    if (this.isActiveQueryTarget(t2)) {
      const n = this.storage.getItem(Uo(this.persistenceKey, t2));
      if (n) {
        const s = Ko.Ji(t2, n);
        s && (e = s.state);
      }
    }
    return this.Ir.Xi(t2), this._r(), e;
  }
  removeLocalQueryTarget(t2) {
    this.Ir.Zi(t2), this._r();
  }
  isLocalQueryTarget(t2) {
    return this.Ir.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    this.removeItem(Uo(this.persistenceKey, t2));
  }
  updateQueryState(t2, e, n) {
    this.Tr(t2, e, n);
  }
  handleUserChange(t2, e, n) {
    e.forEach((t3) => {
      this.pr(t3);
    }), this.currentUser = t2, n.forEach((t3) => {
      this.addPendingMutation(t3);
    });
  }
  setOnlineState(t2) {
    this.Er(t2);
  }
  notifyBundleLoaded(t2) {
    this.Ar(t2);
  }
  shutdown() {
    this.started && (this.window.removeEventListener("storage", this.er), this.removeItem(this.rr), this.started = false);
  }
  getItem(t2) {
    const e = this.storage.getItem(t2);
    return M2("SharedClientState", "READ", t2, e), e;
  }
  setItem(t2, e) {
    M2("SharedClientState", "SET", t2, e), this.storage.setItem(t2, e);
  }
  removeItem(t2) {
    M2("SharedClientState", "REMOVE", t2), this.storage.removeItem(t2);
  }
  nr(t2) {
    const e = t2;
    if (e.storageArea === this.storage) {
      if (M2("SharedClientState", "EVENT", e.key, e.newValue), e.key === this.rr)
        return void F2("Received WebStorage notification for local change. Another client might have garbage-collected our state");
      this.js.enqueueRetryable(async () => {
        if (this.started) {
          if (e.key !== null) {
            if (this.cr.test(e.key)) {
              if (e.newValue == null) {
                const t3 = this.Rr(e.key);
                return this.br(t3, null);
              }
              {
                const t3 = this.Pr(e.key, e.newValue);
                if (t3)
                  return this.br(t3.clientId, t3);
              }
            } else if (this.ar.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.vr(e.key, e.newValue);
                if (t3)
                  return this.Vr(t3);
              }
            } else if (this.hr.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.Sr(e.key, e.newValue);
                if (t3)
                  return this.Dr(t3);
              }
            } else if (e.key === this.lr) {
              if (e.newValue !== null) {
                const t3 = this.wr(e.newValue);
                if (t3)
                  return this.mr(t3);
              }
            } else if (e.key === this.ur) {
              const t3 = function(t4) {
                let e2 = $t.ot;
                if (t4 != null)
                  try {
                    const n = JSON.parse(t4);
                    U2(typeof n == "number"), e2 = n;
                  } catch (t5) {
                    F2("SharedClientState", "Failed to read sequence number from WebStorage", t5);
                  }
                return e2;
              }(e.newValue);
              t3 !== $t.ot && this.sequenceNumberHandler(t3);
            } else if (e.key === this.dr) {
              const t3 = this.Cr(e.newValue);
              await Promise.all(t3.map((t4) => this.syncEngine.Nr(t4)));
            }
          }
        } else
          this.ir.push(e);
      });
    }
  }
  get Ir() {
    return this.sr.get(this.tr);
  }
  _r() {
    this.setItem(this.rr, this.Ir.Yi());
  }
  yr(t2, e, n) {
    const s = new qo(this.currentUser, t2, e, n), i = Lo(this.persistenceKey, this.currentUser, t2);
    this.setItem(i, s.Yi());
  }
  pr(t2) {
    const e = Lo(this.persistenceKey, this.currentUser, t2);
    this.removeItem(e);
  }
  Er(t2) {
    const e = {
      clientId: this.tr,
      onlineState: t2
    };
    this.storage.setItem(this.lr, JSON.stringify(e));
  }
  Tr(t2, e, n) {
    const s = Uo(this.persistenceKey, t2), i = new Ko(t2, e, n);
    this.setItem(s, i.Yi());
  }
  Ar(t2) {
    const e = JSON.stringify(Array.from(t2));
    this.setItem(this.dr, e);
  }
  Rr(t2) {
    const e = this.cr.exec(t2);
    return e ? e[1] : null;
  }
  Pr(t2, e) {
    const n = this.Rr(t2);
    return Go.Ji(n, e);
  }
  vr(t2, e) {
    const n = this.ar.exec(t2), s = Number(n[1]), i = n[2] !== void 0 ? n[2] : null;
    return qo.Ji(new C2(i), s, e);
  }
  Sr(t2, e) {
    const n = this.hr.exec(t2), s = Number(n[1]);
    return Ko.Ji(s, e);
  }
  wr(t2) {
    return Qo.Ji(t2);
  }
  Cr(t2) {
    return JSON.parse(t2);
  }
  async Vr(t2) {
    if (t2.user.uid === this.currentUser.uid)
      return this.syncEngine.kr(t2.batchId, t2.state, t2.error);
    M2("SharedClientState", `Ignoring mutation for non-active user ${t2.user.uid}`);
  }
  Dr(t2) {
    return this.syncEngine.Or(t2.targetId, t2.state, t2.error);
  }
  br(t2, e) {
    const n = e ? this.sr.insert(t2, e) : this.sr.remove(t2), s = this.gr(this.sr), i = this.gr(n), r = [], o = [];
    return i.forEach((t3) => {
      s.has(t3) || r.push(t3);
    }), s.forEach((t3) => {
      i.has(t3) || o.push(t3);
    }), this.syncEngine.Mr(r, o).then(() => {
      this.sr = n;
    });
  }
  mr(t2) {
    this.sr.get(t2.clientId) && this.onlineStateHandler(t2.onlineState);
  }
  gr(t2) {
    let e = gs();
    return t2.forEach((t3, n) => {
      e = e.unionWith(n.activeTargetIds);
    }), e;
  }
};
var zo = class {
  constructor() {
    this.Fr = new jo(), this.$r = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
  }
  addPendingMutation(t2) {
  }
  updateMutationState(t2, e, n) {
  }
  addLocalQueryTarget(t2) {
    return this.Fr.Xi(t2), this.$r[t2] || "not-current";
  }
  updateQueryState(t2, e, n) {
    this.$r[t2] = e;
  }
  removeLocalQueryTarget(t2) {
    this.Fr.Zi(t2);
  }
  isLocalQueryTarget(t2) {
    return this.Fr.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    delete this.$r[t2];
  }
  getAllActiveQueryTargets() {
    return this.Fr.activeTargetIds;
  }
  isActiveQueryTarget(t2) {
    return this.Fr.activeTargetIds.has(t2);
  }
  start() {
    return this.Fr = new jo(), Promise.resolve();
  }
  handleUserChange(t2, e, n) {
  }
  setOnlineState(t2) {
  }
  shutdown() {
  }
  writeSequenceNumber(t2) {
  }
  notifyBundleLoaded(t2) {
  }
};
var Ho = class {
  Br(t2) {
  }
  shutdown() {
  }
};
var Jo = class {
  constructor() {
    this.Lr = () => this.Ur(), this.qr = () => this.Kr(), this.Gr = [], this.Qr();
  }
  Br(t2) {
    this.Gr.push(t2);
  }
  shutdown() {
    window.removeEventListener("online", this.Lr), window.removeEventListener("offline", this.qr);
  }
  Qr() {
    window.addEventListener("online", this.Lr), window.addEventListener("offline", this.qr);
  }
  Ur() {
    M2("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
    for (const t2 of this.Gr)
      t2(0);
  }
  Kr() {
    M2("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
    for (const t2 of this.Gr)
      t2(1);
  }
  static V() {
    return typeof window != "undefined" && window.addEventListener !== void 0 && window.removeEventListener !== void 0;
  }
};
var Yo = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery"
};
var Xo = class {
  constructor(t2) {
    this.jr = t2.jr, this.Wr = t2.Wr;
  }
  zr(t2) {
    this.Hr = t2;
  }
  Jr(t2) {
    this.Yr = t2;
  }
  onMessage(t2) {
    this.Xr = t2;
  }
  close() {
    this.Wr();
  }
  send(t2) {
    this.jr(t2);
  }
  Zr() {
    this.Hr();
  }
  eo(t2) {
    this.Yr(t2);
  }
  no(t2) {
    this.Xr(t2);
  }
};
var Zo = class extends class {
  constructor(t2) {
    this.databaseInfo = t2, this.databaseId = t2.databaseId;
    const e = t2.ssl ? "https" : "http";
    this.so = e + "://" + t2.host, this.io = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
  }
  ro(t2, e, n, s, i) {
    const r = this.oo(t2, e);
    M2("RestConnection", "Sending: ", r, n);
    const o = {};
    return this.uo(o, s, i), this.co(t2, r, o, n).then((t3) => (M2("RestConnection", "Received: ", t3), t3), (e2) => {
      throw $("RestConnection", `${t2} failed with error: `, e2, "url: ", r, "request:", n), e2;
    });
  }
  ao(t2, e, n, s, i) {
    return this.ro(t2, e, n, s, i);
  }
  uo(t2, e, n) {
    t2["X-Goog-Api-Client"] = "gl-js/ fire/" + x2, t2["Content-Type"] = "text/plain", this.databaseInfo.appId && (t2["X-Firebase-GMPID"] = this.databaseInfo.appId), e && e.headers.forEach((e2, n2) => t2[n2] = e2), n && n.headers.forEach((e2, n2) => t2[n2] = e2);
  }
  oo(t2, e) {
    const n = Yo[t2];
    return `${this.so}/v1/${e}:${n}`;
  }
} {
  constructor(t2) {
    super(t2), this.forceLongPolling = t2.forceLongPolling, this.autoDetectLongPolling = t2.autoDetectLongPolling, this.useFetchStreams = t2.useFetchStreams;
  }
  co(t2, e, n, s) {
    return new Promise((i, r) => {
      const o = new XhrIo();
      o.listenOnce(EventType.COMPLETE, () => {
        try {
          switch (o.getLastErrorCode()) {
            case ErrorCode.NO_ERROR:
              const e2 = o.getResponseJson();
              M2("Connection", "XHR received:", JSON.stringify(e2)), i(e2);
              break;
            case ErrorCode.TIMEOUT:
              M2("Connection", 'RPC "' + t2 + '" timed out'), r(new Q2(G.DEADLINE_EXCEEDED, "Request time out"));
              break;
            case ErrorCode.HTTP_ERROR:
              const n2 = o.getStatus();
              if (M2("Connection", 'RPC "' + t2 + '" failed with status:', n2, "response text:", o.getResponseText()), n2 > 0) {
                const t3 = o.getResponseJson().error;
                if (t3 && t3.status && t3.message) {
                  const e3 = function(t4) {
                    const e4 = t4.toLowerCase().replace(/_/g, "-");
                    return Object.values(G).indexOf(e4) >= 0 ? e4 : G.UNKNOWN;
                  }(t3.status);
                  r(new Q2(e3, t3.message));
                } else
                  r(new Q2(G.UNKNOWN, "Server responded with status " + o.getStatus()));
              } else
                r(new Q2(G.UNAVAILABLE, "Connection failed."));
              break;
            default:
              L2();
          }
        } finally {
          M2("Connection", 'RPC "' + t2 + '" completed.');
        }
      });
      const u = JSON.stringify(s);
      o.send(e, "POST", u, n, 15);
    });
  }
  ho(t2, e, n) {
    const s = [this.so, "/", "google.firestore.v1.Firestore", "/", t2, "/channel"], i = createWebChannelTransport(), r = getStatEventTarget(), o = {
      httpSessionIdParam: "gsessionid",
      initMessageHeaders: {},
      messageUrlParams: {
        database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
      },
      sendRawJson: true,
      supportsCrossDomainXhr: true,
      internalChannelParams: {
        forwardChannelRequestTimeoutMs: 6e5
      },
      forceLongPolling: this.forceLongPolling,
      detectBufferingProxy: this.autoDetectLongPolling
    };
    this.useFetchStreams && (o.xmlHttpFactory = new FetchXmlHttpFactory({})), this.uo(o.initMessageHeaders, e, n), isMobileCordova() || isReactNative() || isElectron() || isIE() || isUWP() || isBrowserExtension() || (o.httpHeadersOverwriteParam = "$httpHeaders");
    const u = s.join("");
    M2("Connection", "Creating WebChannel: " + u, o);
    const c = i.createWebChannel(u, o);
    let a = false, h = false;
    const l2 = new Xo({
      jr: (t3) => {
        h ? M2("Connection", "Not sending because WebChannel is closed:", t3) : (a || (M2("Connection", "Opening WebChannel transport."), c.open(), a = true), M2("Connection", "WebChannel sending:", t3), c.send(t3));
      },
      Wr: () => c.close()
    }), y2 = (t3, e2, n2) => {
      t3.listen(e2, (t4) => {
        try {
          n2(t4);
        } catch (t5) {
          setTimeout(() => {
            throw t5;
          }, 0);
        }
      });
    };
    return y2(c, WebChannel.EventType.OPEN, () => {
      h || M2("Connection", "WebChannel transport opened.");
    }), y2(c, WebChannel.EventType.CLOSE, () => {
      h || (h = true, M2("Connection", "WebChannel transport closed"), l2.eo());
    }), y2(c, WebChannel.EventType.ERROR, (t3) => {
      h || (h = true, $("Connection", "WebChannel transport errored:", t3), l2.eo(new Q2(G.UNAVAILABLE, "The operation could not be completed")));
    }), y2(c, WebChannel.EventType.MESSAGE, (t3) => {
      var e2;
      if (!h) {
        const n2 = t3.data[0];
        U2(!!n2);
        const s2 = n2, i2 = s2.error || ((e2 = s2[0]) === null || e2 === void 0 ? void 0 : e2.error);
        if (i2) {
          M2("Connection", "WebChannel received error:", i2);
          const t4 = i2.status;
          let e3 = function(t5) {
            const e4 = ts[t5];
            if (e4 !== void 0)
              return ss(e4);
          }(t4), n3 = i2.message;
          e3 === void 0 && (e3 = G.INTERNAL, n3 = "Unknown error status: " + t4 + " with message " + i2.message), h = true, l2.eo(new Q2(e3, n3)), c.close();
        } else
          M2("Connection", "WebChannel received:", n2), l2.no(n2);
      }
    }), y2(r, Event.STAT_EVENT, (t3) => {
      t3.stat === Stat.PROXY ? M2("Connection", "Detected buffering proxy") : t3.stat === Stat.NOPROXY && M2("Connection", "Detected no buffering proxy");
    }), setTimeout(() => {
      l2.Zr();
    }, 0), l2;
  }
};
function tu() {
  return typeof window != "undefined" ? window : null;
}
function eu() {
  return typeof document != "undefined" ? document : null;
}
function nu(t2) {
  return new Ss(t2, true);
}
var su = class {
  constructor(t2, e, n = 1e3, s = 1.5, i = 6e4) {
    this.js = t2, this.timerId = e, this.lo = n, this.fo = s, this._o = i, this.wo = 0, this.mo = null, this.yo = Date.now(), this.reset();
  }
  reset() {
    this.wo = 0;
  }
  po() {
    this.wo = this._o;
  }
  Io(t2) {
    this.cancel();
    const e = Math.floor(this.wo + this.To()), n = Math.max(0, Date.now() - this.yo), s = Math.max(0, e - n);
    s > 0 && M2("ExponentialBackoff", `Backing off for ${s} ms (base delay: ${this.wo} ms, delay with jitter: ${e} ms, last attempt: ${n} ms ago)`), this.mo = this.js.enqueueAfterDelay(this.timerId, s, () => (this.yo = Date.now(), t2())), this.wo *= this.fo, this.wo < this.lo && (this.wo = this.lo), this.wo > this._o && (this.wo = this._o);
  }
  Eo() {
    this.mo !== null && (this.mo.skipDelay(), this.mo = null);
  }
  cancel() {
    this.mo !== null && (this.mo.cancel(), this.mo = null);
  }
  To() {
    return (Math.random() - 0.5) * this.wo;
  }
};
var iu = class {
  constructor(t2, e, n, s, i, r, o, u) {
    this.js = t2, this.Ao = n, this.Ro = s, this.bo = i, this.authCredentialsProvider = r, this.appCheckCredentialsProvider = o, this.listener = u, this.state = 0, this.Po = 0, this.vo = null, this.Vo = null, this.stream = null, this.So = new su(t2, e);
  }
  Do() {
    return this.state === 1 || this.state === 5 || this.Co();
  }
  Co() {
    return this.state === 2 || this.state === 3;
  }
  start() {
    this.state !== 4 ? this.auth() : this.xo();
  }
  async stop() {
    this.Do() && await this.close(0);
  }
  No() {
    this.state = 0, this.So.reset();
  }
  ko() {
    this.Co() && this.vo === null && (this.vo = this.js.enqueueAfterDelay(this.Ao, 6e4, () => this.Oo()));
  }
  Mo(t2) {
    this.Fo(), this.stream.send(t2);
  }
  async Oo() {
    if (this.Co())
      return this.close(0);
  }
  Fo() {
    this.vo && (this.vo.cancel(), this.vo = null);
  }
  $o() {
    this.Vo && (this.Vo.cancel(), this.Vo = null);
  }
  async close(t2, e) {
    this.Fo(), this.$o(), this.So.cancel(), this.Po++, t2 !== 4 ? this.So.reset() : e && e.code === G.RESOURCE_EXHAUSTED ? (F2(e.toString()), F2("Using maximum backoff delay to prevent overloading the backend."), this.So.po()) : e && e.code === G.UNAUTHENTICATED && this.state !== 3 && (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), this.stream !== null && (this.Bo(), this.stream.close(), this.stream = null), this.state = t2, await this.listener.Jr(e);
  }
  Bo() {
  }
  auth() {
    this.state = 1;
    const t2 = this.Lo(this.Po), e = this.Po;
    Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([t3, n]) => {
      this.Po === e && this.Uo(t3, n);
    }, (e2) => {
      t2(() => {
        const t3 = new Q2(G.UNKNOWN, "Fetching auth token failed: " + e2.message);
        return this.qo(t3);
      });
    });
  }
  Uo(t2, e) {
    const n = this.Lo(this.Po);
    this.stream = this.Ko(t2, e), this.stream.zr(() => {
      n(() => (this.state = 2, this.Vo = this.js.enqueueAfterDelay(this.Ro, 1e4, () => (this.Co() && (this.state = 3), Promise.resolve())), this.listener.zr()));
    }), this.stream.Jr((t3) => {
      n(() => this.qo(t3));
    }), this.stream.onMessage((t3) => {
      n(() => this.onMessage(t3));
    });
  }
  xo() {
    this.state = 5, this.So.Io(async () => {
      this.state = 0, this.start();
    });
  }
  qo(t2) {
    return M2("PersistentStream", `close with error: ${t2}`), this.stream = null, this.close(4, t2);
  }
  Lo(t2) {
    return (e) => {
      this.js.enqueueAndForget(() => this.Po === t2 ? e() : (M2("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
    };
  }
};
var ru = class extends iu {
  constructor(t2, e, n, s, i, r) {
    super(t2, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", e, n, s, r), this.wt = i;
  }
  Ko(t2, e) {
    return this.bo.ho("Listen", t2, e);
  }
  onMessage(t2) {
    this.So.reset();
    const e = Qs(this.wt, t2), n = function(t3) {
      if (!("targetChange" in t3))
        return ct.min();
      const e2 = t3.targetChange;
      return e2.targetIds && e2.targetIds.length ? ct.min() : e2.readTime ? Ns(e2.readTime) : ct.min();
    }(t2);
    return this.listener.Go(e, n);
  }
  Qo(t2) {
    const e = {};
    e.database = Ls(this.wt), e.addTarget = function(t3, e2) {
      let n2;
      const s = e2.target;
      return n2 = $e(s) ? {
        documents: Hs(t3, s)
      } : {
        query: Js(t3, s)
      }, n2.targetId = e2.targetId, e2.resumeToken.approximateByteSize() > 0 ? n2.resumeToken = Cs(t3, e2.resumeToken) : e2.snapshotVersion.compareTo(ct.min()) > 0 && (n2.readTime = Ds(t3, e2.snapshotVersion.toTimestamp())), n2;
    }(this.wt, t2);
    const n = Xs(this.wt, t2);
    n && (e.labels = n), this.Mo(e);
  }
  jo(t2) {
    const e = {};
    e.database = Ls(this.wt), e.removeTarget = t2, this.Mo(e);
  }
};
var ou = class extends iu {
  constructor(t2, e, n, s, i, r) {
    super(t2, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", e, n, s, r), this.wt = i, this.Wo = false;
  }
  get zo() {
    return this.Wo;
  }
  start() {
    this.Wo = false, this.lastStreamToken = void 0, super.start();
  }
  Bo() {
    this.Wo && this.Ho([]);
  }
  Ko(t2, e) {
    return this.bo.ho("Write", t2, e);
  }
  onMessage(t2) {
    if (U2(!!t2.streamToken), this.lastStreamToken = t2.streamToken, this.Wo) {
      this.So.reset();
      const e = zs(t2.writeResults, t2.commitTime), n = Ns(t2.commitTime);
      return this.listener.Jo(n, e);
    }
    return U2(!t2.writeResults || t2.writeResults.length === 0), this.Wo = true, this.listener.Yo();
  }
  Xo() {
    const t2 = {};
    t2.database = Ls(this.wt), this.Mo(t2);
  }
  Ho(t2) {
    const e = {
      streamToken: this.lastStreamToken,
      writes: t2.map((t3) => js(this.wt, t3))
    };
    this.Mo(e);
  }
};
var uu = class extends class {
} {
  constructor(t2, e, n, s) {
    super(), this.authCredentials = t2, this.appCheckCredentials = e, this.bo = n, this.wt = s, this.Zo = false;
  }
  tu() {
    if (this.Zo)
      throw new Q2(G.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  ro(t2, e, n) {
    return this.tu(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, i]) => this.bo.ro(t2, e, n, s, i)).catch((t3) => {
      throw t3.name === "FirebaseError" ? (t3.code === G.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t3) : new Q2(G.UNKNOWN, t3.toString());
    });
  }
  ao(t2, e, n) {
    return this.tu(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, i]) => this.bo.ao(t2, e, n, s, i)).catch((t3) => {
      throw t3.name === "FirebaseError" ? (t3.code === G.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t3) : new Q2(G.UNKNOWN, t3.toString());
    });
  }
  terminate() {
    this.Zo = true;
  }
};
var cu = class {
  constructor(t2, e) {
    this.asyncQueue = t2, this.onlineStateHandler = e, this.state = "Unknown", this.eu = 0, this.nu = null, this.su = true;
  }
  iu() {
    this.eu === 0 && (this.ru("Unknown"), this.nu = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.nu = null, this.ou("Backend didn't respond within 10 seconds."), this.ru("Offline"), Promise.resolve())));
  }
  uu(t2) {
    this.state === "Online" ? this.ru("Unknown") : (this.eu++, this.eu >= 1 && (this.cu(), this.ou(`Connection failed 1 times. Most recent error: ${t2.toString()}`), this.ru("Offline")));
  }
  set(t2) {
    this.cu(), this.eu = 0, t2 === "Online" && (this.su = false), this.ru(t2);
  }
  ru(t2) {
    t2 !== this.state && (this.state = t2, this.onlineStateHandler(t2));
  }
  ou(t2) {
    const e = `Could not reach Cloud Firestore backend. ${t2}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
    this.su ? (F2(e), this.su = false) : M2("OnlineStateTracker", e);
  }
  cu() {
    this.nu !== null && (this.nu.cancel(), this.nu = null);
  }
};
var au = class {
  constructor(t2, e, n, s, i) {
    this.localStore = t2, this.datastore = e, this.asyncQueue = n, this.remoteSyncer = {}, this.au = [], this.hu = /* @__PURE__ */ new Map(), this.lu = /* @__PURE__ */ new Set(), this.fu = [], this.du = i, this.du.Br((t3) => {
      n.enqueueAndForget(async () => {
        yu(this) && (M2("RemoteStore", "Restarting streams for network reachability change."), await async function(t4) {
          const e2 = K2(t4);
          e2.lu.add(4), await lu(e2), e2._u.set("Unknown"), e2.lu.delete(4), await hu(e2);
        }(this));
      });
    }), this._u = new cu(n, s);
  }
};
async function hu(t2) {
  if (yu(t2))
    for (const e of t2.fu)
      await e(true);
}
async function lu(t2) {
  for (const e of t2.fu)
    await e(false);
}
function fu(t2, e) {
  const n = K2(t2);
  n.hu.has(e.targetId) || (n.hu.set(e.targetId, e), gu(n) ? mu(n) : Mu(n).Co() && _u(n, e));
}
function du(t2, e) {
  const n = K2(t2), s = Mu(n);
  n.hu.delete(e), s.Co() && wu(n, e), n.hu.size === 0 && (s.Co() ? s.ko() : yu(n) && n._u.set("Unknown"));
}
function _u(t2, e) {
  t2.wu.Nt(e.targetId), Mu(t2).Qo(e);
}
function wu(t2, e) {
  t2.wu.Nt(e), Mu(t2).jo(e);
}
function mu(t2) {
  t2.wu = new Rs({
    getRemoteKeysForTarget: (e) => t2.remoteSyncer.getRemoteKeysForTarget(e),
    te: (e) => t2.hu.get(e) || null
  }), Mu(t2).start(), t2._u.iu();
}
function gu(t2) {
  return yu(t2) && !Mu(t2).Do() && t2.hu.size > 0;
}
function yu(t2) {
  return K2(t2).lu.size === 0;
}
function pu(t2) {
  t2.wu = void 0;
}
async function Iu(t2) {
  t2.hu.forEach((e, n) => {
    _u(t2, e);
  });
}
async function Tu(t2, e) {
  pu(t2), gu(t2) ? (t2._u.uu(e), mu(t2)) : t2._u.set("Unknown");
}
async function Eu(t2, e, n) {
  if (t2._u.set("Online"), e instanceof Es && e.state === 2 && e.cause)
    try {
      await async function(t3, e2) {
        const n2 = e2.cause;
        for (const s of e2.targetIds)
          t3.hu.has(s) && (await t3.remoteSyncer.rejectListen(s, n2), t3.hu.delete(s), t3.wu.removeTarget(s));
      }(t2, e);
    } catch (n2) {
      M2("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), n2), await Au(t2, n2);
    }
  else if (e instanceof Is ? t2.wu.Ut(e) : e instanceof Ts ? t2.wu.zt(e) : t2.wu.Gt(e), !n.isEqual(ct.min()))
    try {
      const e2 = await vo(t2.localStore);
      n.compareTo(e2) >= 0 && await function(t3, e3) {
        const n2 = t3.wu.Yt(e3);
        return n2.targetChanges.forEach((n3, s) => {
          if (n3.resumeToken.approximateByteSize() > 0) {
            const i = t3.hu.get(s);
            i && t3.hu.set(s, i.withResumeToken(n3.resumeToken, e3));
          }
        }), n2.targetMismatches.forEach((e4) => {
          const n3 = t3.hu.get(e4);
          if (!n3)
            return;
          t3.hu.set(e4, n3.withResumeToken(Jt.EMPTY_BYTE_STRING, n3.snapshotVersion)), wu(t3, e4);
          const s = new Li(n3.target, e4, 1, n3.sequenceNumber);
          _u(t3, s);
        }), t3.remoteSyncer.applyRemoteEvent(n2);
      }(t2, n);
    } catch (e2) {
      M2("RemoteStore", "Failed to raise snapshot:", e2), await Au(t2, e2);
    }
}
async function Au(t2, e, n) {
  if (!Ct(e))
    throw e;
  t2.lu.add(1), await lu(t2), t2._u.set("Offline"), n || (n = () => vo(t2.localStore)), t2.asyncQueue.enqueueRetryable(async () => {
    M2("RemoteStore", "Retrying IndexedDB access"), await n(), t2.lu.delete(1), await hu(t2);
  });
}
function Ru(t2, e) {
  return e().catch((n) => Au(t2, n, e));
}
async function bu(t2) {
  const e = K2(t2), n = Fu(e);
  let s = e.au.length > 0 ? e.au[e.au.length - 1].batchId : -1;
  for (; Pu(e); )
    try {
      const t3 = await Do(e.localStore, s);
      if (t3 === null) {
        e.au.length === 0 && n.ko();
        break;
      }
      s = t3.batchId, vu(e, t3);
    } catch (t3) {
      await Au(e, t3);
    }
  Vu(e) && Su(e);
}
function Pu(t2) {
  return yu(t2) && t2.au.length < 10;
}
function vu(t2, e) {
  t2.au.push(e);
  const n = Fu(t2);
  n.Co() && n.zo && n.Ho(e.mutations);
}
function Vu(t2) {
  return yu(t2) && !Fu(t2).Do() && t2.au.length > 0;
}
function Su(t2) {
  Fu(t2).start();
}
async function Du(t2) {
  Fu(t2).Xo();
}
async function Cu(t2) {
  const e = Fu(t2);
  for (const n of t2.au)
    e.Ho(n.mutations);
}
async function xu(t2, e, n) {
  const s = t2.au.shift(), i = $i.from(s, e, n);
  await Ru(t2, () => t2.remoteSyncer.applySuccessfulWrite(i)), await bu(t2);
}
async function Nu(t2, e) {
  e && Fu(t2).zo && await async function(t3, e2) {
    if (n = e2.code, ns(n) && n !== G.ABORTED) {
      const n2 = t3.au.shift();
      Fu(t3).No(), await Ru(t3, () => t3.remoteSyncer.rejectFailedWrite(n2.batchId, e2)), await bu(t3);
    }
    var n;
  }(t2, e), Vu(t2) && Su(t2);
}
async function ku(t2, e) {
  const n = K2(t2);
  n.asyncQueue.verifyOperationInProgress(), M2("RemoteStore", "RemoteStore received new credentials");
  const s = yu(n);
  n.lu.add(3), await lu(n), s && n._u.set("Unknown"), await n.remoteSyncer.handleCredentialChange(e), n.lu.delete(3), await hu(n);
}
async function Ou(t2, e) {
  const n = K2(t2);
  e ? (n.lu.delete(2), await hu(n)) : e || (n.lu.add(2), await lu(n), n._u.set("Unknown"));
}
function Mu(t2) {
  return t2.mu || (t2.mu = function(t3, e, n) {
    const s = K2(t3);
    return s.tu(), new ru(e, s.bo, s.authCredentials, s.appCheckCredentials, s.wt, n);
  }(t2.datastore, t2.asyncQueue, {
    zr: Iu.bind(null, t2),
    Jr: Tu.bind(null, t2),
    Go: Eu.bind(null, t2)
  }), t2.fu.push(async (e) => {
    e ? (t2.mu.No(), gu(t2) ? mu(t2) : t2._u.set("Unknown")) : (await t2.mu.stop(), pu(t2));
  })), t2.mu;
}
function Fu(t2) {
  return t2.gu || (t2.gu = function(t3, e, n) {
    const s = K2(t3);
    return s.tu(), new ou(e, s.bo, s.authCredentials, s.appCheckCredentials, s.wt, n);
  }(t2.datastore, t2.asyncQueue, {
    zr: Du.bind(null, t2),
    Jr: Nu.bind(null, t2),
    Yo: Cu.bind(null, t2),
    Jo: xu.bind(null, t2)
  }), t2.fu.push(async (e) => {
    e ? (t2.gu.No(), await bu(t2)) : (await t2.gu.stop(), t2.au.length > 0 && (M2("RemoteStore", `Stopping write stream with ${t2.au.length} pending writes`), t2.au = []));
  })), t2.gu;
}
var $u = class {
  constructor(t2, e, n, s, i) {
    this.asyncQueue = t2, this.timerId = e, this.targetTimeMs = n, this.op = s, this.removalCallback = i, this.deferred = new j(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((t3) => {
    });
  }
  static createAndSchedule(t2, e, n, s, i) {
    const r = Date.now() + n, o = new $u(t2, e, r, s, i);
    return o.start(n), o;
  }
  start(t2) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t2);
  }
  skipDelay() {
    return this.handleDelayElapsed();
  }
  cancel(t2) {
    this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new Q2(G.CANCELLED, "Operation cancelled" + (t2 ? ": " + t2 : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then((t2) => this.deferred.resolve(t2))) : Promise.resolve());
  }
  clearTimeout() {
    this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
};
function Bu(t2, e) {
  if (F2("AsyncQueue", `${e}: ${t2}`), Ct(t2))
    return new Q2(G.UNAVAILABLE, `${e}: ${t2}`);
  throw t2;
}
var Lu = class {
  constructor(t2) {
    this.comparator = t2 ? (e, n) => t2(e, n) || dt.comparator(e.key, n.key) : (t3, e) => dt.comparator(t3.key, e.key), this.keyedMap = cs(), this.sortedSet = new qt(this.comparator);
  }
  static emptySet(t2) {
    return new Lu(t2.comparator);
  }
  has(t2) {
    return this.keyedMap.get(t2) != null;
  }
  get(t2) {
    return this.keyedMap.get(t2);
  }
  first() {
    return this.sortedSet.minKey();
  }
  last() {
    return this.sortedSet.maxKey();
  }
  isEmpty() {
    return this.sortedSet.isEmpty();
  }
  indexOf(t2) {
    const e = this.keyedMap.get(t2);
    return e ? this.sortedSet.indexOf(e) : -1;
  }
  get size() {
    return this.sortedSet.size;
  }
  forEach(t2) {
    this.sortedSet.inorderTraversal((e, n) => (t2(e), false));
  }
  add(t2) {
    const e = this.delete(t2.key);
    return e.copy(e.keyedMap.insert(t2.key, t2), e.sortedSet.insert(t2, null));
  }
  delete(t2) {
    const e = this.get(t2);
    return e ? this.copy(this.keyedMap.remove(t2), this.sortedSet.remove(e)) : this;
  }
  isEqual(t2) {
    if (!(t2 instanceof Lu))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.sortedSet.getIterator(), n = t2.sortedSet.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (!t3.isEqual(s))
        return false;
    }
    return true;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e.toString());
    }), t2.length === 0 ? "DocumentSet ()" : "DocumentSet (\n  " + t2.join("  \n") + "\n)";
  }
  copy(t2, e) {
    const n = new Lu();
    return n.comparator = this.comparator, n.keyedMap = t2, n.sortedSet = e, n;
  }
};
var Uu = class {
  constructor() {
    this.yu = new qt(dt.comparator);
  }
  track(t2) {
    const e = t2.doc.key, n = this.yu.get(e);
    n ? t2.type !== 0 && n.type === 3 ? this.yu = this.yu.insert(e, t2) : t2.type === 3 && n.type !== 1 ? this.yu = this.yu.insert(e, {
      type: n.type,
      doc: t2.doc
    }) : t2.type === 2 && n.type === 2 ? this.yu = this.yu.insert(e, {
      type: 2,
      doc: t2.doc
    }) : t2.type === 2 && n.type === 0 ? this.yu = this.yu.insert(e, {
      type: 0,
      doc: t2.doc
    }) : t2.type === 1 && n.type === 0 ? this.yu = this.yu.remove(e) : t2.type === 1 && n.type === 2 ? this.yu = this.yu.insert(e, {
      type: 1,
      doc: n.doc
    }) : t2.type === 0 && n.type === 1 ? this.yu = this.yu.insert(e, {
      type: 2,
      doc: t2.doc
    }) : L2() : this.yu = this.yu.insert(e, t2);
  }
  pu() {
    const t2 = [];
    return this.yu.inorderTraversal((e, n) => {
      t2.push(n);
    }), t2;
  }
};
var qu = class {
  constructor(t2, e, n, s, i, r, o, u) {
    this.query = t2, this.docs = e, this.oldDocs = n, this.docChanges = s, this.mutatedKeys = i, this.fromCache = r, this.syncStateChanged = o, this.excludesMetadataChanges = u;
  }
  static fromInitialDocuments(t2, e, n, s) {
    const i = [];
    return e.forEach((t3) => {
      i.push({
        type: 0,
        doc: t3
      });
    }), new qu(t2, e, Lu.emptySet(e), i, n, s, true, false);
  }
  get hasPendingWrites() {
    return !this.mutatedKeys.isEmpty();
  }
  isEqual(t2) {
    if (!(this.fromCache === t2.fromCache && this.syncStateChanged === t2.syncStateChanged && this.mutatedKeys.isEqual(t2.mutatedKeys) && dn(this.query, t2.query) && this.docs.isEqual(t2.docs) && this.oldDocs.isEqual(t2.oldDocs)))
      return false;
    const e = this.docChanges, n = t2.docChanges;
    if (e.length !== n.length)
      return false;
    for (let t3 = 0; t3 < e.length; t3++)
      if (e[t3].type !== n[t3].type || !e[t3].doc.isEqual(n[t3].doc))
        return false;
    return true;
  }
};
var Ku = class {
  constructor() {
    this.Iu = void 0, this.listeners = [];
  }
};
var Gu = class {
  constructor() {
    this.queries = new is((t2) => _n(t2), dn), this.onlineState = "Unknown", this.Tu = /* @__PURE__ */ new Set();
  }
};
async function Qu(t2, e) {
  const n = K2(t2), s = e.query;
  let i = false, r = n.queries.get(s);
  if (r || (i = true, r = new Ku()), i)
    try {
      r.Iu = await n.onListen(s);
    } catch (t3) {
      const n2 = Bu(t3, `Initialization of query '${wn(e.query)}' failed`);
      return void e.onError(n2);
    }
  if (n.queries.set(s, r), r.listeners.push(e), e.Eu(n.onlineState), r.Iu) {
    e.Au(r.Iu) && Hu(n);
  }
}
async function ju(t2, e) {
  const n = K2(t2), s = e.query;
  let i = false;
  const r = n.queries.get(s);
  if (r) {
    const t3 = r.listeners.indexOf(e);
    t3 >= 0 && (r.listeners.splice(t3, 1), i = r.listeners.length === 0);
  }
  if (i)
    return n.queries.delete(s), n.onUnlisten(s);
}
function Wu(t2, e) {
  const n = K2(t2);
  let s = false;
  for (const t3 of e) {
    const e2 = t3.query, i = n.queries.get(e2);
    if (i) {
      for (const e3 of i.listeners)
        e3.Au(t3) && (s = true);
      i.Iu = t3;
    }
  }
  s && Hu(n);
}
function zu(t2, e, n) {
  const s = K2(t2), i = s.queries.get(e);
  if (i)
    for (const t3 of i.listeners)
      t3.onError(n);
  s.queries.delete(e);
}
function Hu(t2) {
  t2.Tu.forEach((t3) => {
    t3.next();
  });
}
var Ju = class {
  constructor(t2, e, n) {
    this.query = t2, this.Ru = e, this.bu = false, this.Pu = null, this.onlineState = "Unknown", this.options = n || {};
  }
  Au(t2) {
    if (!this.options.includeMetadataChanges) {
      const e2 = [];
      for (const n of t2.docChanges)
        n.type !== 3 && e2.push(n);
      t2 = new qu(t2.query, t2.docs, t2.oldDocs, e2, t2.mutatedKeys, t2.fromCache, t2.syncStateChanged, true);
    }
    let e = false;
    return this.bu ? this.vu(t2) && (this.Ru.next(t2), e = true) : this.Vu(t2, this.onlineState) && (this.Su(t2), e = true), this.Pu = t2, e;
  }
  onError(t2) {
    this.Ru.error(t2);
  }
  Eu(t2) {
    this.onlineState = t2;
    let e = false;
    return this.Pu && !this.bu && this.Vu(this.Pu, t2) && (this.Su(this.Pu), e = true), e;
  }
  Vu(t2, e) {
    if (!t2.fromCache)
      return true;
    const n = e !== "Offline";
    return (!this.options.Du || !n) && (!t2.docs.isEmpty() || e === "Offline");
  }
  vu(t2) {
    if (t2.docChanges.length > 0)
      return true;
    const e = this.Pu && this.Pu.hasPendingWrites !== t2.hasPendingWrites;
    return !(!t2.syncStateChanged && !e) && this.options.includeMetadataChanges === true;
  }
  Su(t2) {
    t2 = qu.fromInitialDocuments(t2.query, t2.docs, t2.mutatedKeys, t2.fromCache), this.bu = true, this.Ru.next(t2);
  }
};
var Yu = class {
  constructor(t2, e) {
    this.payload = t2, this.byteLength = e;
  }
  Cu() {
    return "metadata" in this.payload;
  }
};
var Xu = class {
  constructor(t2) {
    this.wt = t2;
  }
  Wi(t2) {
    return Fs(this.wt, t2);
  }
  zi(t2) {
    return t2.metadata.exists ? Ks(this.wt, t2.document, false) : xe.newNoDocument(this.Wi(t2.metadata.name), this.Hi(t2.metadata.readTime));
  }
  Hi(t2) {
    return Ns(t2);
  }
};
var Zu = class {
  constructor(t2, e, n) {
    this.xu = t2, this.localStore = e, this.wt = n, this.queries = [], this.documents = [], this.collectionGroups = /* @__PURE__ */ new Set(), this.progress = tc2(t2);
  }
  Nu(t2) {
    this.progress.bytesLoaded += t2.byteLength;
    let e = this.progress.documentsLoaded;
    if (t2.payload.namedQuery)
      this.queries.push(t2.payload.namedQuery);
    else if (t2.payload.documentMetadata) {
      this.documents.push({
        metadata: t2.payload.documentMetadata
      }), t2.payload.documentMetadata.exists || ++e;
      const n = ht.fromString(t2.payload.documentMetadata.name);
      this.collectionGroups.add(n.get(n.length - 2));
    } else
      t2.payload.document && (this.documents[this.documents.length - 1].document = t2.payload.document, ++e);
    return e !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = e, Object.assign({}, this.progress)) : null;
  }
  ku(t2) {
    const e = /* @__PURE__ */ new Map(), n = new Xu(this.wt);
    for (const s of t2)
      if (s.metadata.queries) {
        const t3 = n.Wi(s.metadata.name);
        for (const n2 of s.metadata.queries) {
          const s2 = (e.get(n2) || ws()).add(t3);
          e.set(n2, s2);
        }
      }
    return e;
  }
  async complete() {
    const t2 = await Fo(this.localStore, new Xu(this.wt), this.documents, this.xu.id), e = this.ku(this.documents);
    for (const t3 of this.queries)
      await $o(this.localStore, t3, e.get(t3.name));
    return this.progress.taskState = "Success", {
      progress: this.progress,
      Ou: this.collectionGroups,
      Mu: t2
    };
  }
};
function tc2(t2) {
  return {
    taskState: "Running",
    documentsLoaded: 0,
    bytesLoaded: 0,
    totalDocuments: t2.totalDocuments,
    totalBytes: t2.totalBytes
  };
}
var ec2 = class {
  constructor(t2) {
    this.key = t2;
  }
};
var nc2 = class {
  constructor(t2) {
    this.key = t2;
  }
};
var sc2 = class {
  constructor(t2, e) {
    this.query = t2, this.Fu = e, this.$u = null, this.current = false, this.Bu = ws(), this.mutatedKeys = ws(), this.Lu = yn(t2), this.Uu = new Lu(this.Lu);
  }
  get qu() {
    return this.Fu;
  }
  Ku(t2, e) {
    const n = e ? e.Gu : new Uu(), s = e ? e.Uu : this.Uu;
    let i = e ? e.mutatedKeys : this.mutatedKeys, r = s, o = false;
    const u = this.query.limitType === "F" && s.size === this.query.limit ? s.last() : null, c = this.query.limitType === "L" && s.size === this.query.limit ? s.first() : null;
    if (t2.inorderTraversal((t3, e2) => {
      const a = s.get(t3), h = mn(this.query, e2) ? e2 : null, l2 = !!a && this.mutatedKeys.has(a.key), f = !!h && (h.hasLocalMutations || this.mutatedKeys.has(h.key) && h.hasCommittedMutations);
      let d = false;
      if (a && h) {
        a.data.isEqual(h.data) ? l2 !== f && (n.track({
          type: 3,
          doc: h
        }), d = true) : this.Qu(a, h) || (n.track({
          type: 2,
          doc: h
        }), d = true, (u && this.Lu(h, u) > 0 || c && this.Lu(h, c) < 0) && (o = true));
      } else
        !a && h ? (n.track({
          type: 0,
          doc: h
        }), d = true) : a && !h && (n.track({
          type: 1,
          doc: a
        }), d = true, (u || c) && (o = true));
      d && (h ? (r = r.add(h), i = f ? i.add(t3) : i.delete(t3)) : (r = r.delete(t3), i = i.delete(t3)));
    }), this.query.limit !== null)
      for (; r.size > this.query.limit; ) {
        const t3 = this.query.limitType === "F" ? r.last() : r.first();
        r = r.delete(t3.key), i = i.delete(t3.key), n.track({
          type: 1,
          doc: t3
        });
      }
    return {
      Uu: r,
      Gu: n,
      Oi: o,
      mutatedKeys: i
    };
  }
  Qu(t2, e) {
    return t2.hasLocalMutations && e.hasCommittedMutations && !e.hasLocalMutations;
  }
  applyChanges(t2, e, n) {
    const s = this.Uu;
    this.Uu = t2.Uu, this.mutatedKeys = t2.mutatedKeys;
    const i = t2.Gu.pu();
    i.sort((t3, e2) => function(t4, e3) {
      const n2 = (t5) => {
        switch (t5) {
          case 0:
            return 1;
          case 2:
          case 3:
            return 2;
          case 1:
            return 0;
          default:
            return L2();
        }
      };
      return n2(t4) - n2(e3);
    }(t3.type, e2.type) || this.Lu(t3.doc, e2.doc)), this.ju(n);
    const r = e ? this.Wu() : [], o = this.Bu.size === 0 && this.current ? 1 : 0, u = o !== this.$u;
    if (this.$u = o, i.length !== 0 || u) {
      return {
        snapshot: new qu(this.query, t2.Uu, s, i, t2.mutatedKeys, o === 0, u, false),
        zu: r
      };
    }
    return {
      zu: r
    };
  }
  Eu(t2) {
    return this.current && t2 === "Offline" ? (this.current = false, this.applyChanges({
      Uu: this.Uu,
      Gu: new Uu(),
      mutatedKeys: this.mutatedKeys,
      Oi: false
    }, false)) : {
      zu: []
    };
  }
  Hu(t2) {
    return !this.Fu.has(t2) && (!!this.Uu.has(t2) && !this.Uu.get(t2).hasLocalMutations);
  }
  ju(t2) {
    t2 && (t2.addedDocuments.forEach((t3) => this.Fu = this.Fu.add(t3)), t2.modifiedDocuments.forEach((t3) => {
    }), t2.removedDocuments.forEach((t3) => this.Fu = this.Fu.delete(t3)), this.current = t2.current);
  }
  Wu() {
    if (!this.current)
      return [];
    const t2 = this.Bu;
    this.Bu = ws(), this.Uu.forEach((t3) => {
      this.Hu(t3.key) && (this.Bu = this.Bu.add(t3.key));
    });
    const e = [];
    return t2.forEach((t3) => {
      this.Bu.has(t3) || e.push(new nc2(t3));
    }), this.Bu.forEach((n) => {
      t2.has(n) || e.push(new ec2(n));
    }), e;
  }
  Ju(t2) {
    this.Fu = t2.ji, this.Bu = ws();
    const e = this.Ku(t2.documents);
    return this.applyChanges(e, true);
  }
  Yu() {
    return qu.fromInitialDocuments(this.query, this.Uu, this.mutatedKeys, this.$u === 0);
  }
};
var ic2 = class {
  constructor(t2, e, n) {
    this.query = t2, this.targetId = e, this.view = n;
  }
};
var rc2 = class {
  constructor(t2) {
    this.key = t2, this.Xu = false;
  }
};
var oc2 = class {
  constructor(t2, e, n, s, i, r) {
    this.localStore = t2, this.remoteStore = e, this.eventManager = n, this.sharedClientState = s, this.currentUser = i, this.maxConcurrentLimboResolutions = r, this.Zu = {}, this.tc = new is((t3) => _n(t3), dn), this.ec = /* @__PURE__ */ new Map(), this.nc = /* @__PURE__ */ new Set(), this.sc = new qt(dt.comparator), this.ic = /* @__PURE__ */ new Map(), this.rc = new io(), this.oc = {}, this.uc = /* @__PURE__ */ new Map(), this.cc = kr.Rn(), this.onlineState = "Unknown", this.ac = void 0;
  }
  get isPrimaryClient() {
    return this.ac === true;
  }
};
async function uc2(t2, e) {
  const n = Mc2(t2);
  let s, i;
  const r = n.tc.get(e);
  if (r)
    s = r.targetId, n.sharedClientState.addLocalQueryTarget(s), i = r.view.Yu();
  else {
    const t3 = await Co(n.localStore, ln(e));
    n.isPrimaryClient && fu(n.remoteStore, t3);
    const r2 = n.sharedClientState.addLocalQueryTarget(t3.targetId);
    s = t3.targetId, i = await cc2(n, e, s, r2 === "current");
  }
  return i;
}
async function cc2(t2, e, n, s) {
  t2.hc = (e2, n2, s2) => async function(t3, e3, n3, s3) {
    let i2 = e3.view.Ku(n3);
    i2.Oi && (i2 = await No(t3.localStore, e3.query, false).then(({ documents: t4 }) => e3.view.Ku(t4, i2)));
    const r2 = s3 && s3.targetChanges.get(e3.targetId), o2 = e3.view.applyChanges(i2, t3.isPrimaryClient, r2);
    return Tc2(t3, e3.targetId, o2.zu), o2.snapshot;
  }(t2, e2, n2, s2);
  const i = await No(t2.localStore, e, true), r = new sc2(e, i.ji), o = r.Ku(i.documents), u = ps.createSynthesizedTargetChangeForCurrentChange(n, s && t2.onlineState !== "Offline"), c = r.applyChanges(o, t2.isPrimaryClient, u);
  Tc2(t2, n, c.zu);
  const a = new ic2(e, n, r);
  return t2.tc.set(e, a), t2.ec.has(n) ? t2.ec.get(n).push(e) : t2.ec.set(n, [e]), c.snapshot;
}
async function ac2(t2, e) {
  const n = K2(t2), s = n.tc.get(e), i = n.ec.get(s.targetId);
  if (i.length > 1)
    return n.ec.set(s.targetId, i.filter((t3) => !dn(t3, e))), void n.tc.delete(e);
  if (n.isPrimaryClient) {
    n.sharedClientState.removeLocalQueryTarget(s.targetId);
    n.sharedClientState.isActiveQueryTarget(s.targetId) || await xo(n.localStore, s.targetId, false).then(() => {
      n.sharedClientState.clearQueryState(s.targetId), du(n.remoteStore, s.targetId), pc2(n, s.targetId);
    }).catch(bt);
  } else
    pc2(n, s.targetId), await xo(n.localStore, s.targetId, true);
}
async function hc2(t2, e, n) {
  const s = Fc2(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = K2(t4), s2 = ut.now(), i = e2.reduce((t5, e3) => t5.add(e3.key), ws());
      let r, o;
      return n2.persistence.runTransaction("Locally write mutations", "readwrite", (t5) => {
        let u = os(), c = ws();
        return n2.Ui.getEntries(t5, i).next((t6) => {
          u = t6, u.forEach((t7, e3) => {
            e3.isValidDocument() || (c = c.add(t7));
          });
        }).next(() => n2.localDocuments.getOverlayedDocuments(t5, u)).next((i2) => {
          r = i2;
          const o2 = [];
          for (const t6 of e2) {
            const e3 = Gn(t6, r.get(t6.key).overlayedDocument);
            e3 != null && o2.push(new Wn(t6.key, e3, Ce(e3.value.mapValue), $n.exists(true)));
          }
          return n2.mutationQueue.addMutationBatch(t5, s2, o2, e2);
        }).next((e3) => {
          o = e3;
          const s3 = e3.applyToLocalDocumentSet(r, c);
          return n2.documentOverlayCache.saveOverlays(t5, e3.batchId, s3);
        });
      }).then(() => ({
        batchId: o.batchId,
        changes: as(r)
      }));
    }(s.localStore, e);
    s.sharedClientState.addPendingMutation(t3.batchId), function(t4, e2, n2) {
      let s2 = t4.oc[t4.currentUser.toKey()];
      s2 || (s2 = new qt(it));
      s2 = s2.insert(e2, n2), t4.oc[t4.currentUser.toKey()] = s2;
    }(s, t3.batchId, n), await Rc2(s, t3.changes), await bu(s.remoteStore);
  } catch (t3) {
    const e2 = Bu(t3, "Failed to persist write");
    n.reject(e2);
  }
}
async function lc2(t2, e) {
  const n = K2(t2);
  try {
    const t3 = await Vo(n.localStore, e);
    e.targetChanges.forEach((t4, e2) => {
      const s = n.ic.get(e2);
      s && (U2(t4.addedDocuments.size + t4.modifiedDocuments.size + t4.removedDocuments.size <= 1), t4.addedDocuments.size > 0 ? s.Xu = true : t4.modifiedDocuments.size > 0 ? U2(s.Xu) : t4.removedDocuments.size > 0 && (U2(s.Xu), s.Xu = false));
    }), await Rc2(n, t3, e);
  } catch (t3) {
    await bt(t3);
  }
}
function fc2(t2, e, n) {
  const s = K2(t2);
  if (s.isPrimaryClient && n === 0 || !s.isPrimaryClient && n === 1) {
    const t3 = [];
    s.tc.forEach((n2, s2) => {
      const i = s2.view.Eu(e);
      i.snapshot && t3.push(i.snapshot);
    }), function(t4, e2) {
      const n2 = K2(t4);
      n2.onlineState = e2;
      let s2 = false;
      n2.queries.forEach((t5, n3) => {
        for (const t6 of n3.listeners)
          t6.Eu(e2) && (s2 = true);
      }), s2 && Hu(n2);
    }(s.eventManager, e), t3.length && s.Zu.Go(t3), s.onlineState = e, s.isPrimaryClient && s.sharedClientState.setOnlineState(e);
  }
}
async function dc2(t2, e, n) {
  const s = K2(t2);
  s.sharedClientState.updateQueryState(e, "rejected", n);
  const i = s.ic.get(e), r = i && i.key;
  if (r) {
    let t3 = new qt(dt.comparator);
    t3 = t3.insert(r, xe.newNoDocument(r, ct.min()));
    const n2 = ws().add(r), i2 = new ys(ct.min(), /* @__PURE__ */ new Map(), new Qt(it), t3, n2);
    await lc2(s, i2), s.sc = s.sc.remove(r), s.ic.delete(e), Ac2(s);
  } else
    await xo(s.localStore, e, false).then(() => pc2(s, e, n)).catch(bt);
}
async function _c(t2, e) {
  const n = K2(t2), s = e.batch.batchId;
  try {
    const t3 = await Po(n.localStore, e);
    yc2(n, s, null), gc2(n, s), n.sharedClientState.updateMutationState(s, "acknowledged"), await Rc2(n, t3);
  } catch (t3) {
    await bt(t3);
  }
}
async function wc2(t2, e, n) {
  const s = K2(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = K2(t4);
      return n2.persistence.runTransaction("Reject batch", "readwrite-primary", (t5) => {
        let s2;
        return n2.mutationQueue.lookupMutationBatch(t5, e2).next((e3) => (U2(e3 !== null), s2 = e3.keys(), n2.mutationQueue.removeMutationBatch(t5, e3))).next(() => n2.mutationQueue.performConsistencyCheck(t5)).next(() => n2.documentOverlayCache.removeOverlaysForBatchId(t5, s2, e2)).next(() => n2.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(t5, s2)).next(() => n2.localDocuments.getDocuments(t5, s2));
      });
    }(s.localStore, e);
    yc2(s, e, n), gc2(s, e), s.sharedClientState.updateMutationState(e, "rejected", n), await Rc2(s, t3);
  } catch (n2) {
    await bt(n2);
  }
}
async function mc2(t2, e) {
  const n = K2(t2);
  yu(n.remoteStore) || M2("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
  try {
    const t3 = await function(t4) {
      const e2 = K2(t4);
      return e2.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", (t5) => e2.mutationQueue.getHighestUnacknowledgedBatchId(t5));
    }(n.localStore);
    if (t3 === -1)
      return void e.resolve();
    const s = n.uc.get(t3) || [];
    s.push(e), n.uc.set(t3, s);
  } catch (t3) {
    const n2 = Bu(t3, "Initialization of waitForPendingWrites() operation failed");
    e.reject(n2);
  }
}
function gc2(t2, e) {
  (t2.uc.get(e) || []).forEach((t3) => {
    t3.resolve();
  }), t2.uc.delete(e);
}
function yc2(t2, e, n) {
  const s = K2(t2);
  let i = s.oc[s.currentUser.toKey()];
  if (i) {
    const t3 = i.get(e);
    t3 && (n ? t3.reject(n) : t3.resolve(), i = i.remove(e)), s.oc[s.currentUser.toKey()] = i;
  }
}
function pc2(t2, e, n = null) {
  t2.sharedClientState.removeLocalQueryTarget(e);
  for (const s of t2.ec.get(e))
    t2.tc.delete(s), n && t2.Zu.lc(s, n);
  if (t2.ec.delete(e), t2.isPrimaryClient) {
    t2.rc.us(e).forEach((e2) => {
      t2.rc.containsKey(e2) || Ic2(t2, e2);
    });
  }
}
function Ic2(t2, e) {
  t2.nc.delete(e.path.canonicalString());
  const n = t2.sc.get(e);
  n !== null && (du(t2.remoteStore, n), t2.sc = t2.sc.remove(e), t2.ic.delete(n), Ac2(t2));
}
function Tc2(t2, e, n) {
  for (const s of n)
    if (s instanceof ec2)
      t2.rc.addReference(s.key, e), Ec2(t2, s);
    else if (s instanceof nc2) {
      M2("SyncEngine", "Document no longer in limbo: " + s.key), t2.rc.removeReference(s.key, e);
      t2.rc.containsKey(s.key) || Ic2(t2, s.key);
    } else
      L2();
}
function Ec2(t2, e) {
  const n = e.key, s = n.path.canonicalString();
  t2.sc.get(n) || t2.nc.has(s) || (M2("SyncEngine", "New document in limbo: " + n), t2.nc.add(s), Ac2(t2));
}
function Ac2(t2) {
  for (; t2.nc.size > 0 && t2.sc.size < t2.maxConcurrentLimboResolutions; ) {
    const e = t2.nc.values().next().value;
    t2.nc.delete(e);
    const n = new dt(ht.fromString(e)), s = t2.cc.next();
    t2.ic.set(s, new rc2(n)), t2.sc = t2.sc.insert(n, s), fu(t2.remoteStore, new Li(ln(rn(n.path)), s, 2, $t.ot));
  }
}
async function Rc2(t2, e, n) {
  const s = K2(t2), i = [], r = [], o = [];
  s.tc.isEmpty() || (s.tc.forEach((t3, u) => {
    o.push(s.hc(u, e, n).then((t4) => {
      if (t4) {
        s.isPrimaryClient && s.sharedClientState.updateQueryState(u.targetId, t4.fromCache ? "not-current" : "current"), i.push(t4);
        const e2 = To.Vi(u.targetId, t4);
        r.push(e2);
      }
    }));
  }), await Promise.all(o), s.Zu.Go(i), await async function(t3, e2) {
    const n2 = K2(t3);
    try {
      await n2.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (t4) => Pt.forEach(e2, (e3) => Pt.forEach(e3.Pi, (s2) => n2.persistence.referenceDelegate.addReference(t4, e3.targetId, s2)).next(() => Pt.forEach(e3.vi, (s2) => n2.persistence.referenceDelegate.removeReference(t4, e3.targetId, s2)))));
    } catch (t4) {
      if (!Ct(t4))
        throw t4;
      M2("LocalStore", "Failed to update sequence numbers: " + t4);
    }
    for (const t4 of e2) {
      const e3 = t4.targetId;
      if (!t4.fromCache) {
        const t5 = n2.$i.get(e3), s2 = t5.snapshotVersion, i2 = t5.withLastLimboFreeSnapshotVersion(s2);
        n2.$i = n2.$i.insert(e3, i2);
      }
    }
  }(s.localStore, r));
}
async function bc2(t2, e) {
  const n = K2(t2);
  if (!n.currentUser.isEqual(e)) {
    M2("SyncEngine", "User change. New user:", e.toKey());
    const t3 = await bo(n.localStore, e);
    n.currentUser = e, function(t4, e2) {
      t4.uc.forEach((t5) => {
        t5.forEach((t6) => {
          t6.reject(new Q2(G.CANCELLED, e2));
        });
      }), t4.uc.clear();
    }(n, "'waitForPendingWrites' promise is rejected due to a user change."), n.sharedClientState.handleUserChange(e, t3.removedBatchIds, t3.addedBatchIds), await Rc2(n, t3.Ki);
  }
}
function Pc2(t2, e) {
  const n = K2(t2), s = n.ic.get(e);
  if (s && s.Xu)
    return ws().add(s.key);
  {
    let t3 = ws();
    const s2 = n.ec.get(e);
    if (!s2)
      return t3;
    for (const e2 of s2) {
      const s3 = n.tc.get(e2);
      t3 = t3.unionWith(s3.view.qu);
    }
    return t3;
  }
}
async function vc2(t2, e) {
  const n = K2(t2), s = await No(n.localStore, e.query, true), i = e.view.Ju(s);
  return n.isPrimaryClient && Tc2(n, e.targetId, i.zu), i;
}
async function Vc2(t2, e) {
  const n = K2(t2);
  return Oo(n.localStore, e).then((t3) => Rc2(n, t3));
}
async function Sc2(t2, e, n, s) {
  const i = K2(t2), r = await function(t3, e2) {
    const n2 = K2(t3), s2 = K2(n2.mutationQueue);
    return n2.persistence.runTransaction("Lookup mutation documents", "readonly", (t4) => s2.yn(t4, e2).next((e3) => e3 ? n2.localDocuments.getDocuments(t4, e3) : Pt.resolve(null)));
  }(i.localStore, e);
  r !== null ? (n === "pending" ? await bu(i.remoteStore) : n === "acknowledged" || n === "rejected" ? (yc2(i, e, s || null), gc2(i, e), function(t3, e2) {
    K2(K2(t3).mutationQueue).In(e2);
  }(i.localStore, e)) : L2(), await Rc2(i, r)) : M2("SyncEngine", "Cannot apply mutation batch with id: " + e);
}
async function Dc2(t2, e) {
  const n = K2(t2);
  if (Mc2(n), Fc2(n), e === true && n.ac !== true) {
    const t3 = n.sharedClientState.getAllActiveQueryTargets(), e2 = await Cc2(n, t3.toArray());
    n.ac = true, await Ou(n.remoteStore, true);
    for (const t4 of e2)
      fu(n.remoteStore, t4);
  } else if (e === false && n.ac !== false) {
    const t3 = [];
    let e2 = Promise.resolve();
    n.ec.forEach((s, i) => {
      n.sharedClientState.isLocalQueryTarget(i) ? t3.push(i) : e2 = e2.then(() => (pc2(n, i), xo(n.localStore, i, true))), du(n.remoteStore, i);
    }), await e2, await Cc2(n, t3), function(t4) {
      const e3 = K2(t4);
      e3.ic.forEach((t5, n2) => {
        du(e3.remoteStore, n2);
      }), e3.rc.cs(), e3.ic = /* @__PURE__ */ new Map(), e3.sc = new qt(dt.comparator);
    }(n), n.ac = false, await Ou(n.remoteStore, false);
  }
}
async function Cc2(t2, e, n) {
  const s = K2(t2), i = [], r = [];
  for (const t3 of e) {
    let e2;
    const n2 = s.ec.get(t3);
    if (n2 && n2.length !== 0) {
      e2 = await Co(s.localStore, ln(n2[0]));
      for (const t4 of n2) {
        const e3 = s.tc.get(t4), n3 = await vc2(s, e3);
        n3.snapshot && r.push(n3.snapshot);
      }
    } else {
      const n3 = await ko(s.localStore, t3);
      e2 = await Co(s.localStore, n3), await cc2(s, xc2(n3), t3, false);
    }
    i.push(e2);
  }
  return s.Zu.Go(r), i;
}
function xc2(t2) {
  return sn(t2.path, t2.collectionGroup, t2.orderBy, t2.filters, t2.limit, "F", t2.startAt, t2.endAt);
}
function Nc2(t2) {
  const e = K2(t2);
  return K2(K2(e.localStore).persistence).Ri();
}
async function kc2(t2, e, n, s) {
  const i = K2(t2);
  if (i.ac)
    return void M2("SyncEngine", "Ignoring unexpected query state notification.");
  const r = i.ec.get(e);
  if (r && r.length > 0)
    switch (n) {
      case "current":
      case "not-current": {
        const t3 = await Oo(i.localStore, gn(r[0])), s2 = ys.createSynthesizedRemoteEventForCurrentChange(e, n === "current");
        await Rc2(i, t3, s2);
        break;
      }
      case "rejected":
        await xo(i.localStore, e, true), pc2(i, e, s);
        break;
      default:
        L2();
    }
}
async function Oc2(t2, e, n) {
  const s = Mc2(t2);
  if (s.ac) {
    for (const t3 of e) {
      if (s.ec.has(t3)) {
        M2("SyncEngine", "Adding an already active target " + t3);
        continue;
      }
      const e2 = await ko(s.localStore, t3), n2 = await Co(s.localStore, e2);
      await cc2(s, xc2(e2), n2.targetId, false), fu(s.remoteStore, n2);
    }
    for (const t3 of n)
      s.ec.has(t3) && await xo(s.localStore, t3, false).then(() => {
        du(s.remoteStore, t3), pc2(s, t3);
      }).catch(bt);
  }
}
function Mc2(t2) {
  const e = K2(t2);
  return e.remoteStore.remoteSyncer.applyRemoteEvent = lc2.bind(null, e), e.remoteStore.remoteSyncer.getRemoteKeysForTarget = Pc2.bind(null, e), e.remoteStore.remoteSyncer.rejectListen = dc2.bind(null, e), e.Zu.Go = Wu.bind(null, e.eventManager), e.Zu.lc = zu.bind(null, e.eventManager), e;
}
function Fc2(t2) {
  const e = K2(t2);
  return e.remoteStore.remoteSyncer.applySuccessfulWrite = _c.bind(null, e), e.remoteStore.remoteSyncer.rejectFailedWrite = wc2.bind(null, e), e;
}
function $c2(t2, e, n) {
  const s = K2(t2);
  (async function(t3, e2, n2) {
    try {
      const s2 = await e2.getMetadata();
      if (await function(t4, e3) {
        const n3 = K2(t4), s3 = Ns(e3.createTime);
        return n3.persistence.runTransaction("hasNewerBundle", "readonly", (t5) => n3.Ds.getBundleMetadata(t5, e3.id)).then((t5) => !!t5 && t5.createTime.compareTo(s3) >= 0);
      }(t3.localStore, s2))
        return await e2.close(), n2._completeWith(function(t4) {
          return {
            taskState: "Success",
            documentsLoaded: t4.totalDocuments,
            bytesLoaded: t4.totalBytes,
            totalDocuments: t4.totalDocuments,
            totalBytes: t4.totalBytes
          };
        }(s2)), Promise.resolve(/* @__PURE__ */ new Set());
      n2._updateProgress(tc2(s2));
      const i = new Zu(s2, t3.localStore, e2.wt);
      let r = await e2.fc();
      for (; r; ) {
        const t4 = await i.Nu(r);
        t4 && n2._updateProgress(t4), r = await e2.fc();
      }
      const o = await i.complete();
      return await Rc2(t3, o.Mu, void 0), await function(t4, e3) {
        const n3 = K2(t4);
        return n3.persistence.runTransaction("Save bundle", "readwrite", (t5) => n3.Ds.saveBundleMetadata(t5, e3));
      }(t3.localStore, s2), n2._completeWith(o.progress), Promise.resolve(o.Ou);
    } catch (t4) {
      return $("SyncEngine", `Loading bundle failed with ${t4}`), n2._failWith(t4), Promise.resolve(/* @__PURE__ */ new Set());
    }
  })(s, e, n).then((t3) => {
    s.sharedClientState.notifyBundleLoaded(t3);
  });
}
var Bc2 = class {
  constructor() {
    this.synchronizeTabs = false;
  }
  async initialize(t2) {
    this.wt = nu(t2.databaseInfo.databaseId), this.sharedClientState = this.dc(t2), this.persistence = this._c(t2), await this.persistence.start(), this.localStore = this.wc(t2), this.gcScheduler = this.mc(t2, this.localStore), this.indexBackfillerScheduler = this.gc(t2, this.localStore);
  }
  mc(t2, e) {
    return null;
  }
  gc(t2, e) {
    return null;
  }
  wc(t2) {
    return Ro(this.persistence, new Eo(), t2.initialUser, this.wt);
  }
  _c(t2) {
    return new ho(fo.Ms, this.wt);
  }
  dc(t2) {
    return new zo();
  }
  async terminate() {
    this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown();
  }
};
var Lc2 = class extends Bc2 {
  constructor(t2, e, n) {
    super(), this.yc = t2, this.cacheSizeBytes = e, this.forceOwnership = n, this.synchronizeTabs = false;
  }
  async initialize(t2) {
    await super.initialize(t2), await this.yc.initialize(this, t2), await Fc2(this.yc.syncEngine), await bu(this.yc.remoteStore), await this.persistence.ci(() => (this.gcScheduler && !this.gcScheduler.started && this.gcScheduler.start(), this.indexBackfillerScheduler && !this.indexBackfillerScheduler.started && this.indexBackfillerScheduler.start(), Promise.resolve()));
  }
  wc(t2) {
    return Ro(this.persistence, new Eo(), t2.initialUser, this.wt);
  }
  mc(t2, e) {
    const n = this.persistence.referenceDelegate.garbageCollector;
    return new Ur(n, t2.asyncQueue, e);
  }
  gc(t2, e) {
    const n = new Ft(e, this.persistence);
    return new Mt(t2.asyncQueue, n);
  }
  _c(t2) {
    const e = Io(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey), n = this.cacheSizeBytes !== void 0 ? Pr.withCacheSize(this.cacheSizeBytes) : Pr.DEFAULT;
    return new go(this.synchronizeTabs, e, t2.clientId, n, t2.asyncQueue, tu(), eu(), this.wt, this.sharedClientState, !!this.forceOwnership);
  }
  dc(t2) {
    return new zo();
  }
};
var Uc2 = class extends Lc2 {
  constructor(t2, e) {
    super(t2, e, false), this.yc = t2, this.cacheSizeBytes = e, this.synchronizeTabs = true;
  }
  async initialize(t2) {
    await super.initialize(t2);
    const e = this.yc.syncEngine;
    this.sharedClientState instanceof Wo && (this.sharedClientState.syncEngine = {
      kr: Sc2.bind(null, e),
      Or: kc2.bind(null, e),
      Mr: Oc2.bind(null, e),
      Ri: Nc2.bind(null, e),
      Nr: Vc2.bind(null, e)
    }, await this.sharedClientState.start()), await this.persistence.ci(async (t3) => {
      await Dc2(this.yc.syncEngine, t3), this.gcScheduler && (t3 && !this.gcScheduler.started ? this.gcScheduler.start() : t3 || this.gcScheduler.stop()), this.indexBackfillerScheduler && (t3 && !this.indexBackfillerScheduler.started ? this.indexBackfillerScheduler.start() : t3 || this.indexBackfillerScheduler.stop());
    });
  }
  dc(t2) {
    const e = tu();
    if (!Wo.V(e))
      throw new Q2(G.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage.");
    const n = Io(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey);
    return new Wo(e, t2.asyncQueue, n, t2.clientId, t2.initialUser);
  }
};
var qc2 = class {
  async initialize(t2, e) {
    this.localStore || (this.localStore = t2.localStore, this.sharedClientState = t2.sharedClientState, this.datastore = this.createDatastore(e), this.remoteStore = this.createRemoteStore(e), this.eventManager = this.createEventManager(e), this.syncEngine = this.createSyncEngine(e, !t2.synchronizeTabs), this.sharedClientState.onlineStateHandler = (t3) => fc2(this.syncEngine, t3, 1), this.remoteStore.remoteSyncer.handleCredentialChange = bc2.bind(null, this.syncEngine), await Ou(this.remoteStore, this.syncEngine.isPrimaryClient));
  }
  createEventManager(t2) {
    return new Gu();
  }
  createDatastore(t2) {
    const e = nu(t2.databaseInfo.databaseId), n = (s = t2.databaseInfo, new Zo(s));
    var s;
    return function(t3, e2, n2, s2) {
      return new uu(t3, e2, n2, s2);
    }(t2.authCredentials, t2.appCheckCredentials, n, e);
  }
  createRemoteStore(t2) {
    return e = this.localStore, n = this.datastore, s = t2.asyncQueue, i = (t3) => fc2(this.syncEngine, t3, 0), r = Jo.V() ? new Jo() : new Ho(), new au(e, n, s, i, r);
    var e, n, s, i, r;
  }
  createSyncEngine(t2, e) {
    return function(t3, e2, n, s, i, r, o) {
      const u = new oc2(t3, e2, n, s, i, r);
      return o && (u.ac = true), u;
    }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t2.initialUser, t2.maxConcurrentLimboResolutions, e);
  }
  terminate() {
    return async function(t2) {
      const e = K2(t2);
      M2("RemoteStore", "RemoteStore shutting down."), e.lu.add(5), await lu(e), e.du.shutdown(), e._u.set("Unknown");
    }(this.remoteStore);
  }
};
function Kc2(t2, e = 10240) {
  let n = 0;
  return {
    async read() {
      if (n < t2.byteLength) {
        const s = {
          value: t2.slice(n, n + e),
          done: false
        };
        return n += e, s;
      }
      return {
        done: true
      };
    },
    async cancel() {
    },
    releaseLock() {
    },
    closed: Promise.reject("unimplemented")
  };
}
var Gc2 = class {
  constructor(t2) {
    this.observer = t2, this.muted = false;
  }
  next(t2) {
    this.observer.next && this.Ic(this.observer.next, t2);
  }
  error(t2) {
    this.observer.error ? this.Ic(this.observer.error, t2) : console.error("Uncaught Error in snapshot listener:", t2);
  }
  Tc() {
    this.muted = true;
  }
  Ic(t2, e) {
    this.muted || setTimeout(() => {
      this.muted || t2(e);
    }, 0);
  }
};
var Qc2 = class {
  constructor(t2, e) {
    this.Ec = t2, this.wt = e, this.metadata = new j(), this.buffer = new Uint8Array(), this.Ac = new TextDecoder("utf-8"), this.Rc().then((t3) => {
      t3 && t3.Cu() ? this.metadata.resolve(t3.payload.metadata) : this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is
             ${JSON.stringify(t3 == null ? void 0 : t3.payload)}`));
    }, (t3) => this.metadata.reject(t3));
  }
  close() {
    return this.Ec.cancel();
  }
  async getMetadata() {
    return this.metadata.promise;
  }
  async fc() {
    return await this.getMetadata(), this.Rc();
  }
  async Rc() {
    const t2 = await this.bc();
    if (t2 === null)
      return null;
    const e = this.Ac.decode(t2), n = Number(e);
    isNaN(n) && this.Pc(`length string (${e}) is not valid number`);
    const s = await this.vc(n);
    return new Yu(JSON.parse(s), t2.length + n);
  }
  Vc() {
    return this.buffer.findIndex((t2) => t2 === "{".charCodeAt(0));
  }
  async bc() {
    for (; this.Vc() < 0; ) {
      if (await this.Sc())
        break;
    }
    if (this.buffer.length === 0)
      return null;
    const t2 = this.Vc();
    t2 < 0 && this.Pc("Reached the end of bundle when a length string is expected.");
    const e = this.buffer.slice(0, t2);
    return this.buffer = this.buffer.slice(t2), e;
  }
  async vc(t2) {
    for (; this.buffer.length < t2; ) {
      await this.Sc() && this.Pc("Reached the end of bundle when more is expected.");
    }
    const e = this.Ac.decode(this.buffer.slice(0, t2));
    return this.buffer = this.buffer.slice(t2), e;
  }
  Pc(t2) {
    throw this.Ec.cancel(), new Error(`Invalid bundle format: ${t2}`);
  }
  async Sc() {
    const t2 = await this.Ec.read();
    if (!t2.done) {
      const e = new Uint8Array(this.buffer.length + t2.value.length);
      e.set(this.buffer), e.set(t2.value, this.buffer.length), this.buffer = e;
    }
    return t2.done;
  }
};
var jc2 = class {
  constructor(t2) {
    this.datastore = t2, this.readVersions = /* @__PURE__ */ new Map(), this.mutations = [], this.committed = false, this.lastWriteError = null, this.writtenDocs = /* @__PURE__ */ new Set();
  }
  async lookup(t2) {
    if (this.ensureCommitNotCalled(), this.mutations.length > 0)
      throw new Q2(G.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes.");
    const e = await async function(t3, e2) {
      const n = K2(t3), s = Ls(n.wt) + "/documents", i = {
        documents: e2.map((t4) => Ms(n.wt, t4))
      }, r = await n.ao("BatchGetDocuments", s, i), o = /* @__PURE__ */ new Map();
      r.forEach((t4) => {
        const e3 = Gs(n.wt, t4);
        o.set(e3.key.toString(), e3);
      });
      const u = [];
      return e2.forEach((t4) => {
        const e3 = o.get(t4.toString());
        U2(!!e3), u.push(e3);
      }), u;
    }(this.datastore, t2);
    return e.forEach((t3) => this.recordVersion(t3)), e;
  }
  set(t2, e) {
    this.write(e.toMutation(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  update(t2, e) {
    try {
      this.write(e.toMutation(t2, this.preconditionForUpdate(t2)));
    } catch (t3) {
      this.lastWriteError = t3;
    }
    this.writtenDocs.add(t2.toString());
  }
  delete(t2) {
    this.write(new Yn(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  async commit() {
    if (this.ensureCommitNotCalled(), this.lastWriteError)
      throw this.lastWriteError;
    const t2 = this.readVersions;
    this.mutations.forEach((e) => {
      t2.delete(e.key.toString());
    }), t2.forEach((t3, e) => {
      const n = dt.fromPath(e);
      this.mutations.push(new Xn(n, this.precondition(n)));
    }), await async function(t3, e) {
      const n = K2(t3), s = Ls(n.wt) + "/documents", i = {
        writes: e.map((t4) => js(n.wt, t4))
      };
      await n.ro("Commit", s, i);
    }(this.datastore, this.mutations), this.committed = true;
  }
  recordVersion(t2) {
    let e;
    if (t2.isFoundDocument())
      e = t2.version;
    else {
      if (!t2.isNoDocument())
        throw L2();
      e = ct.min();
    }
    const n = this.readVersions.get(t2.key.toString());
    if (n) {
      if (!e.isEqual(n))
        throw new Q2(G.ABORTED, "Document version changed between two reads.");
    } else
      this.readVersions.set(t2.key.toString(), e);
  }
  precondition(t2) {
    const e = this.readVersions.get(t2.toString());
    return !this.writtenDocs.has(t2.toString()) && e ? $n.updateTime(e) : $n.none();
  }
  preconditionForUpdate(t2) {
    const e = this.readVersions.get(t2.toString());
    if (!this.writtenDocs.has(t2.toString()) && e) {
      if (e.isEqual(ct.min()))
        throw new Q2(G.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
      return $n.updateTime(e);
    }
    return $n.exists(true);
  }
  write(t2) {
    this.ensureCommitNotCalled(), this.mutations.push(t2);
  }
  ensureCommitNotCalled() {
  }
};
var Wc2 = class {
  constructor(t2, e, n, s, i) {
    this.asyncQueue = t2, this.datastore = e, this.options = n, this.updateFunction = s, this.deferred = i, this.Dc = n.maxAttempts, this.So = new su(this.asyncQueue, "transaction_retry");
  }
  run() {
    this.Dc -= 1, this.Cc();
  }
  Cc() {
    this.So.Io(async () => {
      const t2 = new jc2(this.datastore), e = this.xc(t2);
      e && e.then((e2) => {
        this.asyncQueue.enqueueAndForget(() => t2.commit().then(() => {
          this.deferred.resolve(e2);
        }).catch((t3) => {
          this.Nc(t3);
        }));
      }).catch((t3) => {
        this.Nc(t3);
      });
    });
  }
  xc(t2) {
    try {
      const e = this.updateFunction(t2);
      return !oe(e) && e.catch && e.then ? e : (this.deferred.reject(Error("Transaction callback must return a Promise")), null);
    } catch (t3) {
      return this.deferred.reject(t3), null;
    }
  }
  Nc(t2) {
    this.Dc > 0 && this.kc(t2) ? (this.Dc -= 1, this.asyncQueue.enqueueAndForget(() => (this.Cc(), Promise.resolve()))) : this.deferred.reject(t2);
  }
  kc(t2) {
    if (t2.name === "FirebaseError") {
      const e = t2.code;
      return e === "aborted" || e === "failed-precondition" || !ns(e);
    }
    return false;
  }
};
var zc2 = class {
  constructor(t2, e, n, s) {
    this.authCredentials = t2, this.appCheckCredentials = e, this.asyncQueue = n, this.databaseInfo = s, this.user = C2.UNAUTHENTICATED, this.clientId = st.I(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this.authCredentials.start(n, async (t3) => {
      M2("FirestoreClient", "Received user=", t3.uid), await this.authCredentialListener(t3), this.user = t3;
    }), this.appCheckCredentials.start(n, (t3) => (M2("FirestoreClient", "Received new app check token=", t3), this.appCheckCredentialListener(t3, this.user)));
  }
  async getConfiguration() {
    return {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      authCredentials: this.authCredentials,
      appCheckCredentials: this.appCheckCredentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100
    };
  }
  setCredentialChangeListener(t2) {
    this.authCredentialListener = t2;
  }
  setAppCheckTokenChangeListener(t2) {
    this.appCheckCredentialListener = t2;
  }
  verifyNotTerminated() {
    if (this.asyncQueue.isShuttingDown)
      throw new Q2(G.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode();
    const t2 = new j();
    return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
      try {
        this.onlineComponents && await this.onlineComponents.terminate(), this.offlineComponents && await this.offlineComponents.terminate(), this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), t2.resolve();
      } catch (e) {
        const n = Bu(e, "Failed to shutdown persistence");
        t2.reject(n);
      }
    }), t2.promise;
  }
};
async function Hc2(t2, e) {
  t2.asyncQueue.verifyOperationInProgress(), M2("FirestoreClient", "Initializing OfflineComponentProvider");
  const n = await t2.getConfiguration();
  await e.initialize(n);
  let s = n.initialUser;
  t2.setCredentialChangeListener(async (t3) => {
    s.isEqual(t3) || (await bo(e.localStore, t3), s = t3);
  }), e.persistence.setDatabaseDeletedListener(() => t2.terminate()), t2.offlineComponents = e;
}
async function Jc2(t2, e) {
  t2.asyncQueue.verifyOperationInProgress();
  const n = await Yc2(t2);
  M2("FirestoreClient", "Initializing OnlineComponentProvider");
  const s = await t2.getConfiguration();
  await e.initialize(n, s), t2.setCredentialChangeListener((t3) => ku(e.remoteStore, t3)), t2.setAppCheckTokenChangeListener((t3, n2) => ku(e.remoteStore, n2)), t2.onlineComponents = e;
}
async function Yc2(t2) {
  return t2.offlineComponents || (M2("FirestoreClient", "Using default OfflineComponentProvider"), await Hc2(t2, new Bc2())), t2.offlineComponents;
}
async function Xc2(t2) {
  return t2.onlineComponents || (M2("FirestoreClient", "Using default OnlineComponentProvider"), await Jc2(t2, new qc2())), t2.onlineComponents;
}
function Zc2(t2) {
  return Yc2(t2).then((t3) => t3.persistence);
}
function ta2(t2) {
  return Yc2(t2).then((t3) => t3.localStore);
}
function ea2(t2) {
  return Xc2(t2).then((t3) => t3.remoteStore);
}
function na2(t2) {
  return Xc2(t2).then((t3) => t3.syncEngine);
}
async function sa2(t2) {
  const e = await Xc2(t2), n = e.eventManager;
  return n.onListen = uc2.bind(null, e.syncEngine), n.onUnlisten = ac2.bind(null, e.syncEngine), n;
}
function ia2(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await Zc2(t2), n = await ea2(t2);
    return e.setNetworkEnabled(true), function(t3) {
      const e2 = K2(t3);
      return e2.lu.delete(0), hu(e2);
    }(n);
  });
}
function ra2(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await Zc2(t2), n = await ea2(t2);
    return e.setNetworkEnabled(false), async function(t3) {
      const e2 = K2(t3);
      e2.lu.add(0), await lu(e2), e2._u.set("Offline");
    }(n);
  });
}
function oa2(t2, e) {
  const n = new j();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await function(t4, e3) {
        const n3 = K2(t4);
        return n3.persistence.runTransaction("read document", "readonly", (t5) => n3.localDocuments.getDocument(t5, e3));
      }(t3, e2);
      s.isFoundDocument() ? n2.resolve(s) : s.isNoDocument() ? n2.resolve(null) : n2.reject(new Q2(G.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)"));
    } catch (t4) {
      const s = Bu(t4, `Failed to get document '${e2} from cache`);
      n2.reject(s);
    }
  }(await ta2(t2), e, n)), n.promise;
}
function ua2(t2, e, n = {}) {
  const s = new j();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new Gc2({
      next: (r2) => {
        e2.enqueueAndForget(() => ju(t3, o));
        const u = r2.docs.has(n2);
        !u && r2.fromCache ? i.reject(new Q2(G.UNAVAILABLE, "Failed to get document because the client is offline.")) : u && r2.fromCache && s2 && s2.source === "server" ? i.reject(new Q2(G.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : i.resolve(r2);
      },
      error: (t4) => i.reject(t4)
    }), o = new Ju(rn(n2.path), r, {
      includeMetadataChanges: true,
      Du: true
    });
    return Qu(t3, o);
  }(await sa2(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function ca(t2, e) {
  const n = new j();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await No(t3, e2, true), i = new sc2(e2, s.ji), r = i.Ku(s.documents), o = i.applyChanges(r, false);
      n2.resolve(o.snapshot);
    } catch (t4) {
      const s = Bu(t4, `Failed to execute query '${e2} against cache`);
      n2.reject(s);
    }
  }(await ta2(t2), e, n)), n.promise;
}
function aa2(t2, e, n = {}) {
  const s = new j();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new Gc2({
      next: (n3) => {
        e2.enqueueAndForget(() => ju(t3, o)), n3.fromCache && s2.source === "server" ? i.reject(new Q2(G.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i.resolve(n3);
      },
      error: (t4) => i.reject(t4)
    }), o = new Ju(n2, r, {
      includeMetadataChanges: true,
      Du: true
    });
    return Qu(t3, o);
  }(await sa2(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function ha2(t2, e) {
  const n = new Gc2(e);
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
    K2(t3).Tu.add(e2), e2.next();
  }(await sa2(t2), n)), () => {
    n.Tc(), t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
      K2(t3).Tu.delete(e2);
    }(await sa2(t2), n));
  };
}
function la2(t2, e, n) {
  const s = new j();
  return t2.asyncQueue.enqueueAndForget(async () => {
    const i = await function(t3) {
      return Xc2(t3).then((t4) => t4.datastore);
    }(t2);
    new Wc2(t2.asyncQueue, i, n, e, s).run();
  }), s.promise;
}
function fa2(t2, e, n, s) {
  const i = function(t3, e2) {
    let n2;
    n2 = typeof t3 == "string" ? new TextEncoder().encode(t3) : t3;
    return function(t4, e3) {
      return new Qc2(t4, e3);
    }(function(t4, e3) {
      if (t4 instanceof Uint8Array)
        return Kc2(t4, e3);
      if (t4 instanceof ArrayBuffer)
        return Kc2(new Uint8Array(t4), e3);
      if (t4 instanceof ReadableStream)
        return t4.getReader();
      throw new Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream");
    }(n2), e2);
  }(n, nu(e));
  t2.asyncQueue.enqueueAndForget(async () => {
    $c2(await na2(t2), i, s);
  });
}
function da2(t2, e) {
  return t2.asyncQueue.enqueue(async () => function(t3, e2) {
    const n = K2(t3);
    return n.persistence.runTransaction("Get named query", "readonly", (t4) => n.Ds.getNamedQuery(t4, e2));
  }(await ta2(t2), e));
}
var _a = /* @__PURE__ */ new Map();
function wa(t2, e, n) {
  if (!n)
    throw new Q2(G.INVALID_ARGUMENT, `Function ${t2}() cannot be called with an empty ${e}.`);
}
function ma2(t2, e, n, s) {
  if (e === true && s === true)
    throw new Q2(G.INVALID_ARGUMENT, `${t2} and ${n} cannot be used together.`);
}
function ga(t2) {
  if (!dt.isDocumentKey(t2))
    throw new Q2(G.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${t2} has ${t2.length}.`);
}
function ya2(t2) {
  if (dt.isDocumentKey(t2))
    throw new Q2(G.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${t2} has ${t2.length}.`);
}
function pa2(t2) {
  if (t2 === void 0)
    return "undefined";
  if (t2 === null)
    return "null";
  if (typeof t2 == "string")
    return t2.length > 20 && (t2 = `${t2.substring(0, 20)}...`), JSON.stringify(t2);
  if (typeof t2 == "number" || typeof t2 == "boolean")
    return "" + t2;
  if (typeof t2 == "object") {
    if (t2 instanceof Array)
      return "an array";
    {
      const e = function(t3) {
        if (t3.constructor)
          return t3.constructor.name;
        return null;
      }(t2);
      return e ? `a custom ${e} object` : "an object";
    }
  }
  return typeof t2 == "function" ? "a function" : L2();
}
function Ia2(t2, e) {
  if ("_delegate" in t2 && (t2 = t2._delegate), !(t2 instanceof e)) {
    if (e.name === t2.constructor.name)
      throw new Q2(G.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const n = pa2(t2);
      throw new Q2(G.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${n}`);
    }
  }
  return t2;
}
function Ta(t2, e) {
  if (e <= 0)
    throw new Q2(G.INVALID_ARGUMENT, `Function ${t2}() requires a positive number, but it was: ${e}.`);
}
var Ea = class {
  constructor(t2) {
    var e;
    if (t2.host === void 0) {
      if (t2.ssl !== void 0)
        throw new Q2(G.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = true;
    } else
      this.host = t2.host, this.ssl = (e = t2.ssl) === null || e === void 0 || e;
    if (this.credentials = t2.credentials, this.ignoreUndefinedProperties = !!t2.ignoreUndefinedProperties, t2.cacheSizeBytes === void 0)
      this.cacheSizeBytes = 41943040;
    else {
      if (t2.cacheSizeBytes !== -1 && t2.cacheSizeBytes < 1048576)
        throw new Q2(G.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = t2.cacheSizeBytes;
    }
    this.experimentalForceLongPolling = !!t2.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!t2.experimentalAutoDetectLongPolling, this.useFetchStreams = !!t2.useFetchStreams, ma2("experimentalForceLongPolling", t2.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t2.experimentalAutoDetectLongPolling);
  }
  isEqual(t2) {
    return this.host === t2.host && this.ssl === t2.ssl && this.credentials === t2.credentials && this.cacheSizeBytes === t2.cacheSizeBytes && this.experimentalForceLongPolling === t2.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t2.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t2.ignoreUndefinedProperties && this.useFetchStreams === t2.useFetchStreams;
  }
};
var Aa2 = class {
  constructor(t2, e, n) {
    this._authCredentials = e, this._appCheckCredentials = n, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new Ea({}), this._settingsFrozen = false, t2 instanceof re ? this._databaseId = t2 : (this._app = t2, this._databaseId = function(t3) {
      if (!Object.prototype.hasOwnProperty.apply(t3.options, ["projectId"]))
        throw new Q2(G.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      return new re(t3.options.projectId);
    }(t2));
  }
  get app() {
    if (!this._app)
      throw new Q2(G.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== void 0;
  }
  _setSettings(t2) {
    if (this._settingsFrozen)
      throw new Q2(G.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new Ea(t2), t2.credentials !== void 0 && (this._authCredentials = function(t3) {
      if (!t3)
        return new z2();
      switch (t3.type) {
        case "gapi":
          const e = t3.client;
          return U2(!(typeof e != "object" || e === null || !e.auth || !e.auth.getAuthHeaderValueForFirstParty)), new X2(e, t3.sessionIndex || "0", t3.iamToken || null);
        case "provider":
          return t3.client;
        default:
          throw new Q2(G.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type");
      }
    }(t2.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = true, this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  _terminate() {
    return function(t2) {
      const e = _a.get(t2);
      e && (M2("ComponentProvider", "Removing Datastore"), _a.delete(t2), e.terminate());
    }(this), Promise.resolve();
  }
};
function Ra2(t2, e, n, s = {}) {
  var i;
  const r = (t2 = Ia2(t2, Aa2))._getSettings();
  if (r.host !== "firestore.googleapis.com" && r.host !== e && $("Host has been set in both settings() and useEmulator(), emulator host will be used"), t2._setSettings(Object.assign(Object.assign({}, r), {
    host: `${e}:${n}`,
    ssl: false
  })), s.mockUserToken) {
    let e2, n2;
    if (typeof s.mockUserToken == "string")
      e2 = s.mockUserToken, n2 = C2.MOCK_USER;
    else {
      e2 = createMockUserToken(s.mockUserToken, (i = t2._app) === null || i === void 0 ? void 0 : i.options.projectId);
      const r2 = s.mockUserToken.sub || s.mockUserToken.user_id;
      if (!r2)
        throw new Q2(G.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
      n2 = new C2(r2);
    }
    t2._authCredentials = new H2(new W2(e2, n2));
  }
}
var ba2 = class {
  constructor(t2, e, n) {
    this.converter = e, this._key = n, this.type = "document", this.firestore = t2;
  }
  get _path() {
    return this._key.path;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get path() {
    return this._key.path.canonicalString();
  }
  get parent() {
    return new va(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(t2) {
    return new ba2(this.firestore, t2, this._key);
  }
};
var Pa = class {
  constructor(t2, e, n) {
    this.converter = e, this._query = n, this.type = "query", this.firestore = t2;
  }
  withConverter(t2) {
    return new Pa(this.firestore, t2, this._query);
  }
};
var va = class extends Pa {
  constructor(t2, e, n) {
    super(t2, e, rn(n)), this._path = n, this.type = "collection";
  }
  get id() {
    return this._query.path.lastSegment();
  }
  get path() {
    return this._query.path.canonicalString();
  }
  get parent() {
    const t2 = this._path.popLast();
    return t2.isEmpty() ? null : new ba2(this.firestore, null, new dt(t2));
  }
  withConverter(t2) {
    return new va(this.firestore, t2, this._path);
  }
};
function Va2(t2, e, ...n) {
  if (t2 = getModularInstance(t2), wa("collection", "path", e), t2 instanceof Aa2) {
    const s = ht.fromString(e, ...n);
    return ya2(s), new va(t2, null, s);
  }
  {
    if (!(t2 instanceof ba2 || t2 instanceof va))
      throw new Q2(G.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(ht.fromString(e, ...n));
    return ya2(s), new va(t2.firestore, null, s);
  }
}
function Sa2(t2, e) {
  if (t2 = Ia2(t2, Aa2), wa("collectionGroup", "collection id", e), e.indexOf("/") >= 0)
    throw new Q2(G.INVALID_ARGUMENT, `Invalid collection ID '${e}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
  return new Pa(t2, null, function(t3) {
    return new nn(ht.emptyPath(), t3);
  }(e));
}
function Da(t2, e, ...n) {
  if (t2 = getModularInstance(t2), arguments.length === 1 && (e = st.I()), wa("doc", "path", e), t2 instanceof Aa2) {
    const s = ht.fromString(e, ...n);
    return ga(s), new ba2(t2, null, new dt(s));
  }
  {
    if (!(t2 instanceof ba2 || t2 instanceof va))
      throw new Q2(G.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(ht.fromString(e, ...n));
    return ga(s), new ba2(t2.firestore, t2 instanceof va ? t2.converter : null, new dt(s));
  }
}
function Ca2(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), (t2 instanceof ba2 || t2 instanceof va) && (e instanceof ba2 || e instanceof va) && (t2.firestore === e.firestore && t2.path === e.path && t2.converter === e.converter);
}
function xa2(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), t2 instanceof Pa && e instanceof Pa && (t2.firestore === e.firestore && dn(t2._query, e._query) && t2.converter === e.converter);
}
var Na2 = class {
  constructor() {
    this.Oc = Promise.resolve(), this.Mc = [], this.Fc = false, this.$c = [], this.Bc = null, this.Lc = false, this.Uc = false, this.qc = [], this.So = new su(this, "async_queue_retry"), this.Kc = () => {
      const t3 = eu();
      t3 && M2("AsyncQueue", "Visibility state changed to " + t3.visibilityState), this.So.Eo();
    };
    const t2 = eu();
    t2 && typeof t2.addEventListener == "function" && t2.addEventListener("visibilitychange", this.Kc);
  }
  get isShuttingDown() {
    return this.Fc;
  }
  enqueueAndForget(t2) {
    this.enqueue(t2);
  }
  enqueueAndForgetEvenWhileRestricted(t2) {
    this.Gc(), this.Qc(t2);
  }
  enterRestrictedMode(t2) {
    if (!this.Fc) {
      this.Fc = true, this.Uc = t2 || false;
      const e = eu();
      e && typeof e.removeEventListener == "function" && e.removeEventListener("visibilitychange", this.Kc);
    }
  }
  enqueue(t2) {
    if (this.Gc(), this.Fc)
      return new Promise(() => {
      });
    const e = new j();
    return this.Qc(() => this.Fc && this.Uc ? Promise.resolve() : (t2().then(e.resolve, e.reject), e.promise)).then(() => e.promise);
  }
  enqueueRetryable(t2) {
    this.enqueueAndForget(() => (this.Mc.push(t2), this.jc()));
  }
  async jc() {
    if (this.Mc.length !== 0) {
      try {
        await this.Mc[0](), this.Mc.shift(), this.So.reset();
      } catch (t2) {
        if (!Ct(t2))
          throw t2;
        M2("AsyncQueue", "Operation failed with retryable error: " + t2);
      }
      this.Mc.length > 0 && this.So.Io(() => this.jc());
    }
  }
  Qc(t2) {
    const e = this.Oc.then(() => (this.Lc = true, t2().catch((t3) => {
      this.Bc = t3, this.Lc = false;
      const e2 = function(t4) {
        let e3 = t4.message || "";
        t4.stack && (e3 = t4.stack.includes(t4.message) ? t4.stack : t4.message + "\n" + t4.stack);
        return e3;
      }(t3);
      throw F2("INTERNAL UNHANDLED ERROR: ", e2), t3;
    }).then((t3) => (this.Lc = false, t3))));
    return this.Oc = e, e;
  }
  enqueueAfterDelay(t2, e, n) {
    this.Gc(), this.qc.indexOf(t2) > -1 && (e = 0);
    const s = $u.createAndSchedule(this, t2, e, n, (t3) => this.Wc(t3));
    return this.$c.push(s), s;
  }
  Gc() {
    this.Bc && L2();
  }
  verifyOperationInProgress() {
  }
  async zc() {
    let t2;
    do {
      t2 = this.Oc, await t2;
    } while (t2 !== this.Oc);
  }
  Hc(t2) {
    for (const e of this.$c)
      if (e.timerId === t2)
        return true;
    return false;
  }
  Jc(t2) {
    return this.zc().then(() => {
      this.$c.sort((t3, e) => t3.targetTimeMs - e.targetTimeMs);
      for (const e of this.$c)
        if (e.skipDelay(), t2 !== "all" && e.timerId === t2)
          break;
      return this.zc();
    });
  }
  Yc(t2) {
    this.qc.push(t2);
  }
  Wc(t2) {
    const e = this.$c.indexOf(t2);
    this.$c.splice(e, 1);
  }
};
function ka2(t2) {
  return function(t3, e) {
    if (typeof t3 != "object" || t3 === null)
      return false;
    const n = t3;
    for (const t4 of e)
      if (t4 in n && typeof n[t4] == "function")
        return true;
    return false;
  }(t2, ["next", "error", "complete"]);
}
var Oa = class {
  constructor() {
    this._progressObserver = {}, this._taskCompletionResolver = new j(), this._lastProgress = {
      taskState: "Running",
      totalBytes: 0,
      totalDocuments: 0,
      bytesLoaded: 0,
      documentsLoaded: 0
    };
  }
  onProgress(t2, e, n) {
    this._progressObserver = {
      next: t2,
      error: e,
      complete: n
    };
  }
  catch(t2) {
    return this._taskCompletionResolver.promise.catch(t2);
  }
  then(t2, e) {
    return this._taskCompletionResolver.promise.then(t2, e);
  }
  _completeWith(t2) {
    this._updateProgress(t2), this._progressObserver.complete && this._progressObserver.complete(), this._taskCompletionResolver.resolve(t2);
  }
  _failWith(t2) {
    this._lastProgress.taskState = "Error", this._progressObserver.next && this._progressObserver.next(this._lastProgress), this._progressObserver.error && this._progressObserver.error(t2), this._taskCompletionResolver.reject(t2);
  }
  _updateProgress(t2) {
    this._lastProgress = t2, this._progressObserver.next && this._progressObserver.next(t2);
  }
};
var Ma2 = -1;
var Fa2 = class extends Aa2 {
  constructor(t2, e, n) {
    super(t2, e, n), this.type = "firestore", this._queue = new Na2(), this._persistenceKey = "name" in t2 ? t2.name : "[DEFAULT]";
  }
  _terminate() {
    return this._firestoreClient || Ua2(this), this._firestoreClient.terminate();
  }
};
function La2(t2) {
  return t2._firestoreClient || Ua2(t2), t2._firestoreClient.verifyNotTerminated(), t2._firestoreClient;
}
function Ua2(t2) {
  var e;
  const n = t2._freezeSettings(), s = function(t3, e2, n2, s2) {
    return new ie(t3, e2, n2, s2.host, s2.ssl, s2.experimentalForceLongPolling, s2.experimentalAutoDetectLongPolling, s2.useFetchStreams);
  }(t2._databaseId, ((e = t2._app) === null || e === void 0 ? void 0 : e.options.appId) || "", t2._persistenceKey, n);
  t2._firestoreClient = new zc2(t2._authCredentials, t2._appCheckCredentials, t2._queue, s);
}
function qa2(t2, e) {
  Xa2(t2 = Ia2(t2, Fa2));
  const n = La2(t2), s = t2._freezeSettings(), i = new qc2();
  return Ga2(n, i, new Lc2(i, s.cacheSizeBytes, e == null ? void 0 : e.forceOwnership));
}
function Ka2(t2) {
  Xa2(t2 = Ia2(t2, Fa2));
  const e = La2(t2), n = t2._freezeSettings(), s = new qc2();
  return Ga2(e, s, new Uc2(s, n.cacheSizeBytes));
}
function Ga2(t2, e, n) {
  const s = new j();
  return t2.asyncQueue.enqueue(async () => {
    try {
      await Hc2(t2, n), await Jc2(t2, e), s.resolve();
    } catch (t3) {
      if (!function(t4) {
        if (t4.name === "FirebaseError")
          return t4.code === G.FAILED_PRECONDITION || t4.code === G.UNIMPLEMENTED;
        if (typeof DOMException != "undefined" && t4 instanceof DOMException)
          return t4.code === 22 || t4.code === 20 || t4.code === 11;
        return true;
      }(t3))
        throw t3;
      console.warn("Error enabling offline persistence. Falling back to persistence disabled: " + t3), s.reject(t3);
    }
  }).then(() => s.promise);
}
function Qa(t2) {
  if (t2._initialized && !t2._terminated)
    throw new Q2(G.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
  const e = new j();
  return t2._queue.enqueueAndForgetEvenWhileRestricted(async () => {
    try {
      await async function(t3) {
        if (!Vt.V())
          return Promise.resolve();
        const e2 = t3 + "main";
        await Vt.delete(e2);
      }(Io(t2._databaseId, t2._persistenceKey)), e.resolve();
    } catch (t3) {
      e.reject(t3);
    }
  }), e.promise;
}
function ja2(t2) {
  return function(t3) {
    const e = new j();
    return t3.asyncQueue.enqueueAndForget(async () => mc2(await na2(t3), e)), e.promise;
  }(La2(t2 = Ia2(t2, Fa2)));
}
function Wa2(t2) {
  return ia2(La2(t2 = Ia2(t2, Fa2)));
}
function za2(t2) {
  return ra2(La2(t2 = Ia2(t2, Fa2)));
}
function Ja2(t2, e) {
  const n = La2(t2 = Ia2(t2, Fa2)), s = new Oa();
  return fa2(n, t2._databaseId, e, s), s;
}
function Ya2(t2, e) {
  return da2(La2(t2 = Ia2(t2, Fa2)), e).then((e2) => e2 ? new Pa(t2, null, e2.query) : null);
}
function Xa2(t2) {
  if (t2._initialized || t2._terminated)
    throw new Q2(G.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.");
}
var Za2 = class {
  constructor(...t2) {
    for (let e = 0; e < t2.length; ++e)
      if (t2[e].length === 0)
        throw new Q2(G.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new ft(t2);
  }
  isEqual(t2) {
    return this._internalPath.isEqual(t2._internalPath);
  }
};
var eh = class {
  constructor(t2) {
    this._byteString = t2;
  }
  static fromBase64String(t2) {
    try {
      return new eh(Jt.fromBase64String(t2));
    } catch (t3) {
      throw new Q2(G.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + t3);
    }
  }
  static fromUint8Array(t2) {
    return new eh(Jt.fromUint8Array(t2));
  }
  toBase64() {
    return this._byteString.toBase64();
  }
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  isEqual(t2) {
    return this._byteString.isEqual(t2._byteString);
  }
};
var nh = class {
  constructor(t2) {
    this._methodName = t2;
  }
};
var sh = class {
  constructor(t2, e) {
    if (!isFinite(t2) || t2 < -90 || t2 > 90)
      throw new Q2(G.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t2);
    if (!isFinite(e) || e < -180 || e > 180)
      throw new Q2(G.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e);
    this._lat = t2, this._long = e;
  }
  get latitude() {
    return this._lat;
  }
  get longitude() {
    return this._long;
  }
  isEqual(t2) {
    return this._lat === t2._lat && this._long === t2._long;
  }
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  _compareTo(t2) {
    return it(this._lat, t2._lat) || it(this._long, t2._long);
  }
};
var ih = /^__.*__$/;
var rh = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return this.fieldMask !== null ? new Wn(t2, this.data, this.fieldMask, e, this.fieldTransforms) : new jn(t2, this.data, e, this.fieldTransforms);
  }
};
var oh = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return new Wn(t2, this.data, this.fieldMask, e, this.fieldTransforms);
  }
};
function uh(t2) {
  switch (t2) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw L2();
  }
}
var ch = class {
  constructor(t2, e, n, s, i, r) {
    this.settings = t2, this.databaseId = e, this.wt = n, this.ignoreUndefinedProperties = s, i === void 0 && this.Xc(), this.fieldTransforms = i || [], this.fieldMask = r || [];
  }
  get path() {
    return this.settings.path;
  }
  get Zc() {
    return this.settings.Zc;
  }
  ta(t2) {
    return new ch(Object.assign(Object.assign({}, this.settings), t2), this.databaseId, this.wt, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  ea(t2) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.ta({
      path: n,
      na: false
    });
    return s.sa(t2), s;
  }
  ia(t2) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.ta({
      path: n,
      na: false
    });
    return s.Xc(), s;
  }
  ra(t2) {
    return this.ta({
      path: void 0,
      na: true
    });
  }
  oa(t2) {
    return Vh(t2, this.settings.methodName, this.settings.ua || false, this.path, this.settings.ca);
  }
  contains(t2) {
    return this.fieldMask.find((e) => t2.isPrefixOf(e)) !== void 0 || this.fieldTransforms.find((e) => t2.isPrefixOf(e.field)) !== void 0;
  }
  Xc() {
    if (this.path)
      for (let t2 = 0; t2 < this.path.length; t2++)
        this.sa(this.path.get(t2));
  }
  sa(t2) {
    if (t2.length === 0)
      throw this.oa("Document fields must not be empty");
    if (uh(this.Zc) && ih.test(t2))
      throw this.oa('Document fields cannot begin and end with "__"');
  }
};
var ah = class {
  constructor(t2, e, n) {
    this.databaseId = t2, this.ignoreUndefinedProperties = e, this.wt = n || nu(t2);
  }
  aa(t2, e, n, s = false) {
    return new ch({
      Zc: t2,
      methodName: e,
      ca: n,
      path: ft.emptyPath(),
      na: false,
      ua: s
    }, this.databaseId, this.wt, this.ignoreUndefinedProperties);
  }
};
function hh(t2) {
  const e = t2._freezeSettings(), n = nu(t2._databaseId);
  return new ah(t2._databaseId, !!e.ignoreUndefinedProperties, n);
}
function lh(t2, e, n, s, i, r = {}) {
  const o = t2.aa(r.merge || r.mergeFields ? 2 : 0, e, n, i);
  Rh("Data must be an object, but it was:", o, s);
  const u = Eh(s, o);
  let c, a;
  if (r.merge)
    c = new zt(o.fieldMask), a = o.fieldTransforms;
  else if (r.mergeFields) {
    const t3 = [];
    for (const s2 of r.mergeFields) {
      const i2 = bh(e, s2, n);
      if (!o.contains(i2))
        throw new Q2(G.INVALID_ARGUMENT, `Field '${i2}' is specified in your field mask but missing from your input data.`);
      Sh(t3, i2) || t3.push(i2);
    }
    c = new zt(t3), a = o.fieldTransforms.filter((t4) => c.covers(t4.field));
  } else
    c = null, a = o.fieldTransforms;
  return new rh(new De(u), c, a);
}
var fh = class extends nh {
  _toFieldTransform(t2) {
    if (t2.Zc !== 2)
      throw t2.Zc === 1 ? t2.oa(`${this._methodName}() can only appear at the top level of your update data`) : t2.oa(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return t2.fieldMask.push(t2.path), null;
  }
  isEqual(t2) {
    return t2 instanceof fh;
  }
};
function dh(t2, e, n) {
  return new ch({
    Zc: 3,
    ca: e.settings.ca,
    methodName: t2._methodName,
    na: n
  }, e.databaseId, e.wt, e.ignoreUndefinedProperties);
}
var _h = class extends nh {
  _toFieldTransform(t2) {
    return new On(t2.path, new vn());
  }
  isEqual(t2) {
    return t2 instanceof _h;
  }
};
var wh = class extends nh {
  constructor(t2, e) {
    super(t2), this.ha = e;
  }
  _toFieldTransform(t2) {
    const e = dh(this, t2, true), n = this.ha.map((t3) => Th(t3, e)), s = new Vn(n);
    return new On(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var mh = class extends nh {
  constructor(t2, e) {
    super(t2), this.ha = e;
  }
  _toFieldTransform(t2) {
    const e = dh(this, t2, true), n = this.ha.map((t3) => Th(t3, e)), s = new Dn(n);
    return new On(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var gh = class extends nh {
  constructor(t2, e) {
    super(t2), this.la = e;
  }
  _toFieldTransform(t2) {
    const e = new xn(t2.wt, En(t2.wt, this.la));
    return new On(t2.path, e);
  }
  isEqual(t2) {
    return this === t2;
  }
};
function yh(t2, e, n, s) {
  const i = t2.aa(1, e, n);
  Rh("Data must be an object, but it was:", i, s);
  const r = [], o = De.empty();
  Lt(s, (t3, s2) => {
    const u2 = vh(e, t3, n);
    s2 = getModularInstance(s2);
    const c = i.ia(u2);
    if (s2 instanceof fh)
      r.push(u2);
    else {
      const t4 = Th(s2, c);
      t4 != null && (r.push(u2), o.set(u2, t4));
    }
  });
  const u = new zt(r);
  return new oh(o, u, i.fieldTransforms);
}
function ph(t2, e, n, s, i, r) {
  const o = t2.aa(1, e, n), u = [bh(e, s, n)], c = [i];
  if (r.length % 2 != 0)
    throw new Q2(G.INVALID_ARGUMENT, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let t3 = 0; t3 < r.length; t3 += 2)
    u.push(bh(e, r[t3])), c.push(r[t3 + 1]);
  const a = [], h = De.empty();
  for (let t3 = u.length - 1; t3 >= 0; --t3)
    if (!Sh(a, u[t3])) {
      const e2 = u[t3];
      let n2 = c[t3];
      n2 = getModularInstance(n2);
      const s2 = o.ia(e2);
      if (n2 instanceof fh)
        a.push(e2);
      else {
        const t4 = Th(n2, s2);
        t4 != null && (a.push(e2), h.set(e2, t4));
      }
    }
  const l2 = new zt(a);
  return new oh(h, l2, o.fieldTransforms);
}
function Ih(t2, e, n, s = false) {
  return Th(n, t2.aa(s ? 4 : 3, e));
}
function Th(t2, e) {
  if (Ah(t2 = getModularInstance(t2)))
    return Rh("Unsupported field value:", e, t2), Eh(t2, e);
  if (t2 instanceof nh)
    return function(t3, e2) {
      if (!uh(e2.Zc))
        throw e2.oa(`${t3._methodName}() can only be used with update() and set()`);
      if (!e2.path)
        throw e2.oa(`${t3._methodName}() is not currently supported inside arrays`);
      const n = t3._toFieldTransform(e2);
      n && e2.fieldTransforms.push(n);
    }(t2, e), null;
  if (t2 === void 0 && e.ignoreUndefinedProperties)
    return null;
  if (e.path && e.fieldMask.push(e.path), t2 instanceof Array) {
    if (e.settings.na && e.Zc !== 4)
      throw e.oa("Nested arrays are not supported");
    return function(t3, e2) {
      const n = [];
      let s = 0;
      for (const i of t3) {
        let t4 = Th(i, e2.ra(s));
        t4 == null && (t4 = {
          nullValue: "NULL_VALUE"
        }), n.push(t4), s++;
      }
      return {
        arrayValue: {
          values: n
        }
      };
    }(t2, e);
  }
  return function(t3, e2) {
    if ((t3 = getModularInstance(t3)) === null)
      return {
        nullValue: "NULL_VALUE"
      };
    if (typeof t3 == "number")
      return En(e2.wt, t3);
    if (typeof t3 == "boolean")
      return {
        booleanValue: t3
      };
    if (typeof t3 == "string")
      return {
        stringValue: t3
      };
    if (t3 instanceof Date) {
      const n = ut.fromDate(t3);
      return {
        timestampValue: Ds(e2.wt, n)
      };
    }
    if (t3 instanceof ut) {
      const n = new ut(t3.seconds, 1e3 * Math.floor(t3.nanoseconds / 1e3));
      return {
        timestampValue: Ds(e2.wt, n)
      };
    }
    if (t3 instanceof sh)
      return {
        geoPointValue: {
          latitude: t3.latitude,
          longitude: t3.longitude
        }
      };
    if (t3 instanceof eh)
      return {
        bytesValue: Cs(e2.wt, t3._byteString)
      };
    if (t3 instanceof ba2) {
      const n = e2.databaseId, s = t3.firestore._databaseId;
      if (!s.isEqual(n))
        throw e2.oa(`Document reference is for database ${s.projectId}/${s.database} but should be for database ${n.projectId}/${n.database}`);
      return {
        referenceValue: ks(t3.firestore._databaseId || e2.databaseId, t3._key.path)
      };
    }
    throw e2.oa(`Unsupported field value: ${pa2(t3)}`);
  }(t2, e);
}
function Eh(t2, e) {
  const n = {};
  return Ut(t2) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : Lt(t2, (t3, s) => {
    const i = Th(s, e.ea(t3));
    i != null && (n[t3] = i);
  }), {
    mapValue: {
      fields: n
    }
  };
}
function Ah(t2) {
  return !(typeof t2 != "object" || t2 === null || t2 instanceof Array || t2 instanceof Date || t2 instanceof ut || t2 instanceof sh || t2 instanceof eh || t2 instanceof ba2 || t2 instanceof nh);
}
function Rh(t2, e, n) {
  if (!Ah(n) || !function(t3) {
    return typeof t3 == "object" && t3 !== null && (Object.getPrototypeOf(t3) === Object.prototype || Object.getPrototypeOf(t3) === null);
  }(n)) {
    const s = pa2(n);
    throw s === "an object" ? e.oa(t2 + " a custom object") : e.oa(t2 + " " + s);
  }
}
function bh(t2, e, n) {
  if ((e = getModularInstance(e)) instanceof Za2)
    return e._internalPath;
  if (typeof e == "string")
    return vh(t2, e);
  throw Vh("Field path arguments must be of type string or ", t2, false, void 0, n);
}
var Ph = new RegExp("[~\\*/\\[\\]]");
function vh(t2, e, n) {
  if (e.search(Ph) >= 0)
    throw Vh(`Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`, t2, false, void 0, n);
  try {
    return new Za2(...e.split("."))._internalPath;
  } catch (s) {
    throw Vh(`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, t2, false, void 0, n);
  }
}
function Vh(t2, e, n, s, i) {
  const r = s && !s.isEmpty(), o = i !== void 0;
  let u = `Function ${e}() called with invalid data`;
  n && (u += " (via `toFirestore()`)"), u += ". ";
  let c = "";
  return (r || o) && (c += " (found", r && (c += ` in field ${s}`), o && (c += ` in document ${i}`), c += ")"), new Q2(G.INVALID_ARGUMENT, u + t2 + c);
}
function Sh(t2, e) {
  return t2.some((t3) => t3.isEqual(e));
}
var Dh = class {
  constructor(t2, e, n, s, i) {
    this._firestore = t2, this._userDataWriter = e, this._key = n, this._document = s, this._converter = i;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get ref() {
    return new ba2(this._firestore, this._converter, this._key);
  }
  exists() {
    return this._document !== null;
  }
  data() {
    if (this._document) {
      if (this._converter) {
        const t2 = new Ch(this._firestore, this._userDataWriter, this._key, this._document, null);
        return this._converter.fromFirestore(t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  get(t2) {
    if (this._document) {
      const e = this._document.data.field(xh("DocumentSnapshot.get", t2));
      if (e !== null)
        return this._userDataWriter.convertValue(e);
    }
  }
};
var Ch = class extends Dh {
  data() {
    return super.data();
  }
};
function xh(t2, e) {
  return typeof e == "string" ? vh(t2, e) : e instanceof Za2 ? e._internalPath : e._delegate._internalPath;
}
var Nh = class {
  constructor(t2, e) {
    this.hasPendingWrites = t2, this.fromCache = e;
  }
  isEqual(t2) {
    return this.hasPendingWrites === t2.hasPendingWrites && this.fromCache === t2.fromCache;
  }
};
var kh = class extends Dh {
  constructor(t2, e, n, s, i, r) {
    super(t2, e, n, s, r), this._firestore = t2, this._firestoreImpl = t2, this.metadata = i;
  }
  exists() {
    return super.exists();
  }
  data(t2 = {}) {
    if (this._document) {
      if (this._converter) {
        const e = new Oh(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
        return this._converter.fromFirestore(e, t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value, t2.serverTimestamps);
    }
  }
  get(t2, e = {}) {
    if (this._document) {
      const n = this._document.data.field(xh("DocumentSnapshot.get", t2));
      if (n !== null)
        return this._userDataWriter.convertValue(n, e.serverTimestamps);
    }
  }
};
var Oh = class extends kh {
  data(t2 = {}) {
    return super.data(t2);
  }
};
var Mh = class {
  constructor(t2, e, n, s) {
    this._firestore = t2, this._userDataWriter = e, this._snapshot = s, this.metadata = new Nh(s.hasPendingWrites, s.fromCache), this.query = n;
  }
  get docs() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), t2;
  }
  get size() {
    return this._snapshot.docs.size;
  }
  get empty() {
    return this.size === 0;
  }
  forEach(t2, e) {
    this._snapshot.docs.forEach((n) => {
      t2.call(e, new Oh(this._firestore, this._userDataWriter, n.key, n, new Nh(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache), this.query.converter));
    });
  }
  docChanges(t2 = {}) {
    const e = !!t2.includeMetadataChanges;
    if (e && this._snapshot.excludesMetadataChanges)
      throw new Q2(G.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
    return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = function(t3, e2) {
      if (t3._snapshot.oldDocs.isEmpty()) {
        let e3 = 0;
        return t3._snapshot.docChanges.map((n) => ({
          type: "added",
          doc: new Oh(t3._firestore, t3._userDataWriter, n.doc.key, n.doc, new Nh(t3._snapshot.mutatedKeys.has(n.doc.key), t3._snapshot.fromCache), t3.query.converter),
          oldIndex: -1,
          newIndex: e3++
        }));
      }
      {
        let n = t3._snapshot.oldDocs;
        return t3._snapshot.docChanges.filter((t4) => e2 || t4.type !== 3).map((e3) => {
          const s = new Oh(t3._firestore, t3._userDataWriter, e3.doc.key, e3.doc, new Nh(t3._snapshot.mutatedKeys.has(e3.doc.key), t3._snapshot.fromCache), t3.query.converter);
          let i = -1, r = -1;
          return e3.type !== 0 && (i = n.indexOf(e3.doc.key), n = n.delete(e3.doc.key)), e3.type !== 1 && (n = n.add(e3.doc), r = n.indexOf(e3.doc.key)), {
            type: Fh(e3.type),
            doc: s,
            oldIndex: i,
            newIndex: r
          };
        });
      }
    }(this, e), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;
  }
};
function Fh(t2) {
  switch (t2) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return L2();
  }
}
function $h(t2, e) {
  return t2 instanceof kh && e instanceof kh ? t2._firestore === e._firestore && t2._key.isEqual(e._key) && (t2._document === null ? e._document === null : t2._document.isEqual(e._document)) && t2._converter === e._converter : t2 instanceof Mh && e instanceof Mh && (t2._firestore === e._firestore && xa2(t2.query, e.query) && t2.metadata.isEqual(e.metadata) && t2._snapshot.isEqual(e._snapshot));
}
function Bh(t2) {
  if (t2.limitType === "L" && t2.explicitOrderBy.length === 0)
    throw new Q2(G.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
var Lh = class {
};
function Uh(t2, ...e) {
  for (const n of e)
    t2 = n._apply(t2);
  return t2;
}
var qh = class extends Lh {
  constructor(t2, e, n) {
    super(), this.fa = t2, this.da = e, this._a = n, this.type = "where";
  }
  _apply(t2) {
    const e = hh(t2.firestore), n = function(t3, e2, n2, s, i, r, o) {
      let u;
      if (i.isKeyField()) {
        if (r === "array-contains" || r === "array-contains-any")
          throw new Q2(G.INVALID_ARGUMENT, `Invalid Query. You can't perform '${r}' queries on documentId().`);
        if (r === "in" || r === "not-in") {
          sl(o, r);
          const e3 = [];
          for (const n3 of o)
            e3.push(nl(s, t3, n3));
          u = {
            arrayValue: {
              values: e3
            }
          };
        } else
          u = nl(s, t3, o);
      } else
        r !== "in" && r !== "not-in" && r !== "array-contains-any" || sl(o, r), u = Ih(n2, e2, o, r === "in" || r === "not-in");
      const c = qe.create(i, r, u);
      return function(t4, e3) {
        if (e3.ht()) {
          const n4 = cn(t4);
          if (n4 !== null && !n4.isEqual(e3.field))
            throw new Q2(G.INVALID_ARGUMENT, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${n4.toString()}' and '${e3.field.toString()}'`);
          const s2 = un(t4);
          s2 !== null && il(t4, e3.field, s2);
        }
        const n3 = function(t5, e4) {
          for (const n4 of t5.filters)
            if (e4.indexOf(n4.op) >= 0)
              return n4.op;
          return null;
        }(t4, function(t5) {
          switch (t5) {
            case "!=":
              return ["!=", "not-in"];
            case "array-contains":
              return ["array-contains", "array-contains-any", "not-in"];
            case "in":
              return ["array-contains-any", "in", "not-in"];
            case "array-contains-any":
              return ["array-contains", "array-contains-any", "in", "not-in"];
            case "not-in":
              return ["array-contains", "array-contains-any", "in", "not-in", "!="];
            default:
              return [];
          }
        }(e3.op));
        if (n3 !== null)
          throw n3 === e3.op ? new Q2(G.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${e3.op.toString()}' filter.`) : new Q2(G.INVALID_ARGUMENT, `Invalid query. You cannot use '${e3.op.toString()}' filters with '${n3.toString()}' filters.`);
      }(t3, c), c;
    }(t2._query, "where", e, t2.firestore._databaseId, this.fa, this.da, this._a);
    return new Pa(t2.firestore, t2.converter, function(t3, e2) {
      const n2 = t3.filters.concat([e2]);
      return new nn(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), n2, t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, n));
  }
};
function Kh(t2, e, n) {
  const s = e, i = xh("where", t2);
  return new qh(i, s, n);
}
var Gh = class extends Lh {
  constructor(t2, e) {
    super(), this.fa = t2, this.wa = e, this.type = "orderBy";
  }
  _apply(t2) {
    const e = function(t3, e2, n) {
      if (t3.startAt !== null)
        throw new Q2(G.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (t3.endAt !== null)
        throw new Q2(G.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      const s = new Xe(e2, n);
      return function(t4, e3) {
        if (un(t4) === null) {
          const n2 = cn(t4);
          n2 !== null && il(t4, n2, e3.field);
        }
      }(t3, s), s;
    }(t2._query, this.fa, this.wa);
    return new Pa(t2.firestore, t2.converter, function(t3, e2) {
      const n = t3.explicitOrderBy.concat([e2]);
      return new nn(t3.path, t3.collectionGroup, n, t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, e));
  }
};
function Qh(t2, e = "asc") {
  const n = e, s = xh("orderBy", t2);
  return new Gh(s, n);
}
var jh = class extends Lh {
  constructor(t2, e, n) {
    super(), this.type = t2, this.ma = e, this.ga = n;
  }
  _apply(t2) {
    return new Pa(t2.firestore, t2.converter, fn(t2._query, this.ma, this.ga));
  }
};
function Wh(t2) {
  return Ta("limit", t2), new jh("limit", t2, "F");
}
function zh(t2) {
  return Ta("limitToLast", t2), new jh("limitToLast", t2, "L");
}
var Hh = class extends Lh {
  constructor(t2, e, n) {
    super(), this.type = t2, this.ya = e, this.pa = n;
  }
  _apply(t2) {
    const e = el(t2, this.type, this.ya, this.pa);
    return new Pa(t2.firestore, t2.converter, function(t3, e2) {
      return new nn(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, e2, t3.endAt);
    }(t2._query, e));
  }
};
function Jh(...t2) {
  return new Hh("startAt", t2, true);
}
function Yh(...t2) {
  return new Hh("startAfter", t2, false);
}
var Xh = class extends Lh {
  constructor(t2, e, n) {
    super(), this.type = t2, this.ya = e, this.pa = n;
  }
  _apply(t2) {
    const e = el(t2, this.type, this.ya, this.pa);
    return new Pa(t2.firestore, t2.converter, function(t3, e2) {
      return new nn(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, e2);
    }(t2._query, e));
  }
};
function Zh(...t2) {
  return new Xh("endBefore", t2, false);
}
function tl(...t2) {
  return new Xh("endAt", t2, true);
}
function el(t2, e, n, s) {
  if (n[0] = getModularInstance(n[0]), n[0] instanceof Dh)
    return function(t3, e2, n2, s2, i) {
      if (!s2)
        throw new Q2(G.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${n2}().`);
      const r = [];
      for (const n3 of hn(t3))
        if (n3.field.isKeyField())
          r.push(ye(e2, s2.key));
        else {
          const t4 = s2.data.field(n3.field);
          if (ee(t4))
            throw new Q2(G.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + n3.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
          if (t4 === null) {
            const t5 = n3.field.canonicalString();
            throw new Q2(G.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a document for which the field '${t5}' (used as the orderBy) does not exist.`);
          }
          r.push(t4);
        }
      return new Ye(r, i);
    }(t2._query, t2.firestore._databaseId, e, n[0]._document, s);
  {
    const i = hh(t2.firestore);
    return function(t3, e2, n2, s2, i2, r) {
      const o = t3.explicitOrderBy;
      if (i2.length > o.length)
        throw new Q2(G.INVALID_ARGUMENT, `Too many arguments provided to ${s2}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
      const u = [];
      for (let r2 = 0; r2 < i2.length; r2++) {
        const c = i2[r2];
        if (o[r2].field.isKeyField()) {
          if (typeof c != "string")
            throw new Q2(G.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${s2}(), but got a ${typeof c}`);
          if (!an(t3) && c.indexOf("/") !== -1)
            throw new Q2(G.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), the value passed to ${s2}() must be a plain document ID, but '${c}' contains a slash.`);
          const n3 = t3.path.child(ht.fromString(c));
          if (!dt.isDocumentKey(n3))
            throw new Q2(G.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${s2}() must result in a valid document path, but '${n3}' is not because it contains an odd number of segments.`);
          const i3 = new dt(n3);
          u.push(ye(e2, i3));
        } else {
          const t4 = Ih(n2, s2, c);
          u.push(t4);
        }
      }
      return new Ye(u, r);
    }(t2._query, t2.firestore._databaseId, i, e, n, s);
  }
}
function nl(t2, e, n) {
  if (typeof (n = getModularInstance(n)) == "string") {
    if (n === "")
      throw new Q2(G.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!an(e) && n.indexOf("/") !== -1)
      throw new Q2(G.INVALID_ARGUMENT, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`);
    const s = e.path.child(ht.fromString(n));
    if (!dt.isDocumentKey(s))
      throw new Q2(G.INVALID_ARGUMENT, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${s}' is not because it has an odd number of segments (${s.length}).`);
    return ye(t2, new dt(s));
  }
  if (n instanceof ba2)
    return ye(t2, n._key);
  throw new Q2(G.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${pa2(n)}.`);
}
function sl(t2, e) {
  if (!Array.isArray(t2) || t2.length === 0)
    throw new Q2(G.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
  if (t2.length > 10)
    throw new Q2(G.INVALID_ARGUMENT, `Invalid Query. '${e.toString()}' filters support a maximum of 10 elements in the value array.`);
}
function il(t2, e, n) {
  if (!n.isEqual(e))
    throw new Q2(G.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n.toString()}' instead.`);
}
var rl = {
  maxAttempts: 5
};
var ol = class {
  convertValue(t2, e = "none") {
    switch (le(t2)) {
      case 0:
        return null;
      case 1:
        return t2.booleanValue;
      case 2:
        return Zt(t2.integerValue || t2.doubleValue);
      case 3:
        return this.convertTimestamp(t2.timestampValue);
      case 4:
        return this.convertServerTimestamp(t2, e);
      case 5:
        return t2.stringValue;
      case 6:
        return this.convertBytes(te(t2.bytesValue));
      case 7:
        return this.convertReference(t2.referenceValue);
      case 8:
        return this.convertGeoPoint(t2.geoPointValue);
      case 9:
        return this.convertArray(t2.arrayValue, e);
      case 10:
        return this.convertObject(t2.mapValue, e);
      default:
        throw L2();
    }
  }
  convertObject(t2, e) {
    const n = {};
    return Lt(t2.fields, (t3, s) => {
      n[t3] = this.convertValue(s, e);
    }), n;
  }
  convertGeoPoint(t2) {
    return new sh(Zt(t2.latitude), Zt(t2.longitude));
  }
  convertArray(t2, e) {
    return (t2.values || []).map((t3) => this.convertValue(t3, e));
  }
  convertServerTimestamp(t2, e) {
    switch (e) {
      case "previous":
        const n = ne(t2);
        return n == null ? null : this.convertValue(n, e);
      case "estimate":
        return this.convertTimestamp(se(t2));
      default:
        return null;
    }
  }
  convertTimestamp(t2) {
    const e = Xt(t2);
    return new ut(e.seconds, e.nanos);
  }
  convertDocumentKey(t2, e) {
    const n = ht.fromString(t2);
    U2(ui(n));
    const s = new re(n.get(1), n.get(3)), i = new dt(n.popFirst(5));
    return s.isEqual(e) || F2(`Document ${i} contains a document reference within a different database (${s.projectId}/${s.database}) which is not supported. It will be treated as a reference in the current database (${e.projectId}/${e.database}) instead.`), i;
  }
};
function ul(t2, e, n) {
  let s;
  return s = t2 ? n && (n.merge || n.mergeFields) ? t2.toFirestore(e, n) : t2.toFirestore(e) : e, s;
}
var cl = class extends ol {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new eh(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new ba2(this.firestore, null, e);
  }
};
var al = class {
  constructor(t2, e) {
    this._firestore = t2, this._commitHandler = e, this._mutations = [], this._committed = false, this._dataReader = hh(t2);
  }
  set(t2, e, n) {
    this._verifyNotCommitted();
    const s = hl(t2, this._firestore), i = ul(s.converter, e, n), r = lh(this._dataReader, "WriteBatch.set", s._key, i, s.converter !== null, n);
    return this._mutations.push(r.toMutation(s._key, $n.none())), this;
  }
  update(t2, e, n, ...s) {
    this._verifyNotCommitted();
    const i = hl(t2, this._firestore);
    let r;
    return r = typeof (e = getModularInstance(e)) == "string" || e instanceof Za2 ? ph(this._dataReader, "WriteBatch.update", i._key, e, n, s) : yh(this._dataReader, "WriteBatch.update", i._key, e), this._mutations.push(r.toMutation(i._key, $n.exists(true))), this;
  }
  delete(t2) {
    this._verifyNotCommitted();
    const e = hl(t2, this._firestore);
    return this._mutations = this._mutations.concat(new Yn(e._key, $n.none())), this;
  }
  commit() {
    return this._verifyNotCommitted(), this._committed = true, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed)
      throw new Q2(G.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
  }
};
function hl(t2, e) {
  if ((t2 = getModularInstance(t2)).firestore !== e)
    throw new Q2(G.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
  return t2;
}
function ll(t2) {
  t2 = Ia2(t2, ba2);
  const e = Ia2(t2.firestore, Fa2);
  return ua2(La2(e), t2._key).then((n) => bl(e, t2, n));
}
var fl = class extends ol {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new eh(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new ba2(this.firestore, null, e);
  }
};
function dl(t2) {
  t2 = Ia2(t2, ba2);
  const e = Ia2(t2.firestore, Fa2), n = La2(e), s = new fl(e);
  return oa2(n, t2._key).then((n2) => new kh(e, s, t2._key, n2, new Nh(n2 !== null && n2.hasLocalMutations, true), t2.converter));
}
function _l(t2) {
  t2 = Ia2(t2, ba2);
  const e = Ia2(t2.firestore, Fa2);
  return ua2(La2(e), t2._key, {
    source: "server"
  }).then((n) => bl(e, t2, n));
}
function wl(t2) {
  t2 = Ia2(t2, Pa);
  const e = Ia2(t2.firestore, Fa2), n = La2(e), s = new fl(e);
  return Bh(t2._query), aa2(n, t2._query).then((n2) => new Mh(e, s, t2, n2));
}
function ml(t2) {
  t2 = Ia2(t2, Pa);
  const e = Ia2(t2.firestore, Fa2), n = La2(e), s = new fl(e);
  return ca(n, t2._query).then((n2) => new Mh(e, s, t2, n2));
}
function gl(t2) {
  t2 = Ia2(t2, Pa);
  const e = Ia2(t2.firestore, Fa2), n = La2(e), s = new fl(e);
  return aa2(n, t2._query, {
    source: "server"
  }).then((n2) => new Mh(e, s, t2, n2));
}
function yl(t2, e, n) {
  t2 = Ia2(t2, ba2);
  const s = Ia2(t2.firestore, Fa2), i = ul(t2.converter, e, n);
  return Rl(s, [lh(hh(s), "setDoc", t2._key, i, t2.converter !== null, n).toMutation(t2._key, $n.none())]);
}
function pl(t2, e, n, ...s) {
  t2 = Ia2(t2, ba2);
  const i = Ia2(t2.firestore, Fa2), r = hh(i);
  let o;
  o = typeof (e = getModularInstance(e)) == "string" || e instanceof Za2 ? ph(r, "updateDoc", t2._key, e, n, s) : yh(r, "updateDoc", t2._key, e);
  return Rl(i, [o.toMutation(t2._key, $n.exists(true))]);
}
function Il(t2) {
  return Rl(Ia2(t2.firestore, Fa2), [new Yn(t2._key, $n.none())]);
}
function Tl(t2, e) {
  const n = Ia2(t2.firestore, Fa2), s = Da(t2), i = ul(t2.converter, e);
  return Rl(n, [lh(hh(t2.firestore), "addDoc", s._key, i, t2.converter !== null, {}).toMutation(s._key, $n.exists(false))]).then(() => s);
}
function El(t2, ...e) {
  var n, s, i;
  t2 = getModularInstance(t2);
  let r = {
    includeMetadataChanges: false
  }, o = 0;
  typeof e[o] != "object" || ka2(e[o]) || (r = e[o], o++);
  const u = {
    includeMetadataChanges: r.includeMetadataChanges
  };
  if (ka2(e[o])) {
    const t3 = e[o];
    e[o] = (n = t3.next) === null || n === void 0 ? void 0 : n.bind(t3), e[o + 1] = (s = t3.error) === null || s === void 0 ? void 0 : s.bind(t3), e[o + 2] = (i = t3.complete) === null || i === void 0 ? void 0 : i.bind(t3);
  }
  let c, a, h;
  if (t2 instanceof ba2)
    a = Ia2(t2.firestore, Fa2), h = rn(t2._key.path), c = {
      next: (n2) => {
        e[o] && e[o](bl(a, t2, n2));
      },
      error: e[o + 1],
      complete: e[o + 2]
    };
  else {
    const n2 = Ia2(t2, Pa);
    a = Ia2(n2.firestore, Fa2), h = n2._query;
    const s2 = new fl(a);
    c = {
      next: (t3) => {
        e[o] && e[o](new Mh(a, s2, n2, t3));
      },
      error: e[o + 1],
      complete: e[o + 2]
    }, Bh(t2._query);
  }
  return function(t3, e2, n2, s2) {
    const i2 = new Gc2(s2), r2 = new Ju(e2, i2, n2);
    return t3.asyncQueue.enqueueAndForget(async () => Qu(await sa2(t3), r2)), () => {
      i2.Tc(), t3.asyncQueue.enqueueAndForget(async () => ju(await sa2(t3), r2));
    };
  }(La2(a), h, u, c);
}
function Al(t2, e) {
  return ha2(La2(t2 = Ia2(t2, Fa2)), ka2(e) ? e : {
    next: e
  });
}
function Rl(t2, e) {
  return function(t3, e2) {
    const n = new j();
    return t3.asyncQueue.enqueueAndForget(async () => hc2(await na2(t3), e2, n)), n.promise;
  }(La2(t2), e);
}
function bl(t2, e, n) {
  const s = n.docs.get(e._key), i = new fl(t2);
  return new kh(t2, i, e._key, s, new Nh(n.hasPendingWrites, n.fromCache), e.converter);
}
var Pl = class extends class {
  constructor(t2, e) {
    this._firestore = t2, this._transaction = e, this._dataReader = hh(t2);
  }
  get(t2) {
    const e = hl(t2, this._firestore), n = new cl(this._firestore);
    return this._transaction.lookup([e._key]).then((t3) => {
      if (!t3 || t3.length !== 1)
        return L2();
      const s = t3[0];
      if (s.isFoundDocument())
        return new Dh(this._firestore, n, s.key, s, e.converter);
      if (s.isNoDocument())
        return new Dh(this._firestore, n, e._key, null, e.converter);
      throw L2();
    });
  }
  set(t2, e, n) {
    const s = hl(t2, this._firestore), i = ul(s.converter, e, n), r = lh(this._dataReader, "Transaction.set", s._key, i, s.converter !== null, n);
    return this._transaction.set(s._key, r), this;
  }
  update(t2, e, n, ...s) {
    const i = hl(t2, this._firestore);
    let r;
    return r = typeof (e = getModularInstance(e)) == "string" || e instanceof Za2 ? ph(this._dataReader, "Transaction.update", i._key, e, n, s) : yh(this._dataReader, "Transaction.update", i._key, e), this._transaction.update(i._key, r), this;
  }
  delete(t2) {
    const e = hl(t2, this._firestore);
    return this._transaction.delete(e._key), this;
  }
} {
  constructor(t2, e) {
    super(t2, e), this._firestore = t2;
  }
  get(t2) {
    const e = hl(t2, this._firestore), n = new fl(this._firestore);
    return super.get(t2).then((t3) => new kh(this._firestore, n, e._key, t3._document, new Nh(false, false), e.converter));
  }
};
function vl(t2, e, n) {
  t2 = Ia2(t2, Fa2);
  const s = Object.assign(Object.assign({}, rl), n);
  !function(t3) {
    if (t3.maxAttempts < 1)
      throw new Q2(G.INVALID_ARGUMENT, "Max attempts must be at least 1");
  }(s);
  return la2(La2(t2), (n2) => e(new Pl(t2, n2)), s);
}
function Vl() {
  return new fh("deleteField");
}
function Sl() {
  return new _h("serverTimestamp");
}
function Dl(...t2) {
  return new wh("arrayUnion", t2);
}
function Cl(...t2) {
  return new mh("arrayRemove", t2);
}
function xl(t2) {
  return new gh("increment", t2);
}
!function(t2, e = true) {
  !function(t3) {
    x2 = t3;
  }(SDK_VERSION), _registerComponent(new Component("firestore", (t3, { options: n }) => {
    const s = t3.getProvider("app").getImmediate(), i = new Fa2(s, new J2(t3.getProvider("auth-internal")), new tt(t3.getProvider("app-check-internal")));
    return n = Object.assign({
      useFetchStreams: e
    }, n), i._setSettings(n), i;
  }, "PUBLIC")), registerVersion(D2, "3.4.10", t2), registerVersion(D2, "3.4.10", "esm2017");
}();

// node_modules/@firebase/firestore-compat/dist/index.esm2017.js
var name7 = "@firebase/firestore-compat";
var version7 = "0.1.19";
function validateSetOptions(methodName, options) {
  if (options === void 0) {
    return {
      merge: false
    };
  }
  if (options.mergeFields !== void 0 && options.merge !== void 0) {
    throw new Q2("invalid-argument", `Invalid options passed to function ${methodName}(): You cannot specify both "merge" and "mergeFields".`);
  }
  return options;
}
function assertUint8ArrayAvailable() {
  if (typeof Uint8Array === "undefined") {
    throw new Q2("unimplemented", "Uint8Arrays are not available in this environment.");
  }
}
function assertBase64Available() {
  if (!Ht()) {
    throw new Q2("unimplemented", "Blobs are unavailable in Firestore in this environment.");
  }
}
var Blob2 = class {
  constructor(_delegate) {
    this._delegate = _delegate;
  }
  static fromBase64String(base642) {
    assertBase64Available();
    return new Blob2(eh.fromBase64String(base642));
  }
  static fromUint8Array(array) {
    assertUint8ArrayAvailable();
    return new Blob2(eh.fromUint8Array(array));
  }
  toBase64() {
    assertBase64Available();
    return this._delegate.toBase64();
  }
  toUint8Array() {
    assertUint8ArrayAvailable();
    return this._delegate.toUint8Array();
  }
  isEqual(other) {
    return this._delegate.isEqual(other._delegate);
  }
  toString() {
    return "Blob(base64: " + this.toBase64() + ")";
  }
};
function isPartialObserver(obj) {
  return implementsAnyMethods(obj, ["next", "error", "complete"]);
}
function implementsAnyMethods(obj, methods) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  const object = obj;
  for (const method of methods) {
    if (method in object && typeof object[method] === "function") {
      return true;
    }
  }
  return false;
}
var IndexedDbPersistenceProvider = class {
  enableIndexedDbPersistence(firestore, forceOwnership) {
    return qa2(firestore._delegate, { forceOwnership });
  }
  enableMultiTabIndexedDbPersistence(firestore) {
    return Ka2(firestore._delegate);
  }
  clearIndexedDbPersistence(firestore) {
    return Qa(firestore._delegate);
  }
};
var Firestore = class {
  constructor(databaseIdOrApp, _delegate, _persistenceProvider) {
    this._delegate = _delegate;
    this._persistenceProvider = _persistenceProvider;
    this.INTERNAL = {
      delete: () => this.terminate()
    };
    if (!(databaseIdOrApp instanceof re)) {
      this._appCompat = databaseIdOrApp;
    }
  }
  get _databaseId() {
    return this._delegate._databaseId;
  }
  settings(settingsLiteral) {
    const currentSettings = this._delegate._getSettings();
    if (!settingsLiteral.merge && currentSettings.host !== settingsLiteral.host) {
      $("You are overriding the original host. If you did not intend to override your settings, use {merge: true}.");
    }
    if (settingsLiteral.merge) {
      settingsLiteral = Object.assign(Object.assign({}, currentSettings), settingsLiteral);
      delete settingsLiteral.merge;
    }
    this._delegate._setSettings(settingsLiteral);
  }
  useEmulator(host, port, options = {}) {
    Ra2(this._delegate, host, port, options);
  }
  enableNetwork() {
    return Wa2(this._delegate);
  }
  disableNetwork() {
    return za2(this._delegate);
  }
  enablePersistence(settings2) {
    let synchronizeTabs = false;
    let experimentalForceOwningTab = false;
    if (settings2) {
      synchronizeTabs = !!settings2.synchronizeTabs;
      experimentalForceOwningTab = !!settings2.experimentalForceOwningTab;
      ma2("synchronizeTabs", synchronizeTabs, "experimentalForceOwningTab", experimentalForceOwningTab);
    }
    return synchronizeTabs ? this._persistenceProvider.enableMultiTabIndexedDbPersistence(this) : this._persistenceProvider.enableIndexedDbPersistence(this, experimentalForceOwningTab);
  }
  clearPersistence() {
    return this._persistenceProvider.clearIndexedDbPersistence(this);
  }
  terminate() {
    if (this._appCompat) {
      this._appCompat._removeServiceInstance("firestore-compat");
      this._appCompat._removeServiceInstance("firestore");
    }
    return this._delegate._delete();
  }
  waitForPendingWrites() {
    return ja2(this._delegate);
  }
  onSnapshotsInSync(arg) {
    return Al(this._delegate, arg);
  }
  get app() {
    if (!this._appCompat) {
      throw new Q2("failed-precondition", "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    }
    return this._appCompat;
  }
  collection(pathString) {
    try {
      return new CollectionReference(this, Va2(this._delegate, pathString));
    } catch (e) {
      throw replaceFunctionName(e, "collection()", "Firestore.collection()");
    }
  }
  doc(pathString) {
    try {
      return new DocumentReference(this, Da(this._delegate, pathString));
    } catch (e) {
      throw replaceFunctionName(e, "doc()", "Firestore.doc()");
    }
  }
  collectionGroup(collectionId) {
    try {
      return new Query2(this, Sa2(this._delegate, collectionId));
    } catch (e) {
      throw replaceFunctionName(e, "collectionGroup()", "Firestore.collectionGroup()");
    }
  }
  runTransaction(updateFunction) {
    return vl(this._delegate, (transaction) => updateFunction(new Transaction(this, transaction)));
  }
  batch() {
    La2(this._delegate);
    return new WriteBatch(new al(this._delegate, (mutations) => Rl(this._delegate, mutations)));
  }
  loadBundle(bundleData) {
    return Ja2(this._delegate, bundleData);
  }
  namedQuery(name19) {
    return Ya2(this._delegate, name19).then((expQuery) => {
      if (!expQuery) {
        return null;
      }
      return new Query2(this, expQuery);
    });
  }
};
var UserDataWriter = class extends ol {
  constructor(firestore) {
    super();
    this.firestore = firestore;
  }
  convertBytes(bytes) {
    return new Blob2(new eh(bytes));
  }
  convertReference(name19) {
    const key = this.convertDocumentKey(name19, this.firestore._databaseId);
    return DocumentReference.forKey(key, this.firestore, null);
  }
};
function setLogLevel2(level) {
  O2(level);
}
var Transaction = class {
  constructor(_firestore, _delegate) {
    this._firestore = _firestore;
    this._delegate = _delegate;
    this._userDataWriter = new UserDataWriter(_firestore);
  }
  get(documentRef) {
    const ref3 = castReference(documentRef);
    return this._delegate.get(ref3).then((result) => new DocumentSnapshot(this._firestore, new kh(this._firestore._delegate, this._userDataWriter, result._key, result._document, result.metadata, ref3.converter)));
  }
  set(documentRef, data, options) {
    const ref3 = castReference(documentRef);
    if (options) {
      validateSetOptions("Transaction.set", options);
      this._delegate.set(ref3, data, options);
    } else {
      this._delegate.set(ref3, data);
    }
    return this;
  }
  update(documentRef, dataOrField, value, ...moreFieldsAndValues) {
    const ref3 = castReference(documentRef);
    if (arguments.length === 2) {
      this._delegate.update(ref3, dataOrField);
    } else {
      this._delegate.update(ref3, dataOrField, value, ...moreFieldsAndValues);
    }
    return this;
  }
  delete(documentRef) {
    const ref3 = castReference(documentRef);
    this._delegate.delete(ref3);
    return this;
  }
};
var WriteBatch = class {
  constructor(_delegate) {
    this._delegate = _delegate;
  }
  set(documentRef, data, options) {
    const ref3 = castReference(documentRef);
    if (options) {
      validateSetOptions("WriteBatch.set", options);
      this._delegate.set(ref3, data, options);
    } else {
      this._delegate.set(ref3, data);
    }
    return this;
  }
  update(documentRef, dataOrField, value, ...moreFieldsAndValues) {
    const ref3 = castReference(documentRef);
    if (arguments.length === 2) {
      this._delegate.update(ref3, dataOrField);
    } else {
      this._delegate.update(ref3, dataOrField, value, ...moreFieldsAndValues);
    }
    return this;
  }
  delete(documentRef) {
    const ref3 = castReference(documentRef);
    this._delegate.delete(ref3);
    return this;
  }
  commit() {
    return this._delegate.commit();
  }
};
var FirestoreDataConverter = class {
  constructor(_firestore, _userDataWriter, _delegate) {
    this._firestore = _firestore;
    this._userDataWriter = _userDataWriter;
    this._delegate = _delegate;
  }
  fromFirestore(snapshot, options) {
    const expSnapshot = new Oh(this._firestore._delegate, this._userDataWriter, snapshot._key, snapshot._document, snapshot.metadata, null);
    return this._delegate.fromFirestore(new QueryDocumentSnapshot(this._firestore, expSnapshot), options !== null && options !== void 0 ? options : {});
  }
  toFirestore(modelObject, options) {
    if (!options) {
      return this._delegate.toFirestore(modelObject);
    } else {
      return this._delegate.toFirestore(modelObject, options);
    }
  }
  static getInstance(firestore, converter) {
    const converterMapByFirestore = FirestoreDataConverter.INSTANCES;
    let untypedConverterByConverter = converterMapByFirestore.get(firestore);
    if (!untypedConverterByConverter) {
      untypedConverterByConverter = /* @__PURE__ */ new WeakMap();
      converterMapByFirestore.set(firestore, untypedConverterByConverter);
    }
    let instance = untypedConverterByConverter.get(converter);
    if (!instance) {
      instance = new FirestoreDataConverter(firestore, new UserDataWriter(firestore), converter);
      untypedConverterByConverter.set(converter, instance);
    }
    return instance;
  }
};
FirestoreDataConverter.INSTANCES = /* @__PURE__ */ new WeakMap();
var DocumentReference = class {
  constructor(firestore, _delegate) {
    this.firestore = firestore;
    this._delegate = _delegate;
    this._userDataWriter = new UserDataWriter(firestore);
  }
  static forPath(path, firestore, converter) {
    if (path.length % 2 !== 0) {
      throw new Q2("invalid-argument", `Invalid document reference. Document references must have an even number of segments, but ${path.canonicalString()} has ${path.length}`);
    }
    return new DocumentReference(firestore, new ba2(firestore._delegate, converter, new dt(path)));
  }
  static forKey(key, firestore, converter) {
    return new DocumentReference(firestore, new ba2(firestore._delegate, converter, key));
  }
  get id() {
    return this._delegate.id;
  }
  get parent() {
    return new CollectionReference(this.firestore, this._delegate.parent);
  }
  get path() {
    return this._delegate.path;
  }
  collection(pathString) {
    try {
      return new CollectionReference(this.firestore, Va2(this._delegate, pathString));
    } catch (e) {
      throw replaceFunctionName(e, "collection()", "DocumentReference.collection()");
    }
  }
  isEqual(other) {
    other = getModularInstance(other);
    if (!(other instanceof ba2)) {
      return false;
    }
    return Ca2(this._delegate, other);
  }
  set(value, options) {
    options = validateSetOptions("DocumentReference.set", options);
    try {
      if (options) {
        return yl(this._delegate, value, options);
      } else {
        return yl(this._delegate, value);
      }
    } catch (e) {
      throw replaceFunctionName(e, "setDoc()", "DocumentReference.set()");
    }
  }
  update(fieldOrUpdateData, value, ...moreFieldsAndValues) {
    try {
      if (arguments.length === 1) {
        return pl(this._delegate, fieldOrUpdateData);
      } else {
        return pl(this._delegate, fieldOrUpdateData, value, ...moreFieldsAndValues);
      }
    } catch (e) {
      throw replaceFunctionName(e, "updateDoc()", "DocumentReference.update()");
    }
  }
  delete() {
    return Il(this._delegate);
  }
  onSnapshot(...args) {
    const options = extractSnapshotOptions(args);
    const observer = wrapObserver(args, (result) => new DocumentSnapshot(this.firestore, new kh(this.firestore._delegate, this._userDataWriter, result._key, result._document, result.metadata, this._delegate.converter)));
    return El(this._delegate, options, observer);
  }
  get(options) {
    let snap;
    if ((options === null || options === void 0 ? void 0 : options.source) === "cache") {
      snap = dl(this._delegate);
    } else if ((options === null || options === void 0 ? void 0 : options.source) === "server") {
      snap = _l(this._delegate);
    } else {
      snap = ll(this._delegate);
    }
    return snap.then((result) => new DocumentSnapshot(this.firestore, new kh(this.firestore._delegate, this._userDataWriter, result._key, result._document, result.metadata, this._delegate.converter)));
  }
  withConverter(converter) {
    return new DocumentReference(this.firestore, converter ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter)) : this._delegate.withConverter(null));
  }
};
function replaceFunctionName(e, original, updated) {
  e.message = e.message.replace(original, updated);
  return e;
}
function extractSnapshotOptions(args) {
  for (const arg of args) {
    if (typeof arg === "object" && !isPartialObserver(arg)) {
      return arg;
    }
  }
  return {};
}
function wrapObserver(args, wrapper) {
  var _a2, _b;
  let userObserver;
  if (isPartialObserver(args[0])) {
    userObserver = args[0];
  } else if (isPartialObserver(args[1])) {
    userObserver = args[1];
  } else if (typeof args[0] === "function") {
    userObserver = {
      next: args[0],
      error: args[1],
      complete: args[2]
    };
  } else {
    userObserver = {
      next: args[1],
      error: args[2],
      complete: args[3]
    };
  }
  return {
    next: (val) => {
      if (userObserver.next) {
        userObserver.next(wrapper(val));
      }
    },
    error: (_a2 = userObserver.error) === null || _a2 === void 0 ? void 0 : _a2.bind(userObserver),
    complete: (_b = userObserver.complete) === null || _b === void 0 ? void 0 : _b.bind(userObserver)
  };
}
var DocumentSnapshot = class {
  constructor(_firestore, _delegate) {
    this._firestore = _firestore;
    this._delegate = _delegate;
  }
  get ref() {
    return new DocumentReference(this._firestore, this._delegate.ref);
  }
  get id() {
    return this._delegate.id;
  }
  get metadata() {
    return this._delegate.metadata;
  }
  get exists() {
    return this._delegate.exists();
  }
  data(options) {
    return this._delegate.data(options);
  }
  get(fieldPath, options) {
    return this._delegate.get(fieldPath, options);
  }
  isEqual(other) {
    return $h(this._delegate, other._delegate);
  }
};
var QueryDocumentSnapshot = class extends DocumentSnapshot {
  data(options) {
    const data = this._delegate.data(options);
    q2(data !== void 0, "Document in a QueryDocumentSnapshot should exist");
    return data;
  }
};
var Query2 = class {
  constructor(firestore, _delegate) {
    this.firestore = firestore;
    this._delegate = _delegate;
    this._userDataWriter = new UserDataWriter(firestore);
  }
  where(fieldPath, opStr, value) {
    try {
      return new Query2(this.firestore, Uh(this._delegate, Kh(fieldPath, opStr, value)));
    } catch (e) {
      throw replaceFunctionName(e, /(orderBy|where)\(\)/, "Query.$1()");
    }
  }
  orderBy(fieldPath, directionStr) {
    try {
      return new Query2(this.firestore, Uh(this._delegate, Qh(fieldPath, directionStr)));
    } catch (e) {
      throw replaceFunctionName(e, /(orderBy|where)\(\)/, "Query.$1()");
    }
  }
  limit(n) {
    try {
      return new Query2(this.firestore, Uh(this._delegate, Wh(n)));
    } catch (e) {
      throw replaceFunctionName(e, "limit()", "Query.limit()");
    }
  }
  limitToLast(n) {
    try {
      return new Query2(this.firestore, Uh(this._delegate, zh(n)));
    } catch (e) {
      throw replaceFunctionName(e, "limitToLast()", "Query.limitToLast()");
    }
  }
  startAt(...args) {
    try {
      return new Query2(this.firestore, Uh(this._delegate, Jh(...args)));
    } catch (e) {
      throw replaceFunctionName(e, "startAt()", "Query.startAt()");
    }
  }
  startAfter(...args) {
    try {
      return new Query2(this.firestore, Uh(this._delegate, Yh(...args)));
    } catch (e) {
      throw replaceFunctionName(e, "startAfter()", "Query.startAfter()");
    }
  }
  endBefore(...args) {
    try {
      return new Query2(this.firestore, Uh(this._delegate, Zh(...args)));
    } catch (e) {
      throw replaceFunctionName(e, "endBefore()", "Query.endBefore()");
    }
  }
  endAt(...args) {
    try {
      return new Query2(this.firestore, Uh(this._delegate, tl(...args)));
    } catch (e) {
      throw replaceFunctionName(e, "endAt()", "Query.endAt()");
    }
  }
  isEqual(other) {
    return xa2(this._delegate, other._delegate);
  }
  get(options) {
    let query2;
    if ((options === null || options === void 0 ? void 0 : options.source) === "cache") {
      query2 = ml(this._delegate);
    } else if ((options === null || options === void 0 ? void 0 : options.source) === "server") {
      query2 = gl(this._delegate);
    } else {
      query2 = wl(this._delegate);
    }
    return query2.then((result) => new QuerySnapshot(this.firestore, new Mh(this.firestore._delegate, this._userDataWriter, this._delegate, result._snapshot)));
  }
  onSnapshot(...args) {
    const options = extractSnapshotOptions(args);
    const observer = wrapObserver(args, (snap) => new QuerySnapshot(this.firestore, new Mh(this.firestore._delegate, this._userDataWriter, this._delegate, snap._snapshot)));
    return El(this._delegate, options, observer);
  }
  withConverter(converter) {
    return new Query2(this.firestore, converter ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter)) : this._delegate.withConverter(null));
  }
};
var DocumentChange = class {
  constructor(_firestore, _delegate) {
    this._firestore = _firestore;
    this._delegate = _delegate;
  }
  get type() {
    return this._delegate.type;
  }
  get doc() {
    return new QueryDocumentSnapshot(this._firestore, this._delegate.doc);
  }
  get oldIndex() {
    return this._delegate.oldIndex;
  }
  get newIndex() {
    return this._delegate.newIndex;
  }
};
var QuerySnapshot = class {
  constructor(_firestore, _delegate) {
    this._firestore = _firestore;
    this._delegate = _delegate;
  }
  get query() {
    return new Query2(this._firestore, this._delegate.query);
  }
  get metadata() {
    return this._delegate.metadata;
  }
  get size() {
    return this._delegate.size;
  }
  get empty() {
    return this._delegate.empty;
  }
  get docs() {
    return this._delegate.docs.map((doc) => new QueryDocumentSnapshot(this._firestore, doc));
  }
  docChanges(options) {
    return this._delegate.docChanges(options).map((docChange) => new DocumentChange(this._firestore, docChange));
  }
  forEach(callback, thisArg) {
    this._delegate.forEach((snapshot) => {
      callback.call(thisArg, new QueryDocumentSnapshot(this._firestore, snapshot));
    });
  }
  isEqual(other) {
    return $h(this._delegate, other._delegate);
  }
};
var CollectionReference = class extends Query2 {
  constructor(firestore, _delegate) {
    super(firestore, _delegate);
    this.firestore = firestore;
    this._delegate = _delegate;
  }
  get id() {
    return this._delegate.id;
  }
  get path() {
    return this._delegate.path;
  }
  get parent() {
    const docRef = this._delegate.parent;
    return docRef ? new DocumentReference(this.firestore, docRef) : null;
  }
  doc(documentPath) {
    try {
      if (documentPath === void 0) {
        return new DocumentReference(this.firestore, Da(this._delegate));
      } else {
        return new DocumentReference(this.firestore, Da(this._delegate, documentPath));
      }
    } catch (e) {
      throw replaceFunctionName(e, "doc()", "CollectionReference.doc()");
    }
  }
  add(data) {
    return Tl(this._delegate, data).then((docRef) => new DocumentReference(this.firestore, docRef));
  }
  isEqual(other) {
    return Ca2(this._delegate, other._delegate);
  }
  withConverter(converter) {
    return new CollectionReference(this.firestore, converter ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter)) : this._delegate.withConverter(null));
  }
};
function castReference(documentRef) {
  return Ia2(documentRef, ba2);
}
var FieldPath = class {
  constructor(...fieldNames) {
    this._delegate = new Za2(...fieldNames);
  }
  static documentId() {
    return new FieldPath(ft.keyField().canonicalString());
  }
  isEqual(other) {
    other = getModularInstance(other);
    if (!(other instanceof Za2)) {
      return false;
    }
    return this._delegate._internalPath.isEqual(other._internalPath);
  }
};
var FieldValue = class {
  constructor(_delegate) {
    this._delegate = _delegate;
  }
  static serverTimestamp() {
    const delegate = Sl();
    delegate._methodName = "FieldValue.serverTimestamp";
    return new FieldValue(delegate);
  }
  static delete() {
    const delegate = Vl();
    delegate._methodName = "FieldValue.delete";
    return new FieldValue(delegate);
  }
  static arrayUnion(...elements) {
    const delegate = Dl(...elements);
    delegate._methodName = "FieldValue.arrayUnion";
    return new FieldValue(delegate);
  }
  static arrayRemove(...elements) {
    const delegate = Cl(...elements);
    delegate._methodName = "FieldValue.arrayRemove";
    return new FieldValue(delegate);
  }
  static increment(n) {
    const delegate = xl(n);
    delegate._methodName = "FieldValue.increment";
    return new FieldValue(delegate);
  }
  isEqual(other) {
    return this._delegate.isEqual(other._delegate);
  }
};
var firestoreNamespace = {
  Firestore,
  GeoPoint: sh,
  Timestamp: ut,
  Blob: Blob2,
  Transaction,
  WriteBatch,
  DocumentReference,
  DocumentSnapshot,
  Query: Query2,
  QueryDocumentSnapshot,
  QuerySnapshot,
  CollectionReference,
  FieldPath,
  FieldValue,
  setLogLevel: setLogLevel2,
  CACHE_SIZE_UNLIMITED: Ma2
};
function configureForFirebase(firebase2, firestoreFactory) {
  firebase2.INTERNAL.registerComponent(new Component("firestore-compat", (container) => {
    const app = container.getProvider("app-compat").getImmediate();
    const firestoreExp = container.getProvider("firestore").getImmediate();
    return firestoreFactory(app, firestoreExp);
  }, "PUBLIC").setServiceProps(Object.assign({}, firestoreNamespace)));
}
function registerFirestore(instance) {
  configureForFirebase(instance, (app, firestoreExp) => new Firestore(app, firestoreExp, new IndexedDbPersistenceProvider()));
  instance.registerVersion(name7, version7);
}
registerFirestore(firebase);

// node_modules/@firebase/functions/dist/index.esm2017.js
var LONG_TYPE = "type.googleapis.com/google.protobuf.Int64Value";
var UNSIGNED_LONG_TYPE = "type.googleapis.com/google.protobuf.UInt64Value";
function mapValues(o, f) {
  const result = {};
  for (const key in o) {
    if (o.hasOwnProperty(key)) {
      result[key] = f(o[key]);
    }
  }
  return result;
}
function encode(data) {
  if (data == null) {
    return null;
  }
  if (data instanceof Number) {
    data = data.valueOf();
  }
  if (typeof data === "number" && isFinite(data)) {
    return data;
  }
  if (data === true || data === false) {
    return data;
  }
  if (Object.prototype.toString.call(data) === "[object String]") {
    return data;
  }
  if (data instanceof Date) {
    return data.toISOString();
  }
  if (Array.isArray(data)) {
    return data.map((x3) => encode(x3));
  }
  if (typeof data === "function" || typeof data === "object") {
    return mapValues(data, (x3) => encode(x3));
  }
  throw new Error("Data cannot be encoded in JSON: " + data);
}
function decode(json) {
  if (json == null) {
    return json;
  }
  if (json["@type"]) {
    switch (json["@type"]) {
      case LONG_TYPE:
      case UNSIGNED_LONG_TYPE: {
        const value = Number(json["value"]);
        if (isNaN(value)) {
          throw new Error("Data cannot be decoded from JSON: " + json);
        }
        return value;
      }
      default: {
        throw new Error("Data cannot be decoded from JSON: " + json);
      }
    }
  }
  if (Array.isArray(json)) {
    return json.map((x3) => decode(x3));
  }
  if (typeof json === "function" || typeof json === "object") {
    return mapValues(json, (x3) => decode(x3));
  }
  return json;
}
var FUNCTIONS_TYPE = "functions";
var errorCodeMap = {
  OK: "ok",
  CANCELLED: "cancelled",
  UNKNOWN: "unknown",
  INVALID_ARGUMENT: "invalid-argument",
  DEADLINE_EXCEEDED: "deadline-exceeded",
  NOT_FOUND: "not-found",
  ALREADY_EXISTS: "already-exists",
  PERMISSION_DENIED: "permission-denied",
  UNAUTHENTICATED: "unauthenticated",
  RESOURCE_EXHAUSTED: "resource-exhausted",
  FAILED_PRECONDITION: "failed-precondition",
  ABORTED: "aborted",
  OUT_OF_RANGE: "out-of-range",
  UNIMPLEMENTED: "unimplemented",
  INTERNAL: "internal",
  UNAVAILABLE: "unavailable",
  DATA_LOSS: "data-loss"
};
var FunctionsError = class extends FirebaseError {
  constructor(code, message, details) {
    super(`${FUNCTIONS_TYPE}/${code}`, message || "");
    this.details = details;
  }
};
function codeForHTTPStatus(status) {
  if (status >= 200 && status < 300) {
    return "ok";
  }
  switch (status) {
    case 0:
      return "internal";
    case 400:
      return "invalid-argument";
    case 401:
      return "unauthenticated";
    case 403:
      return "permission-denied";
    case 404:
      return "not-found";
    case 409:
      return "aborted";
    case 429:
      return "resource-exhausted";
    case 499:
      return "cancelled";
    case 500:
      return "internal";
    case 501:
      return "unimplemented";
    case 503:
      return "unavailable";
    case 504:
      return "deadline-exceeded";
  }
  return "unknown";
}
function _errorForResponse(status, bodyJSON) {
  let code = codeForHTTPStatus(status);
  let description = code;
  let details = void 0;
  try {
    const errorJSON = bodyJSON && bodyJSON.error;
    if (errorJSON) {
      const status2 = errorJSON.status;
      if (typeof status2 === "string") {
        if (!errorCodeMap[status2]) {
          return new FunctionsError("internal", "internal");
        }
        code = errorCodeMap[status2];
        description = status2;
      }
      const message = errorJSON.message;
      if (typeof message === "string") {
        description = message;
      }
      details = errorJSON.details;
      if (details !== void 0) {
        details = decode(details);
      }
    }
  } catch (e) {
  }
  if (code === "ok") {
    return null;
  }
  return new FunctionsError(code, description, details);
}
var ContextProvider = class {
  constructor(authProvider, messagingProvider, appCheckProvider) {
    this.auth = null;
    this.messaging = null;
    this.appCheck = null;
    this.auth = authProvider.getImmediate({ optional: true });
    this.messaging = messagingProvider.getImmediate({
      optional: true
    });
    if (!this.auth) {
      authProvider.get().then((auth) => this.auth = auth, () => {
      });
    }
    if (!this.messaging) {
      messagingProvider.get().then((messaging) => this.messaging = messaging, () => {
      });
    }
    if (!this.appCheck) {
      appCheckProvider.get().then((appCheck) => this.appCheck = appCheck, () => {
      });
    }
  }
  async getAuthToken() {
    if (!this.auth) {
      return void 0;
    }
    try {
      const token = await this.auth.getToken();
      return token === null || token === void 0 ? void 0 : token.accessToken;
    } catch (e) {
      return void 0;
    }
  }
  async getMessagingToken() {
    if (!this.messaging || !("Notification" in self) || Notification.permission !== "granted") {
      return void 0;
    }
    try {
      return await this.messaging.getToken();
    } catch (e) {
      return void 0;
    }
  }
  async getAppCheckToken() {
    if (this.appCheck) {
      const result = await this.appCheck.getToken();
      if (result.error) {
        return null;
      }
      return result.token;
    }
    return null;
  }
  async getContext() {
    const authToken = await this.getAuthToken();
    const messagingToken = await this.getMessagingToken();
    const appCheckToken = await this.getAppCheckToken();
    return { authToken, messagingToken, appCheckToken };
  }
};
var DEFAULT_REGION = "us-central1";
function failAfter(millis) {
  let timer = null;
  return {
    promise: new Promise((_, reject) => {
      timer = setTimeout(() => {
        reject(new FunctionsError("deadline-exceeded", "deadline-exceeded"));
      }, millis);
    }),
    cancel: () => {
      if (timer) {
        clearTimeout(timer);
      }
    }
  };
}
var FunctionsService = class {
  constructor(app, authProvider, messagingProvider, appCheckProvider, regionOrCustomDomain = DEFAULT_REGION, fetchImpl) {
    this.app = app;
    this.fetchImpl = fetchImpl;
    this.emulatorOrigin = null;
    this.contextProvider = new ContextProvider(authProvider, messagingProvider, appCheckProvider);
    this.cancelAllRequests = new Promise((resolve) => {
      this.deleteService = () => {
        return Promise.resolve(resolve());
      };
    });
    try {
      const url = new URL(regionOrCustomDomain);
      this.customDomain = url.origin;
      this.region = DEFAULT_REGION;
    } catch (e) {
      this.customDomain = null;
      this.region = regionOrCustomDomain;
    }
  }
  _delete() {
    return this.deleteService();
  }
  _url(name19) {
    const projectId = this.app.options.projectId;
    if (this.emulatorOrigin !== null) {
      const origin = this.emulatorOrigin;
      return `${origin}/${projectId}/${this.region}/${name19}`;
    }
    if (this.customDomain !== null) {
      return `${this.customDomain}/${name19}`;
    }
    return `https://${this.region}-${projectId}.cloudfunctions.net/${name19}`;
  }
};
function connectFunctionsEmulator$1(functionsInstance, host, port) {
  functionsInstance.emulatorOrigin = `http://${host}:${port}`;
}
function httpsCallable$1(functionsInstance, name19, options) {
  return (data) => {
    return call(functionsInstance, name19, data, options || {});
  };
}
function httpsCallableFromURL$1(functionsInstance, url, options) {
  return (data) => {
    return callAtURL(functionsInstance, url, data, options || {});
  };
}
async function postJSON(url, body, headers, fetchImpl) {
  headers["Content-Type"] = "application/json";
  let response;
  try {
    response = await fetchImpl(url, {
      method: "POST",
      body: JSON.stringify(body),
      headers
    });
  } catch (e) {
    return {
      status: 0,
      json: null
    };
  }
  let json = null;
  try {
    json = await response.json();
  } catch (e) {
  }
  return {
    status: response.status,
    json
  };
}
function call(functionsInstance, name19, data, options) {
  const url = functionsInstance._url(name19);
  return callAtURL(functionsInstance, url, data, options);
}
async function callAtURL(functionsInstance, url, data, options) {
  data = encode(data);
  const body = { data };
  const headers = {};
  const context = await functionsInstance.contextProvider.getContext();
  if (context.authToken) {
    headers["Authorization"] = "Bearer " + context.authToken;
  }
  if (context.messagingToken) {
    headers["Firebase-Instance-ID-Token"] = context.messagingToken;
  }
  if (context.appCheckToken !== null) {
    headers["X-Firebase-AppCheck"] = context.appCheckToken;
  }
  const timeout = options.timeout || 7e4;
  const failAfterHandle = failAfter(timeout);
  const response = await Promise.race([
    postJSON(url, body, headers, functionsInstance.fetchImpl),
    failAfterHandle.promise,
    functionsInstance.cancelAllRequests
  ]);
  failAfterHandle.cancel();
  if (!response) {
    throw new FunctionsError("cancelled", "Firebase Functions instance was deleted.");
  }
  const error = _errorForResponse(response.status, response.json);
  if (error) {
    throw error;
  }
  if (!response.json) {
    throw new FunctionsError("internal", "Response is not valid JSON object.");
  }
  let responseData = response.json.data;
  if (typeof responseData === "undefined") {
    responseData = response.json.result;
  }
  if (typeof responseData === "undefined") {
    throw new FunctionsError("internal", "Response is missing data field.");
  }
  const decodedData = decode(responseData);
  return { data: decodedData };
}
var name8 = "@firebase/functions";
var version8 = "0.8.2";
var AUTH_INTERNAL_NAME = "auth-internal";
var APP_CHECK_INTERNAL_NAME = "app-check-internal";
var MESSAGING_INTERNAL_NAME = "messaging-internal";
function registerFunctions(fetchImpl, variant) {
  const factory8 = (container, { instanceIdentifier: regionOrCustomDomain }) => {
    const app = container.getProvider("app").getImmediate();
    const authProvider = container.getProvider(AUTH_INTERNAL_NAME);
    const messagingProvider = container.getProvider(MESSAGING_INTERNAL_NAME);
    const appCheckProvider = container.getProvider(APP_CHECK_INTERNAL_NAME);
    return new FunctionsService(app, authProvider, messagingProvider, appCheckProvider, regionOrCustomDomain, fetchImpl);
  };
  _registerComponent(new Component(FUNCTIONS_TYPE, factory8, "PUBLIC").setMultipleInstances(true));
  registerVersion(name8, version8, variant);
  registerVersion(name8, version8, "esm2017");
}
function connectFunctionsEmulator(functionsInstance, host, port) {
  connectFunctionsEmulator$1(getModularInstance(functionsInstance), host, port);
}
function httpsCallable(functionsInstance, name19, options) {
  return httpsCallable$1(getModularInstance(functionsInstance), name19, options);
}
function httpsCallableFromURL(functionsInstance, url, options) {
  return httpsCallableFromURL$1(getModularInstance(functionsInstance), url, options);
}
registerFunctions(fetch.bind(self));

// node_modules/@firebase/functions-compat/dist/index.esm2017.js
var name9 = "@firebase/functions-compat";
var version9 = "0.2.2";
var FunctionsService2 = class {
  constructor(app, _delegate) {
    this.app = app;
    this._delegate = _delegate;
    this._region = this._delegate.region;
    this._customDomain = this._delegate.customDomain;
  }
  httpsCallable(name19, options) {
    return httpsCallable(this._delegate, name19, options);
  }
  httpsCallableFromURL(url, options) {
    return httpsCallableFromURL(this._delegate, url, options);
  }
  useFunctionsEmulator(origin) {
    const match = origin.match("[a-zA-Z]+://([a-zA-Z0-9.-]+)(?::([0-9]+))?");
    if (match == null) {
      throw new FirebaseError("functions", "No origin provided to useFunctionsEmulator()");
    }
    if (match[2] == null) {
      throw new FirebaseError("functions", "Port missing in origin provided to useFunctionsEmulator()");
    }
    return connectFunctionsEmulator(this._delegate, match[1], Number(match[2]));
  }
  useEmulator(host, port) {
    return connectFunctionsEmulator(this._delegate, host, port);
  }
};
var DEFAULT_REGION2 = "us-central1";
var factory4 = (container, { instanceIdentifier: regionOrCustomDomain }) => {
  const app = container.getProvider("app-compat").getImmediate();
  const functionsServiceExp = container.getProvider("functions").getImmediate({
    identifier: regionOrCustomDomain !== null && regionOrCustomDomain !== void 0 ? regionOrCustomDomain : DEFAULT_REGION2
  });
  return new FunctionsService2(app, functionsServiceExp);
};
function registerFunctions2() {
  const namespaceExports = {
    Functions: FunctionsService2
  };
  firebase.INTERNAL.registerComponent(new Component("functions-compat", factory4, "PUBLIC").setServiceProps(namespaceExports).setMultipleInstances(true));
}
registerFunctions2();
firebase.registerVersion(name9, version9);

// node_modules/@firebase/messaging/dist/esm/index.esm2017.js
var DEFAULT_SW_PATH = "/firebase-messaging-sw.js";
var DEFAULT_SW_SCOPE = "/firebase-cloud-messaging-push-scope";
var DEFAULT_VAPID_KEY = "BDOU99-h67HcA6JeFXHbSNMu7e2yNNu3RzoMj8TM4W88jITfq7ZmPvIM1Iv-4_l2LxQcYwhqby2xGpWwzjfAnG4";
var ENDPOINT = "https://fcmregistrations.googleapis.com/v1";
var CONSOLE_CAMPAIGN_ID = "google.c.a.c_id";
var CONSOLE_CAMPAIGN_NAME = "google.c.a.c_l";
var CONSOLE_CAMPAIGN_TIME = "google.c.a.ts";
var CONSOLE_CAMPAIGN_ANALYTICS_ENABLED = "google.c.a.e";
var MessageType$1;
(function(MessageType3) {
  MessageType3[MessageType3["DATA_MESSAGE"] = 1] = "DATA_MESSAGE";
  MessageType3[MessageType3["DISPLAY_NOTIFICATION"] = 3] = "DISPLAY_NOTIFICATION";
})(MessageType$1 || (MessageType$1 = {}));
var MessageType;
(function(MessageType3) {
  MessageType3["PUSH_RECEIVED"] = "push-received";
  MessageType3["NOTIFICATION_CLICKED"] = "notification-clicked";
})(MessageType || (MessageType = {}));
function arrayToBase64(array) {
  const uint8Array = new Uint8Array(array);
  const base64String = btoa(String.fromCharCode(...uint8Array));
  return base64String.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64ToArray(base64String) {
  const padding = "=".repeat((4 - base64String.length % 4) % 4);
  const base642 = (base64String + padding).replace(/\-/g, "+").replace(/_/g, "/");
  const rawData = atob(base642);
  const outputArray = new Uint8Array(rawData.length);
  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}
var OLD_DB_NAME = "fcm_token_details_db";
var OLD_DB_VERSION = 5;
var OLD_OBJECT_STORE_NAME = "fcm_token_object_Store";
async function migrateOldDatabase(senderId) {
  if ("databases" in indexedDB) {
    const databases = await indexedDB.databases();
    const dbNames = databases.map((db3) => db3.name);
    if (!dbNames.includes(OLD_DB_NAME)) {
      return null;
    }
  }
  let tokenDetails = null;
  const db2 = await openDB(OLD_DB_NAME, OLD_DB_VERSION, {
    upgrade: async (db3, oldVersion, newVersion, upgradeTransaction) => {
      var _a2;
      if (oldVersion < 2) {
        return;
      }
      if (!db3.objectStoreNames.contains(OLD_OBJECT_STORE_NAME)) {
        return;
      }
      const objectStore = upgradeTransaction.objectStore(OLD_OBJECT_STORE_NAME);
      const value = await objectStore.index("fcmSenderId").get(senderId);
      await objectStore.clear();
      if (!value) {
        return;
      }
      if (oldVersion === 2) {
        const oldDetails = value;
        if (!oldDetails.auth || !oldDetails.p256dh || !oldDetails.endpoint) {
          return;
        }
        tokenDetails = {
          token: oldDetails.fcmToken,
          createTime: (_a2 = oldDetails.createTime) !== null && _a2 !== void 0 ? _a2 : Date.now(),
          subscriptionOptions: {
            auth: oldDetails.auth,
            p256dh: oldDetails.p256dh,
            endpoint: oldDetails.endpoint,
            swScope: oldDetails.swScope,
            vapidKey: typeof oldDetails.vapidKey === "string" ? oldDetails.vapidKey : arrayToBase64(oldDetails.vapidKey)
          }
        };
      } else if (oldVersion === 3) {
        const oldDetails = value;
        tokenDetails = {
          token: oldDetails.fcmToken,
          createTime: oldDetails.createTime,
          subscriptionOptions: {
            auth: arrayToBase64(oldDetails.auth),
            p256dh: arrayToBase64(oldDetails.p256dh),
            endpoint: oldDetails.endpoint,
            swScope: oldDetails.swScope,
            vapidKey: arrayToBase64(oldDetails.vapidKey)
          }
        };
      } else if (oldVersion === 4) {
        const oldDetails = value;
        tokenDetails = {
          token: oldDetails.fcmToken,
          createTime: oldDetails.createTime,
          subscriptionOptions: {
            auth: arrayToBase64(oldDetails.auth),
            p256dh: arrayToBase64(oldDetails.p256dh),
            endpoint: oldDetails.endpoint,
            swScope: oldDetails.swScope,
            vapidKey: arrayToBase64(oldDetails.vapidKey)
          }
        };
      }
    }
  });
  db2.close();
  await deleteDB(OLD_DB_NAME);
  await deleteDB("fcm_vapid_details_db");
  await deleteDB("undefined");
  return checkTokenDetails(tokenDetails) ? tokenDetails : null;
}
function checkTokenDetails(tokenDetails) {
  if (!tokenDetails || !tokenDetails.subscriptionOptions) {
    return false;
  }
  const { subscriptionOptions } = tokenDetails;
  return typeof tokenDetails.createTime === "number" && tokenDetails.createTime > 0 && typeof tokenDetails.token === "string" && tokenDetails.token.length > 0 && typeof subscriptionOptions.auth === "string" && subscriptionOptions.auth.length > 0 && typeof subscriptionOptions.p256dh === "string" && subscriptionOptions.p256dh.length > 0 && typeof subscriptionOptions.endpoint === "string" && subscriptionOptions.endpoint.length > 0 && typeof subscriptionOptions.swScope === "string" && subscriptionOptions.swScope.length > 0 && typeof subscriptionOptions.vapidKey === "string" && subscriptionOptions.vapidKey.length > 0;
}
var DATABASE_NAME = "firebase-messaging-database";
var DATABASE_VERSION = 1;
var OBJECT_STORE_NAME = "firebase-messaging-store";
var dbPromise2 = null;
function getDbPromise() {
  if (!dbPromise2) {
    dbPromise2 = openDB(DATABASE_NAME, DATABASE_VERSION, {
      upgrade: (upgradeDb, oldVersion) => {
        switch (oldVersion) {
          case 0:
            upgradeDb.createObjectStore(OBJECT_STORE_NAME);
        }
      }
    });
  }
  return dbPromise2;
}
async function dbGet(firebaseDependencies) {
  const key = getKey(firebaseDependencies);
  const db2 = await getDbPromise();
  const tokenDetails = await db2.transaction(OBJECT_STORE_NAME).objectStore(OBJECT_STORE_NAME).get(key);
  if (tokenDetails) {
    return tokenDetails;
  } else {
    const oldTokenDetails = await migrateOldDatabase(firebaseDependencies.appConfig.senderId);
    if (oldTokenDetails) {
      await dbSet(firebaseDependencies, oldTokenDetails);
      return oldTokenDetails;
    }
  }
}
async function dbSet(firebaseDependencies, tokenDetails) {
  const key = getKey(firebaseDependencies);
  const db2 = await getDbPromise();
  const tx = db2.transaction(OBJECT_STORE_NAME, "readwrite");
  await tx.objectStore(OBJECT_STORE_NAME).put(tokenDetails, key);
  await tx.done;
  return tokenDetails;
}
async function dbRemove(firebaseDependencies) {
  const key = getKey(firebaseDependencies);
  const db2 = await getDbPromise();
  const tx = db2.transaction(OBJECT_STORE_NAME, "readwrite");
  await tx.objectStore(OBJECT_STORE_NAME).delete(key);
  await tx.done;
}
function getKey({ appConfig }) {
  return appConfig.appId;
}
var ERROR_MAP = {
  ["missing-app-config-values"]: 'Missing App configuration value: "{$valueName}"',
  ["only-available-in-window"]: "This method is available in a Window context.",
  ["only-available-in-sw"]: "This method is available in a service worker context.",
  ["permission-default"]: "The notification permission was not granted and dismissed instead.",
  ["permission-blocked"]: "The notification permission was not granted and blocked instead.",
  ["unsupported-browser"]: "This browser doesn't support the API's required to use the Firebase SDK.",
  ["indexed-db-unsupported"]: "This browser doesn't support indexedDb.open() (ex. Safari iFrame, Firefox Private Browsing, etc)",
  ["failed-service-worker-registration"]: "We are unable to register the default service worker. {$browserErrorMessage}",
  ["token-subscribe-failed"]: "A problem occurred while subscribing the user to FCM: {$errorInfo}",
  ["token-subscribe-no-token"]: "FCM returned no token when subscribing the user to push.",
  ["token-unsubscribe-failed"]: "A problem occurred while unsubscribing the user from FCM: {$errorInfo}",
  ["token-update-failed"]: "A problem occurred while updating the user from FCM: {$errorInfo}",
  ["token-update-no-token"]: "FCM returned no token when updating the user to push.",
  ["use-sw-after-get-token"]: "The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.",
  ["invalid-sw-registration"]: "The input to useServiceWorker() must be a ServiceWorkerRegistration.",
  ["invalid-bg-handler"]: "The input to setBackgroundMessageHandler() must be a function.",
  ["invalid-vapid-key"]: "The public VAPID key must be a string.",
  ["use-vapid-key-after-get-token"]: "The usePublicVapidKey() method may only be called once and must be called before calling getToken() to ensure your VAPID key is used."
};
var ERROR_FACTORY4 = new ErrorFactory("messaging", "Messaging", ERROR_MAP);
async function requestGetToken(firebaseDependencies, subscriptionOptions) {
  const headers = await getHeaders(firebaseDependencies);
  const body = getBody(subscriptionOptions);
  const subscribeOptions = {
    method: "POST",
    headers,
    body: JSON.stringify(body)
  };
  let responseData;
  try {
    const response = await fetch(getEndpoint(firebaseDependencies.appConfig), subscribeOptions);
    responseData = await response.json();
  } catch (err) {
    throw ERROR_FACTORY4.create("token-subscribe-failed", {
      errorInfo: err
    });
  }
  if (responseData.error) {
    const message = responseData.error.message;
    throw ERROR_FACTORY4.create("token-subscribe-failed", {
      errorInfo: message
    });
  }
  if (!responseData.token) {
    throw ERROR_FACTORY4.create("token-subscribe-no-token");
  }
  return responseData.token;
}
async function requestUpdateToken(firebaseDependencies, tokenDetails) {
  const headers = await getHeaders(firebaseDependencies);
  const body = getBody(tokenDetails.subscriptionOptions);
  const updateOptions = {
    method: "PATCH",
    headers,
    body: JSON.stringify(body)
  };
  let responseData;
  try {
    const response = await fetch(`${getEndpoint(firebaseDependencies.appConfig)}/${tokenDetails.token}`, updateOptions);
    responseData = await response.json();
  } catch (err) {
    throw ERROR_FACTORY4.create("token-update-failed", {
      errorInfo: err
    });
  }
  if (responseData.error) {
    const message = responseData.error.message;
    throw ERROR_FACTORY4.create("token-update-failed", {
      errorInfo: message
    });
  }
  if (!responseData.token) {
    throw ERROR_FACTORY4.create("token-update-no-token");
  }
  return responseData.token;
}
async function requestDeleteToken(firebaseDependencies, token) {
  const headers = await getHeaders(firebaseDependencies);
  const unsubscribeOptions = {
    method: "DELETE",
    headers
  };
  try {
    const response = await fetch(`${getEndpoint(firebaseDependencies.appConfig)}/${token}`, unsubscribeOptions);
    const responseData = await response.json();
    if (responseData.error) {
      const message = responseData.error.message;
      throw ERROR_FACTORY4.create("token-unsubscribe-failed", {
        errorInfo: message
      });
    }
  } catch (err) {
    throw ERROR_FACTORY4.create("token-unsubscribe-failed", {
      errorInfo: err
    });
  }
}
function getEndpoint({ projectId }) {
  return `${ENDPOINT}/projects/${projectId}/registrations`;
}
async function getHeaders({ appConfig, installations }) {
  const authToken = await installations.getToken();
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": appConfig.apiKey,
    "x-goog-firebase-installations-auth": `FIS ${authToken}`
  });
}
function getBody({ p256dh, auth, endpoint, vapidKey }) {
  const body = {
    web: {
      endpoint,
      auth,
      p256dh
    }
  };
  if (vapidKey !== DEFAULT_VAPID_KEY) {
    body.web.applicationPubKey = vapidKey;
  }
  return body;
}
var TOKEN_EXPIRATION_MS = 7 * 24 * 60 * 60 * 1e3;
async function getTokenInternal(messaging) {
  const pushSubscription = await getPushSubscription(messaging.swRegistration, messaging.vapidKey);
  const subscriptionOptions = {
    vapidKey: messaging.vapidKey,
    swScope: messaging.swRegistration.scope,
    endpoint: pushSubscription.endpoint,
    auth: arrayToBase64(pushSubscription.getKey("auth")),
    p256dh: arrayToBase64(pushSubscription.getKey("p256dh"))
  };
  const tokenDetails = await dbGet(messaging.firebaseDependencies);
  if (!tokenDetails) {
    return getNewToken(messaging.firebaseDependencies, subscriptionOptions);
  } else if (!isTokenValid(tokenDetails.subscriptionOptions, subscriptionOptions)) {
    try {
      await requestDeleteToken(messaging.firebaseDependencies, tokenDetails.token);
    } catch (e) {
      console.warn(e);
    }
    return getNewToken(messaging.firebaseDependencies, subscriptionOptions);
  } else if (Date.now() >= tokenDetails.createTime + TOKEN_EXPIRATION_MS) {
    return updateToken(messaging, {
      token: tokenDetails.token,
      createTime: Date.now(),
      subscriptionOptions
    });
  } else {
    return tokenDetails.token;
  }
}
async function deleteTokenInternal(messaging) {
  const tokenDetails = await dbGet(messaging.firebaseDependencies);
  if (tokenDetails) {
    await requestDeleteToken(messaging.firebaseDependencies, tokenDetails.token);
    await dbRemove(messaging.firebaseDependencies);
  }
  const pushSubscription = await messaging.swRegistration.pushManager.getSubscription();
  if (pushSubscription) {
    return pushSubscription.unsubscribe();
  }
  return true;
}
async function updateToken(messaging, tokenDetails) {
  try {
    const updatedToken = await requestUpdateToken(messaging.firebaseDependencies, tokenDetails);
    const updatedTokenDetails = Object.assign(Object.assign({}, tokenDetails), { token: updatedToken, createTime: Date.now() });
    await dbSet(messaging.firebaseDependencies, updatedTokenDetails);
    return updatedToken;
  } catch (e) {
    await deleteTokenInternal(messaging);
    throw e;
  }
}
async function getNewToken(firebaseDependencies, subscriptionOptions) {
  const token = await requestGetToken(firebaseDependencies, subscriptionOptions);
  const tokenDetails = {
    token,
    createTime: Date.now(),
    subscriptionOptions
  };
  await dbSet(firebaseDependencies, tokenDetails);
  return tokenDetails.token;
}
async function getPushSubscription(swRegistration, vapidKey) {
  const subscription = await swRegistration.pushManager.getSubscription();
  if (subscription) {
    return subscription;
  }
  return swRegistration.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: base64ToArray(vapidKey)
  });
}
function isTokenValid(dbOptions, currentOptions) {
  const isVapidKeyEqual = currentOptions.vapidKey === dbOptions.vapidKey;
  const isEndpointEqual = currentOptions.endpoint === dbOptions.endpoint;
  const isAuthEqual = currentOptions.auth === dbOptions.auth;
  const isP256dhEqual = currentOptions.p256dh === dbOptions.p256dh;
  return isVapidKeyEqual && isEndpointEqual && isAuthEqual && isP256dhEqual;
}
function externalizePayload(internalPayload) {
  const payload = {
    from: internalPayload.from,
    collapseKey: internalPayload.collapse_key,
    messageId: internalPayload.fcmMessageId
  };
  propagateNotificationPayload(payload, internalPayload);
  propagateDataPayload(payload, internalPayload);
  propagateFcmOptions(payload, internalPayload);
  return payload;
}
function propagateNotificationPayload(payload, messagePayloadInternal) {
  if (!messagePayloadInternal.notification) {
    return;
  }
  payload.notification = {};
  const title = messagePayloadInternal.notification.title;
  if (!!title) {
    payload.notification.title = title;
  }
  const body = messagePayloadInternal.notification.body;
  if (!!body) {
    payload.notification.body = body;
  }
  const image = messagePayloadInternal.notification.image;
  if (!!image) {
    payload.notification.image = image;
  }
}
function propagateDataPayload(payload, messagePayloadInternal) {
  if (!messagePayloadInternal.data) {
    return;
  }
  payload.data = messagePayloadInternal.data;
}
function propagateFcmOptions(payload, messagePayloadInternal) {
  var _a2, _b, _c2, _d, _e2;
  if (!messagePayloadInternal.fcmOptions && !((_a2 = messagePayloadInternal.notification) === null || _a2 === void 0 ? void 0 : _a2.click_action)) {
    return;
  }
  payload.fcmOptions = {};
  const link = (_c2 = (_b = messagePayloadInternal.fcmOptions) === null || _b === void 0 ? void 0 : _b.link) !== null && _c2 !== void 0 ? _c2 : (_d = messagePayloadInternal.notification) === null || _d === void 0 ? void 0 : _d.click_action;
  if (!!link) {
    payload.fcmOptions.link = link;
  }
  const analyticsLabel = (_e2 = messagePayloadInternal.fcmOptions) === null || _e2 === void 0 ? void 0 : _e2.analytics_label;
  if (!!analyticsLabel) {
    payload.fcmOptions.analyticsLabel = analyticsLabel;
  }
}
function isConsoleMessage(data) {
  return typeof data === "object" && !!data && CONSOLE_CAMPAIGN_ID in data;
}
_mergeStrings("hts/frbslgigp.ogepscmv/ieo/eaylg", "tp:/ieaeogn-agolai.o/1frlglgc/o");
_mergeStrings("AzSCbw63g1R0nCw85jG8", "Iaya3yLKwmgvh7cF0q4");
function _mergeStrings(s1, s2) {
  const resultArray = [];
  for (let i = 0; i < s1.length; i++) {
    resultArray.push(s1.charAt(i));
    if (i < s2.length) {
      resultArray.push(s2.charAt(i));
    }
  }
  return resultArray.join("");
}
function extractAppConfig(app) {
  if (!app || !app.options) {
    throw getMissingValueError("App Configuration Object");
  }
  if (!app.name) {
    throw getMissingValueError("App Name");
  }
  const configKeys = [
    "projectId",
    "apiKey",
    "appId",
    "messagingSenderId"
  ];
  const { options } = app;
  for (const keyName of configKeys) {
    if (!options[keyName]) {
      throw getMissingValueError(keyName);
    }
  }
  return {
    appName: app.name,
    projectId: options.projectId,
    apiKey: options.apiKey,
    appId: options.appId,
    senderId: options.messagingSenderId
  };
}
function getMissingValueError(valueName) {
  return ERROR_FACTORY4.create("missing-app-config-values", {
    valueName
  });
}
var MessagingService = class {
  constructor(app, installations, analyticsProvider) {
    this.deliveryMetricsExportedToBigQueryEnabled = false;
    this.onBackgroundMessageHandler = null;
    this.onMessageHandler = null;
    this.logEvents = [];
    this.isLogServiceStarted = false;
    const appConfig = extractAppConfig(app);
    this.firebaseDependencies = {
      app,
      appConfig,
      installations,
      analyticsProvider
    };
  }
  _delete() {
    return Promise.resolve();
  }
};
async function registerDefaultSw(messaging) {
  var _a2;
  try {
    messaging.swRegistration = await navigator.serviceWorker.register(DEFAULT_SW_PATH, {
      scope: DEFAULT_SW_SCOPE
    });
    messaging.swRegistration.update().catch(() => {
    });
  } catch (e) {
    throw ERROR_FACTORY4.create("failed-service-worker-registration", {
      browserErrorMessage: (_a2 = e) === null || _a2 === void 0 ? void 0 : _a2.message
    });
  }
}
async function updateSwReg(messaging, swRegistration) {
  if (!swRegistration && !messaging.swRegistration) {
    await registerDefaultSw(messaging);
  }
  if (!swRegistration && !!messaging.swRegistration) {
    return;
  }
  if (!(swRegistration instanceof ServiceWorkerRegistration)) {
    throw ERROR_FACTORY4.create("invalid-sw-registration");
  }
  messaging.swRegistration = swRegistration;
}
async function updateVapidKey(messaging, vapidKey) {
  if (!!vapidKey) {
    messaging.vapidKey = vapidKey;
  } else if (!messaging.vapidKey) {
    messaging.vapidKey = DEFAULT_VAPID_KEY;
  }
}
async function getToken$12(messaging, options) {
  if (!navigator) {
    throw ERROR_FACTORY4.create("only-available-in-window");
  }
  if (Notification.permission === "default") {
    await Notification.requestPermission();
  }
  if (Notification.permission !== "granted") {
    throw ERROR_FACTORY4.create("permission-blocked");
  }
  await updateVapidKey(messaging, options === null || options === void 0 ? void 0 : options.vapidKey);
  await updateSwReg(messaging, options === null || options === void 0 ? void 0 : options.serviceWorkerRegistration);
  return getTokenInternal(messaging);
}
async function logToScion(messaging, messageType, data) {
  const eventType = getEventType(messageType);
  const analytics = await messaging.firebaseDependencies.analyticsProvider.get();
  analytics.logEvent(eventType, {
    message_id: data[CONSOLE_CAMPAIGN_ID],
    message_name: data[CONSOLE_CAMPAIGN_NAME],
    message_time: data[CONSOLE_CAMPAIGN_TIME],
    message_device_time: Math.floor(Date.now() / 1e3)
  });
}
function getEventType(messageType) {
  switch (messageType) {
    case MessageType.NOTIFICATION_CLICKED:
      return "notification_open";
    case MessageType.PUSH_RECEIVED:
      return "notification_foreground";
    default:
      throw new Error();
  }
}
async function messageEventListener(messaging, event) {
  const internalPayload = event.data;
  if (!internalPayload.isFirebaseMessaging) {
    return;
  }
  if (messaging.onMessageHandler && internalPayload.messageType === MessageType.PUSH_RECEIVED) {
    if (typeof messaging.onMessageHandler === "function") {
      messaging.onMessageHandler(externalizePayload(internalPayload));
    } else {
      messaging.onMessageHandler.next(externalizePayload(internalPayload));
    }
  }
  const dataPayload = internalPayload.data;
  if (isConsoleMessage(dataPayload) && dataPayload[CONSOLE_CAMPAIGN_ANALYTICS_ENABLED] === "1") {
    await logToScion(messaging, internalPayload.messageType, dataPayload);
  }
}
var name10 = "@firebase/messaging";
var version10 = "0.9.14";
var WindowMessagingFactory = (container) => {
  const messaging = new MessagingService(container.getProvider("app").getImmediate(), container.getProvider("installations-internal").getImmediate(), container.getProvider("analytics-internal"));
  navigator.serviceWorker.addEventListener("message", (e) => messageEventListener(messaging, e));
  return messaging;
};
var WindowMessagingInternalFactory = (container) => {
  const messaging = container.getProvider("messaging").getImmediate();
  const messagingInternal = {
    getToken: (options) => getToken$12(messaging, options)
  };
  return messagingInternal;
};
function registerMessagingInWindow() {
  _registerComponent(new Component("messaging", WindowMessagingFactory, "PUBLIC"));
  _registerComponent(new Component("messaging-internal", WindowMessagingInternalFactory, "PRIVATE"));
  registerVersion(name10, version10);
  registerVersion(name10, version10, "esm2017");
}
async function deleteToken$1(messaging) {
  if (!navigator) {
    throw ERROR_FACTORY4.create("only-available-in-window");
  }
  if (!messaging.swRegistration) {
    await registerDefaultSw(messaging);
  }
  return deleteTokenInternal(messaging);
}
function onMessage$1(messaging, nextOrObserver) {
  if (!navigator) {
    throw ERROR_FACTORY4.create("only-available-in-window");
  }
  messaging.onMessageHandler = nextOrObserver;
  return () => {
    messaging.onMessageHandler = null;
  };
}
async function getToken2(messaging, options) {
  messaging = getModularInstance(messaging);
  return getToken$12(messaging, options);
}
function deleteToken(messaging) {
  messaging = getModularInstance(messaging);
  return deleteToken$1(messaging);
}
function onMessage(messaging, nextOrObserver) {
  messaging = getModularInstance(messaging);
  return onMessage$1(messaging, nextOrObserver);
}
registerMessagingInWindow();

// node_modules/@firebase/messaging/dist/index.sw.esm2017.js
var DEFAULT_VAPID_KEY2 = "BDOU99-h67HcA6JeFXHbSNMu7e2yNNu3RzoMj8TM4W88jITfq7ZmPvIM1Iv-4_l2LxQcYwhqby2xGpWwzjfAnG4";
var ENDPOINT2 = "https://fcmregistrations.googleapis.com/v1";
var FCM_MSG = "FCM_MSG";
var CONSOLE_CAMPAIGN_ID2 = "google.c.a.c_id";
var SDK_PLATFORM_WEB = 3;
var EVENT_MESSAGE_DELIVERED = 1;
var MessageType$12;
(function(MessageType3) {
  MessageType3[MessageType3["DATA_MESSAGE"] = 1] = "DATA_MESSAGE";
  MessageType3[MessageType3["DISPLAY_NOTIFICATION"] = 3] = "DISPLAY_NOTIFICATION";
})(MessageType$12 || (MessageType$12 = {}));
var MessageType2;
(function(MessageType3) {
  MessageType3["PUSH_RECEIVED"] = "push-received";
  MessageType3["NOTIFICATION_CLICKED"] = "notification-clicked";
})(MessageType2 || (MessageType2 = {}));
function arrayToBase642(array) {
  const uint8Array = new Uint8Array(array);
  const base64String = btoa(String.fromCharCode(...uint8Array));
  return base64String.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64ToArray2(base64String) {
  const padding = "=".repeat((4 - base64String.length % 4) % 4);
  const base642 = (base64String + padding).replace(/\-/g, "+").replace(/_/g, "/");
  const rawData = atob(base642);
  const outputArray = new Uint8Array(rawData.length);
  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}
var OLD_DB_NAME2 = "fcm_token_details_db";
var OLD_DB_VERSION2 = 5;
var OLD_OBJECT_STORE_NAME2 = "fcm_token_object_Store";
async function migrateOldDatabase2(senderId) {
  if ("databases" in indexedDB) {
    const databases = await indexedDB.databases();
    const dbNames = databases.map((db3) => db3.name);
    if (!dbNames.includes(OLD_DB_NAME2)) {
      return null;
    }
  }
  let tokenDetails = null;
  const db2 = await openDB(OLD_DB_NAME2, OLD_DB_VERSION2, {
    upgrade: async (db3, oldVersion, newVersion, upgradeTransaction) => {
      var _a2;
      if (oldVersion < 2) {
        return;
      }
      if (!db3.objectStoreNames.contains(OLD_OBJECT_STORE_NAME2)) {
        return;
      }
      const objectStore = upgradeTransaction.objectStore(OLD_OBJECT_STORE_NAME2);
      const value = await objectStore.index("fcmSenderId").get(senderId);
      await objectStore.clear();
      if (!value) {
        return;
      }
      if (oldVersion === 2) {
        const oldDetails = value;
        if (!oldDetails.auth || !oldDetails.p256dh || !oldDetails.endpoint) {
          return;
        }
        tokenDetails = {
          token: oldDetails.fcmToken,
          createTime: (_a2 = oldDetails.createTime) !== null && _a2 !== void 0 ? _a2 : Date.now(),
          subscriptionOptions: {
            auth: oldDetails.auth,
            p256dh: oldDetails.p256dh,
            endpoint: oldDetails.endpoint,
            swScope: oldDetails.swScope,
            vapidKey: typeof oldDetails.vapidKey === "string" ? oldDetails.vapidKey : arrayToBase642(oldDetails.vapidKey)
          }
        };
      } else if (oldVersion === 3) {
        const oldDetails = value;
        tokenDetails = {
          token: oldDetails.fcmToken,
          createTime: oldDetails.createTime,
          subscriptionOptions: {
            auth: arrayToBase642(oldDetails.auth),
            p256dh: arrayToBase642(oldDetails.p256dh),
            endpoint: oldDetails.endpoint,
            swScope: oldDetails.swScope,
            vapidKey: arrayToBase642(oldDetails.vapidKey)
          }
        };
      } else if (oldVersion === 4) {
        const oldDetails = value;
        tokenDetails = {
          token: oldDetails.fcmToken,
          createTime: oldDetails.createTime,
          subscriptionOptions: {
            auth: arrayToBase642(oldDetails.auth),
            p256dh: arrayToBase642(oldDetails.p256dh),
            endpoint: oldDetails.endpoint,
            swScope: oldDetails.swScope,
            vapidKey: arrayToBase642(oldDetails.vapidKey)
          }
        };
      }
    }
  });
  db2.close();
  await deleteDB(OLD_DB_NAME2);
  await deleteDB("fcm_vapid_details_db");
  await deleteDB("undefined");
  return checkTokenDetails2(tokenDetails) ? tokenDetails : null;
}
function checkTokenDetails2(tokenDetails) {
  if (!tokenDetails || !tokenDetails.subscriptionOptions) {
    return false;
  }
  const { subscriptionOptions } = tokenDetails;
  return typeof tokenDetails.createTime === "number" && tokenDetails.createTime > 0 && typeof tokenDetails.token === "string" && tokenDetails.token.length > 0 && typeof subscriptionOptions.auth === "string" && subscriptionOptions.auth.length > 0 && typeof subscriptionOptions.p256dh === "string" && subscriptionOptions.p256dh.length > 0 && typeof subscriptionOptions.endpoint === "string" && subscriptionOptions.endpoint.length > 0 && typeof subscriptionOptions.swScope === "string" && subscriptionOptions.swScope.length > 0 && typeof subscriptionOptions.vapidKey === "string" && subscriptionOptions.vapidKey.length > 0;
}
var DATABASE_NAME2 = "firebase-messaging-database";
var DATABASE_VERSION2 = 1;
var OBJECT_STORE_NAME2 = "firebase-messaging-store";
var dbPromise3 = null;
function getDbPromise2() {
  if (!dbPromise3) {
    dbPromise3 = openDB(DATABASE_NAME2, DATABASE_VERSION2, {
      upgrade: (upgradeDb, oldVersion) => {
        switch (oldVersion) {
          case 0:
            upgradeDb.createObjectStore(OBJECT_STORE_NAME2);
        }
      }
    });
  }
  return dbPromise3;
}
async function dbGet2(firebaseDependencies) {
  const key = getKey2(firebaseDependencies);
  const db2 = await getDbPromise2();
  const tokenDetails = await db2.transaction(OBJECT_STORE_NAME2).objectStore(OBJECT_STORE_NAME2).get(key);
  if (tokenDetails) {
    return tokenDetails;
  } else {
    const oldTokenDetails = await migrateOldDatabase2(firebaseDependencies.appConfig.senderId);
    if (oldTokenDetails) {
      await dbSet2(firebaseDependencies, oldTokenDetails);
      return oldTokenDetails;
    }
  }
}
async function dbSet2(firebaseDependencies, tokenDetails) {
  const key = getKey2(firebaseDependencies);
  const db2 = await getDbPromise2();
  const tx = db2.transaction(OBJECT_STORE_NAME2, "readwrite");
  await tx.objectStore(OBJECT_STORE_NAME2).put(tokenDetails, key);
  await tx.done;
  return tokenDetails;
}
async function dbRemove2(firebaseDependencies) {
  const key = getKey2(firebaseDependencies);
  const db2 = await getDbPromise2();
  const tx = db2.transaction(OBJECT_STORE_NAME2, "readwrite");
  await tx.objectStore(OBJECT_STORE_NAME2).delete(key);
  await tx.done;
}
function getKey2({ appConfig }) {
  return appConfig.appId;
}
var ERROR_MAP2 = {
  ["missing-app-config-values"]: 'Missing App configuration value: "{$valueName}"',
  ["only-available-in-window"]: "This method is available in a Window context.",
  ["only-available-in-sw"]: "This method is available in a service worker context.",
  ["permission-default"]: "The notification permission was not granted and dismissed instead.",
  ["permission-blocked"]: "The notification permission was not granted and blocked instead.",
  ["unsupported-browser"]: "This browser doesn't support the API's required to use the Firebase SDK.",
  ["indexed-db-unsupported"]: "This browser doesn't support indexedDb.open() (ex. Safari iFrame, Firefox Private Browsing, etc)",
  ["failed-service-worker-registration"]: "We are unable to register the default service worker. {$browserErrorMessage}",
  ["token-subscribe-failed"]: "A problem occurred while subscribing the user to FCM: {$errorInfo}",
  ["token-subscribe-no-token"]: "FCM returned no token when subscribing the user to push.",
  ["token-unsubscribe-failed"]: "A problem occurred while unsubscribing the user from FCM: {$errorInfo}",
  ["token-update-failed"]: "A problem occurred while updating the user from FCM: {$errorInfo}",
  ["token-update-no-token"]: "FCM returned no token when updating the user to push.",
  ["use-sw-after-get-token"]: "The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.",
  ["invalid-sw-registration"]: "The input to useServiceWorker() must be a ServiceWorkerRegistration.",
  ["invalid-bg-handler"]: "The input to setBackgroundMessageHandler() must be a function.",
  ["invalid-vapid-key"]: "The public VAPID key must be a string.",
  ["use-vapid-key-after-get-token"]: "The usePublicVapidKey() method may only be called once and must be called before calling getToken() to ensure your VAPID key is used."
};
var ERROR_FACTORY5 = new ErrorFactory("messaging", "Messaging", ERROR_MAP2);
async function requestGetToken2(firebaseDependencies, subscriptionOptions) {
  const headers = await getHeaders2(firebaseDependencies);
  const body = getBody2(subscriptionOptions);
  const subscribeOptions = {
    method: "POST",
    headers,
    body: JSON.stringify(body)
  };
  let responseData;
  try {
    const response = await fetch(getEndpoint2(firebaseDependencies.appConfig), subscribeOptions);
    responseData = await response.json();
  } catch (err) {
    throw ERROR_FACTORY5.create("token-subscribe-failed", {
      errorInfo: err
    });
  }
  if (responseData.error) {
    const message = responseData.error.message;
    throw ERROR_FACTORY5.create("token-subscribe-failed", {
      errorInfo: message
    });
  }
  if (!responseData.token) {
    throw ERROR_FACTORY5.create("token-subscribe-no-token");
  }
  return responseData.token;
}
async function requestUpdateToken2(firebaseDependencies, tokenDetails) {
  const headers = await getHeaders2(firebaseDependencies);
  const body = getBody2(tokenDetails.subscriptionOptions);
  const updateOptions = {
    method: "PATCH",
    headers,
    body: JSON.stringify(body)
  };
  let responseData;
  try {
    const response = await fetch(`${getEndpoint2(firebaseDependencies.appConfig)}/${tokenDetails.token}`, updateOptions);
    responseData = await response.json();
  } catch (err) {
    throw ERROR_FACTORY5.create("token-update-failed", {
      errorInfo: err
    });
  }
  if (responseData.error) {
    const message = responseData.error.message;
    throw ERROR_FACTORY5.create("token-update-failed", {
      errorInfo: message
    });
  }
  if (!responseData.token) {
    throw ERROR_FACTORY5.create("token-update-no-token");
  }
  return responseData.token;
}
async function requestDeleteToken2(firebaseDependencies, token) {
  const headers = await getHeaders2(firebaseDependencies);
  const unsubscribeOptions = {
    method: "DELETE",
    headers
  };
  try {
    const response = await fetch(`${getEndpoint2(firebaseDependencies.appConfig)}/${token}`, unsubscribeOptions);
    const responseData = await response.json();
    if (responseData.error) {
      const message = responseData.error.message;
      throw ERROR_FACTORY5.create("token-unsubscribe-failed", {
        errorInfo: message
      });
    }
  } catch (err) {
    throw ERROR_FACTORY5.create("token-unsubscribe-failed", {
      errorInfo: err
    });
  }
}
function getEndpoint2({ projectId }) {
  return `${ENDPOINT2}/projects/${projectId}/registrations`;
}
async function getHeaders2({ appConfig, installations }) {
  const authToken = await installations.getToken();
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": appConfig.apiKey,
    "x-goog-firebase-installations-auth": `FIS ${authToken}`
  });
}
function getBody2({ p256dh, auth, endpoint, vapidKey }) {
  const body = {
    web: {
      endpoint,
      auth,
      p256dh
    }
  };
  if (vapidKey !== DEFAULT_VAPID_KEY2) {
    body.web.applicationPubKey = vapidKey;
  }
  return body;
}
var TOKEN_EXPIRATION_MS2 = 7 * 24 * 60 * 60 * 1e3;
async function getTokenInternal2(messaging) {
  const pushSubscription = await getPushSubscription2(messaging.swRegistration, messaging.vapidKey);
  const subscriptionOptions = {
    vapidKey: messaging.vapidKey,
    swScope: messaging.swRegistration.scope,
    endpoint: pushSubscription.endpoint,
    auth: arrayToBase642(pushSubscription.getKey("auth")),
    p256dh: arrayToBase642(pushSubscription.getKey("p256dh"))
  };
  const tokenDetails = await dbGet2(messaging.firebaseDependencies);
  if (!tokenDetails) {
    return getNewToken2(messaging.firebaseDependencies, subscriptionOptions);
  } else if (!isTokenValid2(tokenDetails.subscriptionOptions, subscriptionOptions)) {
    try {
      await requestDeleteToken2(messaging.firebaseDependencies, tokenDetails.token);
    } catch (e) {
      console.warn(e);
    }
    return getNewToken2(messaging.firebaseDependencies, subscriptionOptions);
  } else if (Date.now() >= tokenDetails.createTime + TOKEN_EXPIRATION_MS2) {
    return updateToken2(messaging, {
      token: tokenDetails.token,
      createTime: Date.now(),
      subscriptionOptions
    });
  } else {
    return tokenDetails.token;
  }
}
async function deleteTokenInternal2(messaging) {
  const tokenDetails = await dbGet2(messaging.firebaseDependencies);
  if (tokenDetails) {
    await requestDeleteToken2(messaging.firebaseDependencies, tokenDetails.token);
    await dbRemove2(messaging.firebaseDependencies);
  }
  const pushSubscription = await messaging.swRegistration.pushManager.getSubscription();
  if (pushSubscription) {
    return pushSubscription.unsubscribe();
  }
  return true;
}
async function updateToken2(messaging, tokenDetails) {
  try {
    const updatedToken = await requestUpdateToken2(messaging.firebaseDependencies, tokenDetails);
    const updatedTokenDetails = Object.assign(Object.assign({}, tokenDetails), { token: updatedToken, createTime: Date.now() });
    await dbSet2(messaging.firebaseDependencies, updatedTokenDetails);
    return updatedToken;
  } catch (e) {
    await deleteTokenInternal2(messaging);
    throw e;
  }
}
async function getNewToken2(firebaseDependencies, subscriptionOptions) {
  const token = await requestGetToken2(firebaseDependencies, subscriptionOptions);
  const tokenDetails = {
    token,
    createTime: Date.now(),
    subscriptionOptions
  };
  await dbSet2(firebaseDependencies, tokenDetails);
  return tokenDetails.token;
}
async function getPushSubscription2(swRegistration, vapidKey) {
  const subscription = await swRegistration.pushManager.getSubscription();
  if (subscription) {
    return subscription;
  }
  return swRegistration.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: base64ToArray2(vapidKey)
  });
}
function isTokenValid2(dbOptions, currentOptions) {
  const isVapidKeyEqual = currentOptions.vapidKey === dbOptions.vapidKey;
  const isEndpointEqual = currentOptions.endpoint === dbOptions.endpoint;
  const isAuthEqual = currentOptions.auth === dbOptions.auth;
  const isP256dhEqual = currentOptions.p256dh === dbOptions.p256dh;
  return isVapidKeyEqual && isEndpointEqual && isAuthEqual && isP256dhEqual;
}
function externalizePayload2(internalPayload) {
  const payload = {
    from: internalPayload.from,
    collapseKey: internalPayload.collapse_key,
    messageId: internalPayload.fcmMessageId
  };
  propagateNotificationPayload2(payload, internalPayload);
  propagateDataPayload2(payload, internalPayload);
  propagateFcmOptions2(payload, internalPayload);
  return payload;
}
function propagateNotificationPayload2(payload, messagePayloadInternal) {
  if (!messagePayloadInternal.notification) {
    return;
  }
  payload.notification = {};
  const title = messagePayloadInternal.notification.title;
  if (!!title) {
    payload.notification.title = title;
  }
  const body = messagePayloadInternal.notification.body;
  if (!!body) {
    payload.notification.body = body;
  }
  const image = messagePayloadInternal.notification.image;
  if (!!image) {
    payload.notification.image = image;
  }
}
function propagateDataPayload2(payload, messagePayloadInternal) {
  if (!messagePayloadInternal.data) {
    return;
  }
  payload.data = messagePayloadInternal.data;
}
function propagateFcmOptions2(payload, messagePayloadInternal) {
  var _a2, _b, _c2, _d, _e2;
  if (!messagePayloadInternal.fcmOptions && !((_a2 = messagePayloadInternal.notification) === null || _a2 === void 0 ? void 0 : _a2.click_action)) {
    return;
  }
  payload.fcmOptions = {};
  const link = (_c2 = (_b = messagePayloadInternal.fcmOptions) === null || _b === void 0 ? void 0 : _b.link) !== null && _c2 !== void 0 ? _c2 : (_d = messagePayloadInternal.notification) === null || _d === void 0 ? void 0 : _d.click_action;
  if (!!link) {
    payload.fcmOptions.link = link;
  }
  const analyticsLabel = (_e2 = messagePayloadInternal.fcmOptions) === null || _e2 === void 0 ? void 0 : _e2.analytics_label;
  if (!!analyticsLabel) {
    payload.fcmOptions.analyticsLabel = analyticsLabel;
  }
}
function isConsoleMessage2(data) {
  return typeof data === "object" && !!data && CONSOLE_CAMPAIGN_ID2 in data;
}
function sleep2(ms2) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms2);
  });
}
_mergeStrings2("hts/frbslgigp.ogepscmv/ieo/eaylg", "tp:/ieaeogn-agolai.o/1frlglgc/o");
_mergeStrings2("AzSCbw63g1R0nCw85jG8", "Iaya3yLKwmgvh7cF0q4");
async function stageLog(messaging, internalPayload) {
  const fcmEvent = createFcmEvent(internalPayload, await messaging.firebaseDependencies.installations.getId());
  createAndEnqueueLogEvent(messaging, fcmEvent);
}
function createFcmEvent(internalPayload, fid) {
  var _a2, _b;
  const fcmEvent = {};
  if (!!internalPayload.from) {
    fcmEvent.project_number = internalPayload.from;
  }
  if (!!internalPayload.fcmMessageId) {
    fcmEvent.message_id = internalPayload.fcmMessageId;
  }
  fcmEvent.instance_id = fid;
  if (!!internalPayload.notification) {
    fcmEvent.message_type = MessageType$12.DISPLAY_NOTIFICATION.toString();
  } else {
    fcmEvent.message_type = MessageType$12.DATA_MESSAGE.toString();
  }
  fcmEvent.sdk_platform = SDK_PLATFORM_WEB.toString();
  fcmEvent.package_name = self.origin.replace(/(^\w+:|^)\/\//, "");
  if (!!internalPayload.collapse_key) {
    fcmEvent.collapse_key = internalPayload.collapse_key;
  }
  fcmEvent.event = EVENT_MESSAGE_DELIVERED.toString();
  if (!!((_a2 = internalPayload.fcmOptions) === null || _a2 === void 0 ? void 0 : _a2.analytics_label)) {
    fcmEvent.analytics_label = (_b = internalPayload.fcmOptions) === null || _b === void 0 ? void 0 : _b.analytics_label;
  }
  return fcmEvent;
}
function createAndEnqueueLogEvent(messaging, fcmEvent) {
  const logEvent2 = {};
  logEvent2.event_time_ms = Math.floor(Date.now()).toString();
  logEvent2.source_extension_json_proto3 = JSON.stringify(fcmEvent);
  messaging.logEvents.push(logEvent2);
}
function _mergeStrings2(s1, s2) {
  const resultArray = [];
  for (let i = 0; i < s1.length; i++) {
    resultArray.push(s1.charAt(i));
    if (i < s2.length) {
      resultArray.push(s2.charAt(i));
    }
  }
  return resultArray.join("");
}
async function onSubChange(event, messaging) {
  var _a2, _b;
  const { newSubscription } = event;
  if (!newSubscription) {
    await deleteTokenInternal2(messaging);
    return;
  }
  const tokenDetails = await dbGet2(messaging.firebaseDependencies);
  await deleteTokenInternal2(messaging);
  messaging.vapidKey = (_b = (_a2 = tokenDetails === null || tokenDetails === void 0 ? void 0 : tokenDetails.subscriptionOptions) === null || _a2 === void 0 ? void 0 : _a2.vapidKey) !== null && _b !== void 0 ? _b : DEFAULT_VAPID_KEY2;
  await getTokenInternal2(messaging);
}
async function onPush(event, messaging) {
  const internalPayload = getMessagePayloadInternal(event);
  if (!internalPayload) {
    return;
  }
  if (messaging.deliveryMetricsExportedToBigQueryEnabled) {
    await stageLog(messaging, internalPayload);
  }
  const clientList = await getClientList();
  if (hasVisibleClients(clientList)) {
    return sendMessagePayloadInternalToWindows(clientList, internalPayload);
  }
  if (!!internalPayload.notification) {
    await showNotification(wrapInternalPayload(internalPayload));
  }
  if (!messaging) {
    return;
  }
  if (!!messaging.onBackgroundMessageHandler) {
    const payload = externalizePayload2(internalPayload);
    if (typeof messaging.onBackgroundMessageHandler === "function") {
      await messaging.onBackgroundMessageHandler(payload);
    } else {
      messaging.onBackgroundMessageHandler.next(payload);
    }
  }
}
async function onNotificationClick(event) {
  var _a2, _b;
  const internalPayload = (_b = (_a2 = event.notification) === null || _a2 === void 0 ? void 0 : _a2.data) === null || _b === void 0 ? void 0 : _b[FCM_MSG];
  if (!internalPayload) {
    return;
  } else if (event.action) {
    return;
  }
  event.stopImmediatePropagation();
  event.notification.close();
  const link = getLink(internalPayload);
  if (!link) {
    return;
  }
  const url = new URL(link, self.location.href);
  const originUrl = new URL(self.location.origin);
  if (url.host !== originUrl.host) {
    return;
  }
  let client = await getWindowClient(url);
  if (!client) {
    client = await self.clients.openWindow(link);
    await sleep2(3e3);
  } else {
    client = await client.focus();
  }
  if (!client) {
    return;
  }
  internalPayload.messageType = MessageType2.NOTIFICATION_CLICKED;
  internalPayload.isFirebaseMessaging = true;
  return client.postMessage(internalPayload);
}
function wrapInternalPayload(internalPayload) {
  const wrappedInternalPayload = Object.assign({}, internalPayload.notification);
  wrappedInternalPayload.data = {
    [FCM_MSG]: internalPayload
  };
  return wrappedInternalPayload;
}
function getMessagePayloadInternal({ data }) {
  if (!data) {
    return null;
  }
  try {
    return data.json();
  } catch (err) {
    return null;
  }
}
async function getWindowClient(url) {
  const clientList = await getClientList();
  for (const client of clientList) {
    const clientUrl = new URL(client.url, self.location.href);
    if (url.host === clientUrl.host) {
      return client;
    }
  }
  return null;
}
function hasVisibleClients(clientList) {
  return clientList.some((client) => client.visibilityState === "visible" && !client.url.startsWith("chrome-extension://"));
}
function sendMessagePayloadInternalToWindows(clientList, internalPayload) {
  internalPayload.isFirebaseMessaging = true;
  internalPayload.messageType = MessageType2.PUSH_RECEIVED;
  for (const client of clientList) {
    client.postMessage(internalPayload);
  }
}
function getClientList() {
  return self.clients.matchAll({
    type: "window",
    includeUncontrolled: true
  });
}
function showNotification(notificationPayloadInternal) {
  var _a2;
  const { actions } = notificationPayloadInternal;
  const { maxActions } = Notification;
  if (actions && maxActions && actions.length > maxActions) {
    console.warn(`This browser only supports ${maxActions} actions. The remaining actions will not be displayed.`);
  }
  return self.registration.showNotification((_a2 = notificationPayloadInternal.title) !== null && _a2 !== void 0 ? _a2 : "", notificationPayloadInternal);
}
function getLink(payload) {
  var _a2, _b, _c2;
  const link = (_b = (_a2 = payload.fcmOptions) === null || _a2 === void 0 ? void 0 : _a2.link) !== null && _b !== void 0 ? _b : (_c2 = payload.notification) === null || _c2 === void 0 ? void 0 : _c2.click_action;
  if (link) {
    return link;
  }
  if (isConsoleMessage2(payload.data)) {
    return self.location.origin;
  } else {
    return null;
  }
}
function extractAppConfig2(app) {
  if (!app || !app.options) {
    throw getMissingValueError2("App Configuration Object");
  }
  if (!app.name) {
    throw getMissingValueError2("App Name");
  }
  const configKeys = [
    "projectId",
    "apiKey",
    "appId",
    "messagingSenderId"
  ];
  const { options } = app;
  for (const keyName of configKeys) {
    if (!options[keyName]) {
      throw getMissingValueError2(keyName);
    }
  }
  return {
    appName: app.name,
    projectId: options.projectId,
    apiKey: options.apiKey,
    appId: options.appId,
    senderId: options.messagingSenderId
  };
}
function getMissingValueError2(valueName) {
  return ERROR_FACTORY5.create("missing-app-config-values", {
    valueName
  });
}
var MessagingService2 = class {
  constructor(app, installations, analyticsProvider) {
    this.deliveryMetricsExportedToBigQueryEnabled = false;
    this.onBackgroundMessageHandler = null;
    this.onMessageHandler = null;
    this.logEvents = [];
    this.isLogServiceStarted = false;
    const appConfig = extractAppConfig2(app);
    this.firebaseDependencies = {
      app,
      appConfig,
      installations,
      analyticsProvider
    };
  }
  _delete() {
    return Promise.resolve();
  }
};
var SwMessagingFactory = (container) => {
  const messaging = new MessagingService2(container.getProvider("app").getImmediate(), container.getProvider("installations-internal").getImmediate(), container.getProvider("analytics-internal"));
  self.addEventListener("push", (e) => {
    e.waitUntil(onPush(e, messaging));
  });
  self.addEventListener("pushsubscriptionchange", (e) => {
    e.waitUntil(onSubChange(e, messaging));
  });
  self.addEventListener("notificationclick", (e) => {
    e.waitUntil(onNotificationClick(e));
  });
  return messaging;
};
function registerMessagingInSw() {
  _registerComponent(new Component("messaging-sw", SwMessagingFactory, "PUBLIC"));
}
function onBackgroundMessage$1(messaging, nextOrObserver) {
  if (self.document !== void 0) {
    throw ERROR_FACTORY5.create("only-available-in-sw");
  }
  messaging.onBackgroundMessageHandler = nextOrObserver;
  return () => {
    messaging.onBackgroundMessageHandler = null;
  };
}
function onBackgroundMessage(messaging, nextOrObserver) {
  messaging = getModularInstance(messaging);
  return onBackgroundMessage$1(messaging, nextOrObserver);
}
registerMessagingInSw();

// node_modules/@firebase/messaging-compat/dist/esm/index.esm2017.js
var name11 = "@firebase/messaging-compat";
var version11 = "0.1.14";
function isSupported2() {
  if (self && "ServiceWorkerGlobalScope" in self) {
    return isSwSupported();
  } else {
    return isWindowSupported();
  }
}
function isWindowSupported() {
  return typeof window !== "undefined" && isIndexedDBAvailable() && areCookiesEnabled() && "serviceWorker" in navigator && "PushManager" in window && "Notification" in window && "fetch" in window && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey");
}
function isSwSupported() {
  return isIndexedDBAvailable() && "PushManager" in self && "Notification" in self && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey");
}
var MessagingCompatImpl = class {
  constructor(app, _delegate) {
    this.app = app;
    this._delegate = _delegate;
    this.app = app;
    this._delegate = _delegate;
  }
  async getToken(options) {
    return getToken2(this._delegate, options);
  }
  async deleteToken() {
    return deleteToken(this._delegate);
  }
  onMessage(nextOrObserver) {
    return onMessage(this._delegate, nextOrObserver);
  }
  onBackgroundMessage(nextOrObserver) {
    return onBackgroundMessage(this._delegate, nextOrObserver);
  }
};
var messagingCompatFactory = (container) => {
  if (self && "ServiceWorkerGlobalScope" in self) {
    return new MessagingCompatImpl(container.getProvider("app-compat").getImmediate(), container.getProvider("messaging-sw").getImmediate());
  } else {
    return new MessagingCompatImpl(container.getProvider("app-compat").getImmediate(), container.getProvider("messaging").getImmediate());
  }
};
var NAMESPACE_EXPORTS = {
  isSupported: isSupported2
};
function registerMessagingCompat() {
  firebase.INTERNAL.registerComponent(new Component("messaging-compat", messagingCompatFactory, "PUBLIC").setServiceProps(NAMESPACE_EXPORTS));
}
registerMessagingCompat();
firebase.registerVersion(name11, version11);

// node_modules/@firebase/storage/dist/index.esm2017.js
var DEFAULT_HOST = "firebasestorage.googleapis.com";
var CONFIG_STORAGE_BUCKET_KEY = "storageBucket";
var DEFAULT_MAX_OPERATION_RETRY_TIME = 2 * 60 * 1e3;
var DEFAULT_MAX_UPLOAD_RETRY_TIME = 10 * 60 * 1e3;
var StorageError = class extends FirebaseError {
  constructor(code, message) {
    super(prependCode(code), `Firebase Storage: ${message} (${prependCode(code)})`);
    this.customData = { serverResponse: null };
    this._baseMessage = this.message;
    Object.setPrototypeOf(this, StorageError.prototype);
  }
  _codeEquals(code) {
    return prependCode(code) === this.code;
  }
  get serverResponse() {
    return this.customData.serverResponse;
  }
  set serverResponse(serverResponse) {
    this.customData.serverResponse = serverResponse;
    if (this.customData.serverResponse) {
      this.message = `${this._baseMessage}
${this.customData.serverResponse}`;
    } else {
      this.message = this._baseMessage;
    }
  }
};
function prependCode(code) {
  return "storage/" + code;
}
function unknown() {
  const message = "An unknown error occurred, please check the error payload for server response.";
  return new StorageError("unknown", message);
}
function objectNotFound(path) {
  return new StorageError("object-not-found", "Object '" + path + "' does not exist.");
}
function quotaExceeded(bucket) {
  return new StorageError("quota-exceeded", "Quota for bucket '" + bucket + "' exceeded, please view quota on https://firebase.google.com/pricing/.");
}
function unauthenticated() {
  const message = "User is not authenticated, please authenticate using Firebase Authentication and try again.";
  return new StorageError("unauthenticated", message);
}
function unauthorizedApp() {
  return new StorageError("unauthorized-app", "This app does not have permission to access Firebase Storage on this project.");
}
function unauthorized(path) {
  return new StorageError("unauthorized", "User does not have permission to access '" + path + "'.");
}
function retryLimitExceeded() {
  return new StorageError("retry-limit-exceeded", "Max retry time for operation exceeded, please try again.");
}
function canceled() {
  return new StorageError("canceled", "User canceled the upload/download.");
}
function invalidUrl(url) {
  return new StorageError("invalid-url", "Invalid URL '" + url + "'.");
}
function invalidDefaultBucket(bucket) {
  return new StorageError("invalid-default-bucket", "Invalid default bucket '" + bucket + "'.");
}
function noDefaultBucket() {
  return new StorageError("no-default-bucket", "No default bucket found. Did you set the '" + CONFIG_STORAGE_BUCKET_KEY + "' property when initializing the app?");
}
function cannotSliceBlob() {
  return new StorageError("cannot-slice-blob", "Cannot slice blob for upload. Please retry the upload.");
}
function serverFileWrongSize() {
  return new StorageError("server-file-wrong-size", "Server recorded incorrect upload file size, please retry the upload.");
}
function noDownloadURL() {
  return new StorageError("no-download-url", "The given file does not have any download URLs.");
}
function invalidArgument(message) {
  return new StorageError("invalid-argument", message);
}
function appDeleted() {
  return new StorageError("app-deleted", "The Firebase app was deleted.");
}
function invalidRootOperation(name19) {
  return new StorageError("invalid-root-operation", "The operation '" + name19 + "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').");
}
function invalidFormat(format, message) {
  return new StorageError("invalid-format", "String does not match format '" + format + "': " + message);
}
function internalError(message) {
  throw new StorageError("internal-error", "Internal error: " + message);
}
var Location = class {
  constructor(bucket, path) {
    this.bucket = bucket;
    this.path_ = path;
  }
  get path() {
    return this.path_;
  }
  get isRoot() {
    return this.path.length === 0;
  }
  fullServerUrl() {
    const encode2 = encodeURIComponent;
    return "/b/" + encode2(this.bucket) + "/o/" + encode2(this.path);
  }
  bucketOnlyServerUrl() {
    const encode2 = encodeURIComponent;
    return "/b/" + encode2(this.bucket) + "/o";
  }
  static makeFromBucketSpec(bucketString, host) {
    let bucketLocation;
    try {
      bucketLocation = Location.makeFromUrl(bucketString, host);
    } catch (e) {
      return new Location(bucketString, "");
    }
    if (bucketLocation.path === "") {
      return bucketLocation;
    } else {
      throw invalidDefaultBucket(bucketString);
    }
  }
  static makeFromUrl(url, host) {
    let location = null;
    const bucketDomain = "([A-Za-z0-9.\\-_]+)";
    function gsModify(loc) {
      if (loc.path.charAt(loc.path.length - 1) === "/") {
        loc.path_ = loc.path_.slice(0, -1);
      }
    }
    const gsPath = "(/(.*))?$";
    const gsRegex = new RegExp("^gs://" + bucketDomain + gsPath, "i");
    const gsIndices = { bucket: 1, path: 3 };
    function httpModify(loc) {
      loc.path_ = decodeURIComponent(loc.path);
    }
    const version19 = "v[A-Za-z0-9_]+";
    const firebaseStorageHost = host.replace(/[.]/g, "\\.");
    const firebaseStoragePath = "(/([^?#]*).*)?$";
    const firebaseStorageRegExp = new RegExp(`^https?://${firebaseStorageHost}/${version19}/b/${bucketDomain}/o${firebaseStoragePath}`, "i");
    const firebaseStorageIndices = { bucket: 1, path: 3 };
    const cloudStorageHost = host === DEFAULT_HOST ? "(?:storage.googleapis.com|storage.cloud.google.com)" : host;
    const cloudStoragePath = "([^?#]*)";
    const cloudStorageRegExp = new RegExp(`^https?://${cloudStorageHost}/${bucketDomain}/${cloudStoragePath}`, "i");
    const cloudStorageIndices = { bucket: 1, path: 2 };
    const groups = [
      { regex: gsRegex, indices: gsIndices, postModify: gsModify },
      {
        regex: firebaseStorageRegExp,
        indices: firebaseStorageIndices,
        postModify: httpModify
      },
      {
        regex: cloudStorageRegExp,
        indices: cloudStorageIndices,
        postModify: httpModify
      }
    ];
    for (let i = 0; i < groups.length; i++) {
      const group = groups[i];
      const captures = group.regex.exec(url);
      if (captures) {
        const bucketValue = captures[group.indices.bucket];
        let pathValue = captures[group.indices.path];
        if (!pathValue) {
          pathValue = "";
        }
        location = new Location(bucketValue, pathValue);
        group.postModify(location);
        break;
      }
    }
    if (location == null) {
      throw invalidUrl(url);
    }
    return location;
  }
};
var FailRequest = class {
  constructor(error) {
    this.promise_ = Promise.reject(error);
  }
  getPromise() {
    return this.promise_;
  }
  cancel(_appDelete = false) {
  }
};
function start(f, callback, timeout) {
  let waitSeconds = 1;
  let retryTimeoutId = null;
  let globalTimeoutId = null;
  let hitTimeout = false;
  let cancelState = 0;
  function canceled2() {
    return cancelState === 2;
  }
  let triggeredCallback = false;
  function triggerCallback(...args) {
    if (!triggeredCallback) {
      triggeredCallback = true;
      callback.apply(null, args);
    }
  }
  function callWithDelay(millis) {
    retryTimeoutId = setTimeout(() => {
      retryTimeoutId = null;
      f(handler, canceled2());
    }, millis);
  }
  function clearGlobalTimeout() {
    if (globalTimeoutId) {
      clearTimeout(globalTimeoutId);
    }
  }
  function handler(success, ...args) {
    if (triggeredCallback) {
      clearGlobalTimeout();
      return;
    }
    if (success) {
      clearGlobalTimeout();
      triggerCallback.call(null, success, ...args);
      return;
    }
    const mustStop = canceled2() || hitTimeout;
    if (mustStop) {
      clearGlobalTimeout();
      triggerCallback.call(null, success, ...args);
      return;
    }
    if (waitSeconds < 64) {
      waitSeconds *= 2;
    }
    let waitMillis;
    if (cancelState === 1) {
      cancelState = 2;
      waitMillis = 0;
    } else {
      waitMillis = (waitSeconds + Math.random()) * 1e3;
    }
    callWithDelay(waitMillis);
  }
  let stopped = false;
  function stop2(wasTimeout) {
    if (stopped) {
      return;
    }
    stopped = true;
    clearGlobalTimeout();
    if (triggeredCallback) {
      return;
    }
    if (retryTimeoutId !== null) {
      if (!wasTimeout) {
        cancelState = 2;
      }
      clearTimeout(retryTimeoutId);
      callWithDelay(0);
    } else {
      if (!wasTimeout) {
        cancelState = 1;
      }
    }
  }
  callWithDelay(0);
  globalTimeoutId = setTimeout(() => {
    hitTimeout = true;
    stop2(true);
  }, timeout);
  return stop2;
}
function stop(id2) {
  id2(false);
}
function isJustDef(p2) {
  return p2 !== void 0;
}
function isFunction(p2) {
  return typeof p2 === "function";
}
function isNonArrayObject(p2) {
  return typeof p2 === "object" && !Array.isArray(p2);
}
function isString(p2) {
  return typeof p2 === "string" || p2 instanceof String;
}
function isNativeBlob(p2) {
  return isNativeBlobDefined() && p2 instanceof Blob;
}
function isNativeBlobDefined() {
  return typeof Blob !== "undefined";
}
function validateNumber(argument, minValue, maxValue, value) {
  if (value < minValue) {
    throw invalidArgument(`Invalid value for '${argument}'. Expected ${minValue} or greater.`);
  }
  if (value > maxValue) {
    throw invalidArgument(`Invalid value for '${argument}'. Expected ${maxValue} or less.`);
  }
}
function makeUrl(urlPart, host, protocol) {
  let origin = host;
  if (protocol == null) {
    origin = `https://${host}`;
  }
  return `${protocol}://${origin}/v0${urlPart}`;
}
function makeQueryString(params) {
  const encode2 = encodeURIComponent;
  let queryPart = "?";
  for (const key in params) {
    if (params.hasOwnProperty(key)) {
      const nextPart = encode2(key) + "=" + encode2(params[key]);
      queryPart = queryPart + nextPart + "&";
    }
  }
  queryPart = queryPart.slice(0, -1);
  return queryPart;
}
var ErrorCode2;
(function(ErrorCode3) {
  ErrorCode3[ErrorCode3["NO_ERROR"] = 0] = "NO_ERROR";
  ErrorCode3[ErrorCode3["NETWORK_ERROR"] = 1] = "NETWORK_ERROR";
  ErrorCode3[ErrorCode3["ABORT"] = 2] = "ABORT";
})(ErrorCode2 || (ErrorCode2 = {}));
var NetworkRequest = class {
  constructor(url_, method_, headers_, body_, successCodes_, additionalRetryCodes_, callback_, errorCallback_, timeout_, progressCallback_, connectionFactory_) {
    this.url_ = url_;
    this.method_ = method_;
    this.headers_ = headers_;
    this.body_ = body_;
    this.successCodes_ = successCodes_;
    this.additionalRetryCodes_ = additionalRetryCodes_;
    this.callback_ = callback_;
    this.errorCallback_ = errorCallback_;
    this.timeout_ = timeout_;
    this.progressCallback_ = progressCallback_;
    this.connectionFactory_ = connectionFactory_;
    this.pendingConnection_ = null;
    this.backoffId_ = null;
    this.canceled_ = false;
    this.appDelete_ = false;
    this.promise_ = new Promise((resolve, reject) => {
      this.resolve_ = resolve;
      this.reject_ = reject;
      this.start_();
    });
  }
  start_() {
    const doTheRequest = (backoffCallback, canceled2) => {
      if (canceled2) {
        backoffCallback(false, new RequestEndStatus(false, null, true));
        return;
      }
      const connection = this.connectionFactory_();
      this.pendingConnection_ = connection;
      const progressListener = (progressEvent) => {
        const loaded = progressEvent.loaded;
        const total = progressEvent.lengthComputable ? progressEvent.total : -1;
        if (this.progressCallback_ !== null) {
          this.progressCallback_(loaded, total);
        }
      };
      if (this.progressCallback_ !== null) {
        connection.addUploadProgressListener(progressListener);
      }
      connection.send(this.url_, this.method_, this.body_, this.headers_).then(() => {
        if (this.progressCallback_ !== null) {
          connection.removeUploadProgressListener(progressListener);
        }
        this.pendingConnection_ = null;
        const hitServer = connection.getErrorCode() === ErrorCode2.NO_ERROR;
        const status = connection.getStatus();
        if (!hitServer || this.isRetryStatusCode_(status)) {
          const wasCanceled = connection.getErrorCode() === ErrorCode2.ABORT;
          backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));
          return;
        }
        const successCode = this.successCodes_.indexOf(status) !== -1;
        backoffCallback(true, new RequestEndStatus(successCode, connection));
      });
    };
    const backoffDone = (requestWentThrough, status) => {
      const resolve = this.resolve_;
      const reject = this.reject_;
      const connection = status.connection;
      if (status.wasSuccessCode) {
        try {
          const result = this.callback_(connection, connection.getResponse());
          if (isJustDef(result)) {
            resolve(result);
          } else {
            resolve();
          }
        } catch (e) {
          reject(e);
        }
      } else {
        if (connection !== null) {
          const err = unknown();
          err.serverResponse = connection.getErrorText();
          if (this.errorCallback_) {
            reject(this.errorCallback_(connection, err));
          } else {
            reject(err);
          }
        } else {
          if (status.canceled) {
            const err = this.appDelete_ ? appDeleted() : canceled();
            reject(err);
          } else {
            const err = retryLimitExceeded();
            reject(err);
          }
        }
      }
    };
    if (this.canceled_) {
      backoffDone(false, new RequestEndStatus(false, null, true));
    } else {
      this.backoffId_ = start(doTheRequest, backoffDone, this.timeout_);
    }
  }
  getPromise() {
    return this.promise_;
  }
  cancel(appDelete) {
    this.canceled_ = true;
    this.appDelete_ = appDelete || false;
    if (this.backoffId_ !== null) {
      stop(this.backoffId_);
    }
    if (this.pendingConnection_ !== null) {
      this.pendingConnection_.abort();
    }
  }
  isRetryStatusCode_(status) {
    const isFiveHundredCode = status >= 500 && status < 600;
    const extraRetryCodes = [
      408,
      429
    ];
    const isExtraRetryCode = extraRetryCodes.indexOf(status) !== -1;
    const isRequestSpecificRetryCode = this.additionalRetryCodes_.indexOf(status) !== -1;
    return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;
  }
};
var RequestEndStatus = class {
  constructor(wasSuccessCode, connection, canceled2) {
    this.wasSuccessCode = wasSuccessCode;
    this.connection = connection;
    this.canceled = !!canceled2;
  }
};
function addAuthHeader_(headers, authToken) {
  if (authToken !== null && authToken.length > 0) {
    headers["Authorization"] = "Firebase " + authToken;
  }
}
function addVersionHeader_(headers, firebaseVersion) {
  headers["X-Firebase-Storage-Version"] = "webjs/" + (firebaseVersion !== null && firebaseVersion !== void 0 ? firebaseVersion : "AppManager");
}
function addGmpidHeader_(headers, appId) {
  if (appId) {
    headers["X-Firebase-GMPID"] = appId;
  }
}
function addAppCheckHeader_(headers, appCheckToken) {
  if (appCheckToken !== null) {
    headers["X-Firebase-AppCheck"] = appCheckToken;
  }
}
function makeRequest(requestInfo, appId, authToken, appCheckToken, requestFactory, firebaseVersion) {
  const queryPart = makeQueryString(requestInfo.urlParams);
  const url = requestInfo.url + queryPart;
  const headers = Object.assign({}, requestInfo.headers);
  addGmpidHeader_(headers, appId);
  addAuthHeader_(headers, authToken);
  addVersionHeader_(headers, firebaseVersion);
  addAppCheckHeader_(headers, appCheckToken);
  return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, requestFactory);
}
function getBlobBuilder() {
  if (typeof BlobBuilder !== "undefined") {
    return BlobBuilder;
  } else if (typeof WebKitBlobBuilder !== "undefined") {
    return WebKitBlobBuilder;
  } else {
    return void 0;
  }
}
function getBlob$1(...args) {
  const BlobBuilder2 = getBlobBuilder();
  if (BlobBuilder2 !== void 0) {
    const bb2 = new BlobBuilder2();
    for (let i = 0; i < args.length; i++) {
      bb2.append(args[i]);
    }
    return bb2.getBlob();
  } else {
    if (isNativeBlobDefined()) {
      return new Blob(args);
    } else {
      throw new StorageError("unsupported-environment", "This browser doesn't seem to support creating Blobs");
    }
  }
}
function sliceBlob(blob, start2, end) {
  if (blob.webkitSlice) {
    return blob.webkitSlice(start2, end);
  } else if (blob.mozSlice) {
    return blob.mozSlice(start2, end);
  } else if (blob.slice) {
    return blob.slice(start2, end);
  }
  return null;
}
function decodeBase64(encoded) {
  return atob(encoded);
}
var StringFormat = {
  RAW: "raw",
  BASE64: "base64",
  BASE64URL: "base64url",
  DATA_URL: "data_url"
};
var StringData = class {
  constructor(data, contentType) {
    this.data = data;
    this.contentType = contentType || null;
  }
};
function dataFromString(format, stringData) {
  switch (format) {
    case StringFormat.RAW:
      return new StringData(utf8Bytes_(stringData));
    case StringFormat.BASE64:
    case StringFormat.BASE64URL:
      return new StringData(base64Bytes_(format, stringData));
    case StringFormat.DATA_URL:
      return new StringData(dataURLBytes_(stringData), dataURLContentType_(stringData));
  }
  throw unknown();
}
function utf8Bytes_(value) {
  const b = [];
  for (let i = 0; i < value.length; i++) {
    let c = value.charCodeAt(i);
    if (c <= 127) {
      b.push(c);
    } else {
      if (c <= 2047) {
        b.push(192 | c >> 6, 128 | c & 63);
      } else {
        if ((c & 64512) === 55296) {
          const valid = i < value.length - 1 && (value.charCodeAt(i + 1) & 64512) === 56320;
          if (!valid) {
            b.push(239, 191, 189);
          } else {
            const hi2 = c;
            const lo2 = value.charCodeAt(++i);
            c = 65536 | (hi2 & 1023) << 10 | lo2 & 1023;
            b.push(240 | c >> 18, 128 | c >> 12 & 63, 128 | c >> 6 & 63, 128 | c & 63);
          }
        } else {
          if ((c & 64512) === 56320) {
            b.push(239, 191, 189);
          } else {
            b.push(224 | c >> 12, 128 | c >> 6 & 63, 128 | c & 63);
          }
        }
      }
    }
  }
  return new Uint8Array(b);
}
function percentEncodedBytes_(value) {
  let decoded;
  try {
    decoded = decodeURIComponent(value);
  } catch (e) {
    throw invalidFormat(StringFormat.DATA_URL, "Malformed data URL.");
  }
  return utf8Bytes_(decoded);
}
function base64Bytes_(format, value) {
  switch (format) {
    case StringFormat.BASE64: {
      const hasMinus = value.indexOf("-") !== -1;
      const hasUnder = value.indexOf("_") !== -1;
      if (hasMinus || hasUnder) {
        const invalidChar = hasMinus ? "-" : "_";
        throw invalidFormat(format, "Invalid character '" + invalidChar + "' found: is it base64url encoded?");
      }
      break;
    }
    case StringFormat.BASE64URL: {
      const hasPlus = value.indexOf("+") !== -1;
      const hasSlash = value.indexOf("/") !== -1;
      if (hasPlus || hasSlash) {
        const invalidChar = hasPlus ? "+" : "/";
        throw invalidFormat(format, "Invalid character '" + invalidChar + "' found: is it base64 encoded?");
      }
      value = value.replace(/-/g, "+").replace(/_/g, "/");
      break;
    }
  }
  let bytes;
  try {
    bytes = decodeBase64(value);
  } catch (e) {
    throw invalidFormat(format, "Invalid character found");
  }
  const array = new Uint8Array(bytes.length);
  for (let i = 0; i < bytes.length; i++) {
    array[i] = bytes.charCodeAt(i);
  }
  return array;
}
var DataURLParts = class {
  constructor(dataURL) {
    this.base64 = false;
    this.contentType = null;
    const matches = dataURL.match(/^data:([^,]+)?,/);
    if (matches === null) {
      throw invalidFormat(StringFormat.DATA_URL, "Must be formatted 'data:[<mediatype>][;base64],<data>");
    }
    const middle = matches[1] || null;
    if (middle != null) {
      this.base64 = endsWith(middle, ";base64");
      this.contentType = this.base64 ? middle.substring(0, middle.length - ";base64".length) : middle;
    }
    this.rest = dataURL.substring(dataURL.indexOf(",") + 1);
  }
};
function dataURLBytes_(dataUrl) {
  const parts = new DataURLParts(dataUrl);
  if (parts.base64) {
    return base64Bytes_(StringFormat.BASE64, parts.rest);
  } else {
    return percentEncodedBytes_(parts.rest);
  }
}
function dataURLContentType_(dataUrl) {
  const parts = new DataURLParts(dataUrl);
  return parts.contentType;
}
function endsWith(s, end) {
  const longEnough = s.length >= end.length;
  if (!longEnough) {
    return false;
  }
  return s.substring(s.length - end.length) === end;
}
var FbsBlob = class {
  constructor(data, elideCopy) {
    let size = 0;
    let blobType = "";
    if (isNativeBlob(data)) {
      this.data_ = data;
      size = data.size;
      blobType = data.type;
    } else if (data instanceof ArrayBuffer) {
      if (elideCopy) {
        this.data_ = new Uint8Array(data);
      } else {
        this.data_ = new Uint8Array(data.byteLength);
        this.data_.set(new Uint8Array(data));
      }
      size = this.data_.length;
    } else if (data instanceof Uint8Array) {
      if (elideCopy) {
        this.data_ = data;
      } else {
        this.data_ = new Uint8Array(data.length);
        this.data_.set(data);
      }
      size = data.length;
    }
    this.size_ = size;
    this.type_ = blobType;
  }
  size() {
    return this.size_;
  }
  type() {
    return this.type_;
  }
  slice(startByte, endByte) {
    if (isNativeBlob(this.data_)) {
      const realBlob = this.data_;
      const sliced = sliceBlob(realBlob, startByte, endByte);
      if (sliced === null) {
        return null;
      }
      return new FbsBlob(sliced);
    } else {
      const slice = new Uint8Array(this.data_.buffer, startByte, endByte - startByte);
      return new FbsBlob(slice, true);
    }
  }
  static getBlob(...args) {
    if (isNativeBlobDefined()) {
      const blobby = args.map((val) => {
        if (val instanceof FbsBlob) {
          return val.data_;
        } else {
          return val;
        }
      });
      return new FbsBlob(getBlob$1.apply(null, blobby));
    } else {
      const uint8Arrays = args.map((val) => {
        if (isString(val)) {
          return dataFromString(StringFormat.RAW, val).data;
        } else {
          return val.data_;
        }
      });
      let finalLength = 0;
      uint8Arrays.forEach((array) => {
        finalLength += array.byteLength;
      });
      const merged = new Uint8Array(finalLength);
      let index = 0;
      uint8Arrays.forEach((array) => {
        for (let i = 0; i < array.length; i++) {
          merged[index++] = array[i];
        }
      });
      return new FbsBlob(merged, true);
    }
  }
  uploadData() {
    return this.data_;
  }
};
function jsonObjectOrNull(s) {
  let obj;
  try {
    obj = JSON.parse(s);
  } catch (e) {
    return null;
  }
  if (isNonArrayObject(obj)) {
    return obj;
  } else {
    return null;
  }
}
function parent(path) {
  if (path.length === 0) {
    return null;
  }
  const index = path.lastIndexOf("/");
  if (index === -1) {
    return "";
  }
  const newPath = path.slice(0, index);
  return newPath;
}
function child2(path, childPath) {
  const canonicalChildPath = childPath.split("/").filter((component) => component.length > 0).join("/");
  if (path.length === 0) {
    return canonicalChildPath;
  } else {
    return path + "/" + canonicalChildPath;
  }
}
function lastComponent(path) {
  const index = path.lastIndexOf("/", path.length - 2);
  if (index === -1) {
    return path;
  } else {
    return path.slice(index + 1);
  }
}
function noXform_(metadata, value) {
  return value;
}
var Mapping = class {
  constructor(server, local, writable, xform) {
    this.server = server;
    this.local = local || server;
    this.writable = !!writable;
    this.xform = xform || noXform_;
  }
};
var mappings_ = null;
function xformPath(fullPath) {
  if (!isString(fullPath) || fullPath.length < 2) {
    return fullPath;
  } else {
    return lastComponent(fullPath);
  }
}
function getMappings() {
  if (mappings_) {
    return mappings_;
  }
  const mappings = [];
  mappings.push(new Mapping("bucket"));
  mappings.push(new Mapping("generation"));
  mappings.push(new Mapping("metageneration"));
  mappings.push(new Mapping("name", "fullPath", true));
  function mappingsXformPath(_metadata, fullPath) {
    return xformPath(fullPath);
  }
  const nameMapping = new Mapping("name");
  nameMapping.xform = mappingsXformPath;
  mappings.push(nameMapping);
  function xformSize(_metadata, size) {
    if (size !== void 0) {
      return Number(size);
    } else {
      return size;
    }
  }
  const sizeMapping = new Mapping("size");
  sizeMapping.xform = xformSize;
  mappings.push(sizeMapping);
  mappings.push(new Mapping("timeCreated"));
  mappings.push(new Mapping("updated"));
  mappings.push(new Mapping("md5Hash", null, true));
  mappings.push(new Mapping("cacheControl", null, true));
  mappings.push(new Mapping("contentDisposition", null, true));
  mappings.push(new Mapping("contentEncoding", null, true));
  mappings.push(new Mapping("contentLanguage", null, true));
  mappings.push(new Mapping("contentType", null, true));
  mappings.push(new Mapping("metadata", "customMetadata", true));
  mappings_ = mappings;
  return mappings_;
}
function addRef(metadata, service) {
  function generateRef() {
    const bucket = metadata["bucket"];
    const path = metadata["fullPath"];
    const loc = new Location(bucket, path);
    return service._makeStorageReference(loc);
  }
  Object.defineProperty(metadata, "ref", { get: generateRef });
}
function fromResource(service, resource, mappings) {
  const metadata = {};
  metadata["type"] = "file";
  const len = mappings.length;
  for (let i = 0; i < len; i++) {
    const mapping = mappings[i];
    metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);
  }
  addRef(metadata, service);
  return metadata;
}
function fromResourceString(service, resourceString, mappings) {
  const obj = jsonObjectOrNull(resourceString);
  if (obj === null) {
    return null;
  }
  const resource = obj;
  return fromResource(service, resource, mappings);
}
function downloadUrlFromResourceString(metadata, resourceString, host, protocol) {
  const obj = jsonObjectOrNull(resourceString);
  if (obj === null) {
    return null;
  }
  if (!isString(obj["downloadTokens"])) {
    return null;
  }
  const tokens = obj["downloadTokens"];
  if (tokens.length === 0) {
    return null;
  }
  const encode2 = encodeURIComponent;
  const tokensList = tokens.split(",");
  const urls = tokensList.map((token) => {
    const bucket = metadata["bucket"];
    const path = metadata["fullPath"];
    const urlPart = "/b/" + encode2(bucket) + "/o/" + encode2(path);
    const base = makeUrl(urlPart, host, protocol);
    const queryString = makeQueryString({
      alt: "media",
      token
    });
    return base + queryString;
  });
  return urls[0];
}
function toResourceString(metadata, mappings) {
  const resource = {};
  const len = mappings.length;
  for (let i = 0; i < len; i++) {
    const mapping = mappings[i];
    if (mapping.writable) {
      resource[mapping.server] = metadata[mapping.local];
    }
  }
  return JSON.stringify(resource);
}
var PREFIXES_KEY = "prefixes";
var ITEMS_KEY = "items";
function fromBackendResponse(service, bucket, resource) {
  const listResult = {
    prefixes: [],
    items: [],
    nextPageToken: resource["nextPageToken"]
  };
  if (resource[PREFIXES_KEY]) {
    for (const path of resource[PREFIXES_KEY]) {
      const pathWithoutTrailingSlash = path.replace(/\/$/, "");
      const reference = service._makeStorageReference(new Location(bucket, pathWithoutTrailingSlash));
      listResult.prefixes.push(reference);
    }
  }
  if (resource[ITEMS_KEY]) {
    for (const item of resource[ITEMS_KEY]) {
      const reference = service._makeStorageReference(new Location(bucket, item["name"]));
      listResult.items.push(reference);
    }
  }
  return listResult;
}
function fromResponseString(service, bucket, resourceString) {
  const obj = jsonObjectOrNull(resourceString);
  if (obj === null) {
    return null;
  }
  const resource = obj;
  return fromBackendResponse(service, bucket, resource);
}
var RequestInfo = class {
  constructor(url, method, handler, timeout) {
    this.url = url;
    this.method = method;
    this.handler = handler;
    this.timeout = timeout;
    this.urlParams = {};
    this.headers = {};
    this.body = null;
    this.errorHandler = null;
    this.progressCallback = null;
    this.successCodes = [200];
    this.additionalRetryCodes = [];
  }
};
function handlerCheck(cndn) {
  if (!cndn) {
    throw unknown();
  }
}
function metadataHandler(service, mappings) {
  function handler(xhr, text) {
    const metadata = fromResourceString(service, text, mappings);
    handlerCheck(metadata !== null);
    return metadata;
  }
  return handler;
}
function listHandler(service, bucket) {
  function handler(xhr, text) {
    const listResult = fromResponseString(service, bucket, text);
    handlerCheck(listResult !== null);
    return listResult;
  }
  return handler;
}
function downloadUrlHandler(service, mappings) {
  function handler(xhr, text) {
    const metadata = fromResourceString(service, text, mappings);
    handlerCheck(metadata !== null);
    return downloadUrlFromResourceString(metadata, text, service.host, service._protocol);
  }
  return handler;
}
function sharedErrorHandler(location) {
  function errorHandler(xhr, err) {
    let newErr;
    if (xhr.getStatus() === 401) {
      if (xhr.getErrorText().includes("Firebase App Check token is invalid")) {
        newErr = unauthorizedApp();
      } else {
        newErr = unauthenticated();
      }
    } else {
      if (xhr.getStatus() === 402) {
        newErr = quotaExceeded(location.bucket);
      } else {
        if (xhr.getStatus() === 403) {
          newErr = unauthorized(location.path);
        } else {
          newErr = err;
        }
      }
    }
    newErr.serverResponse = err.serverResponse;
    return newErr;
  }
  return errorHandler;
}
function objectErrorHandler(location) {
  const shared = sharedErrorHandler(location);
  function errorHandler(xhr, err) {
    let newErr = shared(xhr, err);
    if (xhr.getStatus() === 404) {
      newErr = objectNotFound(location.path);
    }
    newErr.serverResponse = err.serverResponse;
    return newErr;
  }
  return errorHandler;
}
function getMetadata$2(service, location, mappings) {
  const urlPart = location.fullServerUrl();
  const url = makeUrl(urlPart, service.host, service._protocol);
  const method = "GET";
  const timeout = service.maxOperationRetryTime;
  const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
  requestInfo.errorHandler = objectErrorHandler(location);
  return requestInfo;
}
function list$2(service, location, delimiter, pageToken, maxResults) {
  const urlParams = {};
  if (location.isRoot) {
    urlParams["prefix"] = "";
  } else {
    urlParams["prefix"] = location.path + "/";
  }
  if (delimiter && delimiter.length > 0) {
    urlParams["delimiter"] = delimiter;
  }
  if (pageToken) {
    urlParams["pageToken"] = pageToken;
  }
  if (maxResults) {
    urlParams["maxResults"] = maxResults;
  }
  const urlPart = location.bucketOnlyServerUrl();
  const url = makeUrl(urlPart, service.host, service._protocol);
  const method = "GET";
  const timeout = service.maxOperationRetryTime;
  const requestInfo = new RequestInfo(url, method, listHandler(service, location.bucket), timeout);
  requestInfo.urlParams = urlParams;
  requestInfo.errorHandler = sharedErrorHandler(location);
  return requestInfo;
}
function getDownloadUrl(service, location, mappings) {
  const urlPart = location.fullServerUrl();
  const url = makeUrl(urlPart, service.host, service._protocol);
  const method = "GET";
  const timeout = service.maxOperationRetryTime;
  const requestInfo = new RequestInfo(url, method, downloadUrlHandler(service, mappings), timeout);
  requestInfo.errorHandler = objectErrorHandler(location);
  return requestInfo;
}
function updateMetadata$2(service, location, metadata, mappings) {
  const urlPart = location.fullServerUrl();
  const url = makeUrl(urlPart, service.host, service._protocol);
  const method = "PATCH";
  const body = toResourceString(metadata, mappings);
  const headers = { "Content-Type": "application/json; charset=utf-8" };
  const timeout = service.maxOperationRetryTime;
  const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
  requestInfo.headers = headers;
  requestInfo.body = body;
  requestInfo.errorHandler = objectErrorHandler(location);
  return requestInfo;
}
function deleteObject$2(service, location) {
  const urlPart = location.fullServerUrl();
  const url = makeUrl(urlPart, service.host, service._protocol);
  const method = "DELETE";
  const timeout = service.maxOperationRetryTime;
  function handler(_xhr, _text) {
  }
  const requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.successCodes = [200, 204];
  requestInfo.errorHandler = objectErrorHandler(location);
  return requestInfo;
}
function determineContentType_(metadata, blob) {
  return metadata && metadata["contentType"] || blob && blob.type() || "application/octet-stream";
}
function metadataForUpload_(location, blob, metadata) {
  const metadataClone = Object.assign({}, metadata);
  metadataClone["fullPath"] = location.path;
  metadataClone["size"] = blob.size();
  if (!metadataClone["contentType"]) {
    metadataClone["contentType"] = determineContentType_(null, blob);
  }
  return metadataClone;
}
function multipartUpload(service, location, mappings, blob, metadata) {
  const urlPart = location.bucketOnlyServerUrl();
  const headers = {
    "X-Goog-Upload-Protocol": "multipart"
  };
  function genBoundary() {
    let str = "";
    for (let i = 0; i < 2; i++) {
      str = str + Math.random().toString().slice(2);
    }
    return str;
  }
  const boundary = genBoundary();
  headers["Content-Type"] = "multipart/related; boundary=" + boundary;
  const metadata_ = metadataForUpload_(location, blob, metadata);
  const metadataString = toResourceString(metadata_, mappings);
  const preBlobPart = "--" + boundary + "\r\nContent-Type: application/json; charset=utf-8\r\n\r\n" + metadataString + "\r\n--" + boundary + "\r\nContent-Type: " + metadata_["contentType"] + "\r\n\r\n";
  const postBlobPart = "\r\n--" + boundary + "--";
  const body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);
  if (body === null) {
    throw cannotSliceBlob();
  }
  const urlParams = { name: metadata_["fullPath"] };
  const url = makeUrl(urlPart, service.host, service._protocol);
  const method = "POST";
  const timeout = service.maxUploadRetryTime;
  const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
  requestInfo.urlParams = urlParams;
  requestInfo.headers = headers;
  requestInfo.body = body.uploadData();
  requestInfo.errorHandler = sharedErrorHandler(location);
  return requestInfo;
}
var ResumableUploadStatus = class {
  constructor(current, total, finalized, metadata) {
    this.current = current;
    this.total = total;
    this.finalized = !!finalized;
    this.metadata = metadata || null;
  }
};
function checkResumeHeader_(xhr, allowed) {
  let status = null;
  try {
    status = xhr.getResponseHeader("X-Goog-Upload-Status");
  } catch (e) {
    handlerCheck(false);
  }
  const allowedStatus = allowed || ["active"];
  handlerCheck(!!status && allowedStatus.indexOf(status) !== -1);
  return status;
}
function createResumableUpload(service, location, mappings, blob, metadata) {
  const urlPart = location.bucketOnlyServerUrl();
  const metadataForUpload = metadataForUpload_(location, blob, metadata);
  const urlParams = { name: metadataForUpload["fullPath"] };
  const url = makeUrl(urlPart, service.host, service._protocol);
  const method = "POST";
  const headers = {
    "X-Goog-Upload-Protocol": "resumable",
    "X-Goog-Upload-Command": "start",
    "X-Goog-Upload-Header-Content-Length": `${blob.size()}`,
    "X-Goog-Upload-Header-Content-Type": metadataForUpload["contentType"],
    "Content-Type": "application/json; charset=utf-8"
  };
  const body = toResourceString(metadataForUpload, mappings);
  const timeout = service.maxUploadRetryTime;
  function handler(xhr) {
    checkResumeHeader_(xhr);
    let url2;
    try {
      url2 = xhr.getResponseHeader("X-Goog-Upload-URL");
    } catch (e) {
      handlerCheck(false);
    }
    handlerCheck(isString(url2));
    return url2;
  }
  const requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.urlParams = urlParams;
  requestInfo.headers = headers;
  requestInfo.body = body;
  requestInfo.errorHandler = sharedErrorHandler(location);
  return requestInfo;
}
function getResumableUploadStatus(service, location, url, blob) {
  const headers = { "X-Goog-Upload-Command": "query" };
  function handler(xhr) {
    const status = checkResumeHeader_(xhr, ["active", "final"]);
    let sizeString = null;
    try {
      sizeString = xhr.getResponseHeader("X-Goog-Upload-Size-Received");
    } catch (e) {
      handlerCheck(false);
    }
    if (!sizeString) {
      handlerCheck(false);
    }
    const size = Number(sizeString);
    handlerCheck(!isNaN(size));
    return new ResumableUploadStatus(size, blob.size(), status === "final");
  }
  const method = "POST";
  const timeout = service.maxUploadRetryTime;
  const requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.headers = headers;
  requestInfo.errorHandler = sharedErrorHandler(location);
  return requestInfo;
}
var RESUMABLE_UPLOAD_CHUNK_SIZE = 256 * 1024;
function continueResumableUpload(location, service, url, blob, chunkSize, mappings, status, progressCallback) {
  const status_ = new ResumableUploadStatus(0, 0);
  if (status) {
    status_.current = status.current;
    status_.total = status.total;
  } else {
    status_.current = 0;
    status_.total = blob.size();
  }
  if (blob.size() !== status_.total) {
    throw serverFileWrongSize();
  }
  const bytesLeft = status_.total - status_.current;
  let bytesToUpload = bytesLeft;
  if (chunkSize > 0) {
    bytesToUpload = Math.min(bytesToUpload, chunkSize);
  }
  const startByte = status_.current;
  const endByte = startByte + bytesToUpload;
  const uploadCommand = bytesToUpload === bytesLeft ? "upload, finalize" : "upload";
  const headers = {
    "X-Goog-Upload-Command": uploadCommand,
    "X-Goog-Upload-Offset": `${status_.current}`
  };
  const body = blob.slice(startByte, endByte);
  if (body === null) {
    throw cannotSliceBlob();
  }
  function handler(xhr, text) {
    const uploadStatus = checkResumeHeader_(xhr, ["active", "final"]);
    const newCurrent = status_.current + bytesToUpload;
    const size = blob.size();
    let metadata;
    if (uploadStatus === "final") {
      metadata = metadataHandler(service, mappings)(xhr, text);
    } else {
      metadata = null;
    }
    return new ResumableUploadStatus(newCurrent, size, uploadStatus === "final", metadata);
  }
  const method = "POST";
  const timeout = service.maxUploadRetryTime;
  const requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.headers = headers;
  requestInfo.body = body.uploadData();
  requestInfo.progressCallback = progressCallback || null;
  requestInfo.errorHandler = sharedErrorHandler(location);
  return requestInfo;
}
var TaskEvent = {
  STATE_CHANGED: "state_changed"
};
var TaskState = {
  RUNNING: "running",
  PAUSED: "paused",
  SUCCESS: "success",
  CANCELED: "canceled",
  ERROR: "error"
};
function taskStateFromInternalTaskState(state) {
  switch (state) {
    case "running":
    case "pausing":
    case "canceling":
      return TaskState.RUNNING;
    case "paused":
      return TaskState.PAUSED;
    case "success":
      return TaskState.SUCCESS;
    case "canceled":
      return TaskState.CANCELED;
    case "error":
      return TaskState.ERROR;
    default:
      return TaskState.ERROR;
  }
}
var Observer = class {
  constructor(nextOrObserver, error, complete) {
    const asFunctions = isFunction(nextOrObserver) || error != null || complete != null;
    if (asFunctions) {
      this.next = nextOrObserver;
      this.error = error !== null && error !== void 0 ? error : void 0;
      this.complete = complete !== null && complete !== void 0 ? complete : void 0;
    } else {
      const observer = nextOrObserver;
      this.next = observer.next;
      this.error = observer.error;
      this.complete = observer.complete;
    }
  }
};
function async(f) {
  return (...argsToForward) => {
    Promise.resolve().then(() => f(...argsToForward));
  };
}
var textFactoryOverride = null;
var XhrConnection = class {
  constructor() {
    this.sent_ = false;
    this.xhr_ = new XMLHttpRequest();
    this.initXhr();
    this.errorCode_ = ErrorCode2.NO_ERROR;
    this.sendPromise_ = new Promise((resolve) => {
      this.xhr_.addEventListener("abort", () => {
        this.errorCode_ = ErrorCode2.ABORT;
        resolve();
      });
      this.xhr_.addEventListener("error", () => {
        this.errorCode_ = ErrorCode2.NETWORK_ERROR;
        resolve();
      });
      this.xhr_.addEventListener("load", () => {
        resolve();
      });
    });
  }
  send(url, method, body, headers) {
    if (this.sent_) {
      throw internalError("cannot .send() more than once");
    }
    this.sent_ = true;
    this.xhr_.open(method, url, true);
    if (headers !== void 0) {
      for (const key in headers) {
        if (headers.hasOwnProperty(key)) {
          this.xhr_.setRequestHeader(key, headers[key].toString());
        }
      }
    }
    if (body !== void 0) {
      this.xhr_.send(body);
    } else {
      this.xhr_.send();
    }
    return this.sendPromise_;
  }
  getErrorCode() {
    if (!this.sent_) {
      throw internalError("cannot .getErrorCode() before sending");
    }
    return this.errorCode_;
  }
  getStatus() {
    if (!this.sent_) {
      throw internalError("cannot .getStatus() before sending");
    }
    try {
      return this.xhr_.status;
    } catch (e) {
      return -1;
    }
  }
  getResponse() {
    if (!this.sent_) {
      throw internalError("cannot .getResponse() before sending");
    }
    return this.xhr_.response;
  }
  getErrorText() {
    if (!this.sent_) {
      throw internalError("cannot .getErrorText() before sending");
    }
    return this.xhr_.statusText;
  }
  abort() {
    this.xhr_.abort();
  }
  getResponseHeader(header) {
    return this.xhr_.getResponseHeader(header);
  }
  addUploadProgressListener(listener) {
    if (this.xhr_.upload != null) {
      this.xhr_.upload.addEventListener("progress", listener);
    }
  }
  removeUploadProgressListener(listener) {
    if (this.xhr_.upload != null) {
      this.xhr_.upload.removeEventListener("progress", listener);
    }
  }
};
var XhrTextConnection = class extends XhrConnection {
  initXhr() {
    this.xhr_.responseType = "text";
  }
};
function newTextConnection() {
  return textFactoryOverride ? textFactoryOverride() : new XhrTextConnection();
}
var UploadTask = class {
  constructor(ref3, blob, metadata = null) {
    this._transferred = 0;
    this._needToFetchStatus = false;
    this._needToFetchMetadata = false;
    this._observers = [];
    this._error = void 0;
    this._uploadUrl = void 0;
    this._request = void 0;
    this._chunkMultiplier = 1;
    this._resolve = void 0;
    this._reject = void 0;
    this._ref = ref3;
    this._blob = blob;
    this._metadata = metadata;
    this._mappings = getMappings();
    this._resumable = this._shouldDoResumable(this._blob);
    this._state = "running";
    this._errorHandler = (error) => {
      this._request = void 0;
      this._chunkMultiplier = 1;
      if (error._codeEquals("canceled")) {
        this._needToFetchStatus = true;
        this.completeTransitions_();
      } else {
        this._error = error;
        this._transition("error");
      }
    };
    this._metadataErrorHandler = (error) => {
      this._request = void 0;
      if (error._codeEquals("canceled")) {
        this.completeTransitions_();
      } else {
        this._error = error;
        this._transition("error");
      }
    };
    this._promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
      this._start();
    });
    this._promise.then(null, () => {
    });
  }
  _makeProgressCallback() {
    const sizeBefore = this._transferred;
    return (loaded) => this._updateProgress(sizeBefore + loaded);
  }
  _shouldDoResumable(blob) {
    return blob.size() > 256 * 1024;
  }
  _start() {
    if (this._state !== "running") {
      return;
    }
    if (this._request !== void 0) {
      return;
    }
    if (this._resumable) {
      if (this._uploadUrl === void 0) {
        this._createResumable();
      } else {
        if (this._needToFetchStatus) {
          this._fetchStatus();
        } else {
          if (this._needToFetchMetadata) {
            this._fetchMetadata();
          } else {
            this._continueUpload();
          }
        }
      }
    } else {
      this._oneShotUpload();
    }
  }
  _resolveToken(callback) {
    Promise.all([
      this._ref.storage._getAuthToken(),
      this._ref.storage._getAppCheckToken()
    ]).then(([authToken, appCheckToken]) => {
      switch (this._state) {
        case "running":
          callback(authToken, appCheckToken);
          break;
        case "canceling":
          this._transition("canceled");
          break;
        case "pausing":
          this._transition("paused");
          break;
      }
    });
  }
  _createResumable() {
    this._resolveToken((authToken, appCheckToken) => {
      const requestInfo = createResumableUpload(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata);
      const createRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);
      this._request = createRequest;
      createRequest.getPromise().then((url) => {
        this._request = void 0;
        this._uploadUrl = url;
        this._needToFetchStatus = false;
        this.completeTransitions_();
      }, this._errorHandler);
    });
  }
  _fetchStatus() {
    const url = this._uploadUrl;
    this._resolveToken((authToken, appCheckToken) => {
      const requestInfo = getResumableUploadStatus(this._ref.storage, this._ref._location, url, this._blob);
      const statusRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);
      this._request = statusRequest;
      statusRequest.getPromise().then((status) => {
        status = status;
        this._request = void 0;
        this._updateProgress(status.current);
        this._needToFetchStatus = false;
        if (status.finalized) {
          this._needToFetchMetadata = true;
        }
        this.completeTransitions_();
      }, this._errorHandler);
    });
  }
  _continueUpload() {
    const chunkSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;
    const status = new ResumableUploadStatus(this._transferred, this._blob.size());
    const url = this._uploadUrl;
    this._resolveToken((authToken, appCheckToken) => {
      let requestInfo;
      try {
        requestInfo = continueResumableUpload(this._ref._location, this._ref.storage, url, this._blob, chunkSize, this._mappings, status, this._makeProgressCallback());
      } catch (e) {
        this._error = e;
        this._transition("error");
        return;
      }
      const uploadRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);
      this._request = uploadRequest;
      uploadRequest.getPromise().then((newStatus) => {
        this._increaseMultiplier();
        this._request = void 0;
        this._updateProgress(newStatus.current);
        if (newStatus.finalized) {
          this._metadata = newStatus.metadata;
          this._transition("success");
        } else {
          this.completeTransitions_();
        }
      }, this._errorHandler);
    });
  }
  _increaseMultiplier() {
    const currentSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;
    if (currentSize < 32 * 1024 * 1024) {
      this._chunkMultiplier *= 2;
    }
  }
  _fetchMetadata() {
    this._resolveToken((authToken, appCheckToken) => {
      const requestInfo = getMetadata$2(this._ref.storage, this._ref._location, this._mappings);
      const metadataRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);
      this._request = metadataRequest;
      metadataRequest.getPromise().then((metadata) => {
        this._request = void 0;
        this._metadata = metadata;
        this._transition("success");
      }, this._metadataErrorHandler);
    });
  }
  _oneShotUpload() {
    this._resolveToken((authToken, appCheckToken) => {
      const requestInfo = multipartUpload(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata);
      const multipartRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);
      this._request = multipartRequest;
      multipartRequest.getPromise().then((metadata) => {
        this._request = void 0;
        this._metadata = metadata;
        this._updateProgress(this._blob.size());
        this._transition("success");
      }, this._errorHandler);
    });
  }
  _updateProgress(transferred) {
    const old = this._transferred;
    this._transferred = transferred;
    if (this._transferred !== old) {
      this._notifyObservers();
    }
  }
  _transition(state) {
    if (this._state === state) {
      return;
    }
    switch (state) {
      case "canceling":
        this._state = state;
        if (this._request !== void 0) {
          this._request.cancel();
        }
        break;
      case "pausing":
        this._state = state;
        if (this._request !== void 0) {
          this._request.cancel();
        }
        break;
      case "running":
        const wasPaused = this._state === "paused";
        this._state = state;
        if (wasPaused) {
          this._notifyObservers();
          this._start();
        }
        break;
      case "paused":
        this._state = state;
        this._notifyObservers();
        break;
      case "canceled":
        this._error = canceled();
        this._state = state;
        this._notifyObservers();
        break;
      case "error":
        this._state = state;
        this._notifyObservers();
        break;
      case "success":
        this._state = state;
        this._notifyObservers();
        break;
    }
  }
  completeTransitions_() {
    switch (this._state) {
      case "pausing":
        this._transition("paused");
        break;
      case "canceling":
        this._transition("canceled");
        break;
      case "running":
        this._start();
        break;
    }
  }
  get snapshot() {
    const externalState = taskStateFromInternalTaskState(this._state);
    return {
      bytesTransferred: this._transferred,
      totalBytes: this._blob.size(),
      state: externalState,
      metadata: this._metadata,
      task: this,
      ref: this._ref
    };
  }
  on(type, nextOrObserver, error, completed) {
    const observer = new Observer(nextOrObserver || void 0, error || void 0, completed || void 0);
    this._addObserver(observer);
    return () => {
      this._removeObserver(observer);
    };
  }
  then(onFulfilled, onRejected) {
    return this._promise.then(onFulfilled, onRejected);
  }
  catch(onRejected) {
    return this.then(null, onRejected);
  }
  _addObserver(observer) {
    this._observers.push(observer);
    this._notifyObserver(observer);
  }
  _removeObserver(observer) {
    const i = this._observers.indexOf(observer);
    if (i !== -1) {
      this._observers.splice(i, 1);
    }
  }
  _notifyObservers() {
    this._finishPromise();
    const observers = this._observers.slice();
    observers.forEach((observer) => {
      this._notifyObserver(observer);
    });
  }
  _finishPromise() {
    if (this._resolve !== void 0) {
      let triggered = true;
      switch (taskStateFromInternalTaskState(this._state)) {
        case TaskState.SUCCESS:
          async(this._resolve.bind(null, this.snapshot))();
          break;
        case TaskState.CANCELED:
        case TaskState.ERROR:
          const toCall = this._reject;
          async(toCall.bind(null, this._error))();
          break;
        default:
          triggered = false;
          break;
      }
      if (triggered) {
        this._resolve = void 0;
        this._reject = void 0;
      }
    }
  }
  _notifyObserver(observer) {
    const externalState = taskStateFromInternalTaskState(this._state);
    switch (externalState) {
      case TaskState.RUNNING:
      case TaskState.PAUSED:
        if (observer.next) {
          async(observer.next.bind(observer, this.snapshot))();
        }
        break;
      case TaskState.SUCCESS:
        if (observer.complete) {
          async(observer.complete.bind(observer))();
        }
        break;
      case TaskState.CANCELED:
      case TaskState.ERROR:
        if (observer.error) {
          async(observer.error.bind(observer, this._error))();
        }
        break;
      default:
        if (observer.error) {
          async(observer.error.bind(observer, this._error))();
        }
    }
  }
  resume() {
    const valid = this._state === "paused" || this._state === "pausing";
    if (valid) {
      this._transition("running");
    }
    return valid;
  }
  pause() {
    const valid = this._state === "running";
    if (valid) {
      this._transition("pausing");
    }
    return valid;
  }
  cancel() {
    const valid = this._state === "running" || this._state === "pausing";
    if (valid) {
      this._transition("canceling");
    }
    return valid;
  }
};
var Reference2 = class {
  constructor(_service, location) {
    this._service = _service;
    if (location instanceof Location) {
      this._location = location;
    } else {
      this._location = Location.makeFromUrl(location, _service.host);
    }
  }
  toString() {
    return "gs://" + this._location.bucket + "/" + this._location.path;
  }
  _newRef(service, location) {
    return new Reference2(service, location);
  }
  get root() {
    const location = new Location(this._location.bucket, "");
    return this._newRef(this._service, location);
  }
  get bucket() {
    return this._location.bucket;
  }
  get fullPath() {
    return this._location.path;
  }
  get name() {
    return lastComponent(this._location.path);
  }
  get storage() {
    return this._service;
  }
  get parent() {
    const newPath = parent(this._location.path);
    if (newPath === null) {
      return null;
    }
    const location = new Location(this._location.bucket, newPath);
    return new Reference2(this._service, location);
  }
  _throwIfRoot(name19) {
    if (this._location.path === "") {
      throw invalidRootOperation(name19);
    }
  }
};
function uploadBytesResumable$1(ref3, data, metadata) {
  ref3._throwIfRoot("uploadBytesResumable");
  return new UploadTask(ref3, new FbsBlob(data), metadata);
}
function listAll$1(ref3) {
  const accumulator = {
    prefixes: [],
    items: []
  };
  return listAllHelper(ref3, accumulator).then(() => accumulator);
}
async function listAllHelper(ref3, accumulator, pageToken) {
  const opt = {
    pageToken
  };
  const nextPage = await list$1(ref3, opt);
  accumulator.prefixes.push(...nextPage.prefixes);
  accumulator.items.push(...nextPage.items);
  if (nextPage.nextPageToken != null) {
    await listAllHelper(ref3, accumulator, nextPage.nextPageToken);
  }
}
function list$1(ref3, options) {
  if (options != null) {
    if (typeof options.maxResults === "number") {
      validateNumber("options.maxResults", 1, 1e3, options.maxResults);
    }
  }
  const op = options || {};
  const requestInfo = list$2(ref3.storage, ref3._location, "/", op.pageToken, op.maxResults);
  return ref3.storage.makeRequestWithTokens(requestInfo, newTextConnection);
}
function getMetadata$1(ref3) {
  ref3._throwIfRoot("getMetadata");
  const requestInfo = getMetadata$2(ref3.storage, ref3._location, getMappings());
  return ref3.storage.makeRequestWithTokens(requestInfo, newTextConnection);
}
function updateMetadata$1(ref3, metadata) {
  ref3._throwIfRoot("updateMetadata");
  const requestInfo = updateMetadata$2(ref3.storage, ref3._location, metadata, getMappings());
  return ref3.storage.makeRequestWithTokens(requestInfo, newTextConnection);
}
function getDownloadURL$1(ref3) {
  ref3._throwIfRoot("getDownloadURL");
  const requestInfo = getDownloadUrl(ref3.storage, ref3._location, getMappings());
  return ref3.storage.makeRequestWithTokens(requestInfo, newTextConnection).then((url) => {
    if (url === null) {
      throw noDownloadURL();
    }
    return url;
  });
}
function deleteObject$1(ref3) {
  ref3._throwIfRoot("deleteObject");
  const requestInfo = deleteObject$2(ref3.storage, ref3._location);
  return ref3.storage.makeRequestWithTokens(requestInfo, newTextConnection);
}
function _getChild$1(ref3, childPath) {
  const newPath = child2(ref3._location.path, childPath);
  const location = new Location(ref3._location.bucket, newPath);
  return new Reference2(ref3.storage, location);
}
function isUrl(path) {
  return /^[A-Za-z]+:\/\//.test(path);
}
function refFromURL2(service, url) {
  return new Reference2(service, url);
}
function refFromPath(ref3, path) {
  if (ref3 instanceof FirebaseStorageImpl) {
    const service = ref3;
    if (service._bucket == null) {
      throw noDefaultBucket();
    }
    const reference = new Reference2(service, service._bucket);
    if (path != null) {
      return refFromPath(reference, path);
    } else {
      return reference;
    }
  } else {
    if (path !== void 0) {
      return _getChild$1(ref3, path);
    } else {
      return ref3;
    }
  }
}
function ref$1(serviceOrRef, pathOrUrl) {
  if (pathOrUrl && isUrl(pathOrUrl)) {
    if (serviceOrRef instanceof FirebaseStorageImpl) {
      return refFromURL2(serviceOrRef, pathOrUrl);
    } else {
      throw invalidArgument("To use ref(service, url), the first argument must be a Storage instance.");
    }
  } else {
    return refFromPath(serviceOrRef, pathOrUrl);
  }
}
function extractBucket(host, config) {
  const bucketString = config === null || config === void 0 ? void 0 : config[CONFIG_STORAGE_BUCKET_KEY];
  if (bucketString == null) {
    return null;
  }
  return Location.makeFromBucketSpec(bucketString, host);
}
function connectStorageEmulator$1(storage2, host, port, options = {}) {
  storage2.host = `${host}:${port}`;
  storage2._protocol = "http";
  const { mockUserToken } = options;
  if (mockUserToken) {
    storage2._overrideAuthToken = typeof mockUserToken === "string" ? mockUserToken : createMockUserToken(mockUserToken, storage2.app.options.projectId);
  }
}
var FirebaseStorageImpl = class {
  constructor(app, _authProvider, _appCheckProvider, _url, _firebaseVersion) {
    this.app = app;
    this._authProvider = _authProvider;
    this._appCheckProvider = _appCheckProvider;
    this._url = _url;
    this._firebaseVersion = _firebaseVersion;
    this._bucket = null;
    this._host = DEFAULT_HOST;
    this._protocol = "https";
    this._appId = null;
    this._deleted = false;
    this._maxOperationRetryTime = DEFAULT_MAX_OPERATION_RETRY_TIME;
    this._maxUploadRetryTime = DEFAULT_MAX_UPLOAD_RETRY_TIME;
    this._requests = /* @__PURE__ */ new Set();
    if (_url != null) {
      this._bucket = Location.makeFromBucketSpec(_url, this._host);
    } else {
      this._bucket = extractBucket(this._host, this.app.options);
    }
  }
  get host() {
    return this._host;
  }
  set host(host) {
    this._host = host;
    if (this._url != null) {
      this._bucket = Location.makeFromBucketSpec(this._url, host);
    } else {
      this._bucket = extractBucket(host, this.app.options);
    }
  }
  get maxUploadRetryTime() {
    return this._maxUploadRetryTime;
  }
  set maxUploadRetryTime(time) {
    validateNumber("time", 0, Number.POSITIVE_INFINITY, time);
    this._maxUploadRetryTime = time;
  }
  get maxOperationRetryTime() {
    return this._maxOperationRetryTime;
  }
  set maxOperationRetryTime(time) {
    validateNumber("time", 0, Number.POSITIVE_INFINITY, time);
    this._maxOperationRetryTime = time;
  }
  async _getAuthToken() {
    if (this._overrideAuthToken) {
      return this._overrideAuthToken;
    }
    const auth = this._authProvider.getImmediate({ optional: true });
    if (auth) {
      const tokenData = await auth.getToken();
      if (tokenData !== null) {
        return tokenData.accessToken;
      }
    }
    return null;
  }
  async _getAppCheckToken() {
    const appCheck = this._appCheckProvider.getImmediate({ optional: true });
    if (appCheck) {
      const result = await appCheck.getToken();
      return result.token;
    }
    return null;
  }
  _delete() {
    if (!this._deleted) {
      this._deleted = true;
      this._requests.forEach((request) => request.cancel());
      this._requests.clear();
    }
    return Promise.resolve();
  }
  _makeStorageReference(loc) {
    return new Reference2(this, loc);
  }
  _makeRequest(requestInfo, requestFactory, authToken, appCheckToken) {
    if (!this._deleted) {
      const request = makeRequest(requestInfo, this._appId, authToken, appCheckToken, requestFactory, this._firebaseVersion);
      this._requests.add(request);
      request.getPromise().then(() => this._requests.delete(request), () => this._requests.delete(request));
      return request;
    } else {
      return new FailRequest(appDeleted());
    }
  }
  async makeRequestWithTokens(requestInfo, requestFactory) {
    const [authToken, appCheckToken] = await Promise.all([
      this._getAuthToken(),
      this._getAppCheckToken()
    ]);
    return this._makeRequest(requestInfo, requestFactory, authToken, appCheckToken).getPromise();
  }
};
var name12 = "@firebase/storage";
var version12 = "0.9.7";
var STORAGE_TYPE = "storage";
function uploadBytesResumable(ref3, data, metadata) {
  ref3 = getModularInstance(ref3);
  return uploadBytesResumable$1(ref3, data, metadata);
}
function getMetadata(ref3) {
  ref3 = getModularInstance(ref3);
  return getMetadata$1(ref3);
}
function updateMetadata(ref3, metadata) {
  ref3 = getModularInstance(ref3);
  return updateMetadata$1(ref3, metadata);
}
function list(ref3, options) {
  ref3 = getModularInstance(ref3);
  return list$1(ref3, options);
}
function listAll(ref3) {
  ref3 = getModularInstance(ref3);
  return listAll$1(ref3);
}
function getDownloadURL(ref3) {
  ref3 = getModularInstance(ref3);
  return getDownloadURL$1(ref3);
}
function deleteObject(ref3) {
  ref3 = getModularInstance(ref3);
  return deleteObject$1(ref3);
}
function ref2(serviceOrRef, pathOrUrl) {
  serviceOrRef = getModularInstance(serviceOrRef);
  return ref$1(serviceOrRef, pathOrUrl);
}
function _getChild(ref3, childPath) {
  return _getChild$1(ref3, childPath);
}
function connectStorageEmulator(storage2, host, port, options = {}) {
  connectStorageEmulator$1(storage2, host, port, options);
}
function factory5(container, { instanceIdentifier: url }) {
  const app = container.getProvider("app").getImmediate();
  const authProvider = container.getProvider("auth-internal");
  const appCheckProvider = container.getProvider("app-check-internal");
  return new FirebaseStorageImpl(app, authProvider, appCheckProvider, url, SDK_VERSION);
}
function registerStorage() {
  _registerComponent(new Component(STORAGE_TYPE, factory5, "PUBLIC").setMultipleInstances(true));
  registerVersion(name12, version12, "");
  registerVersion(name12, version12, "esm2017");
}
registerStorage();

// node_modules/@firebase/storage-compat/dist/esm/index.esm2017.js
var UploadTaskSnapshotCompat = class {
  constructor(_delegate, task, ref3) {
    this._delegate = _delegate;
    this.task = task;
    this.ref = ref3;
  }
  get bytesTransferred() {
    return this._delegate.bytesTransferred;
  }
  get metadata() {
    return this._delegate.metadata;
  }
  get state() {
    return this._delegate.state;
  }
  get totalBytes() {
    return this._delegate.totalBytes;
  }
};
var UploadTaskCompat = class {
  constructor(_delegate, _ref) {
    this._delegate = _delegate;
    this._ref = _ref;
    this.cancel = this._delegate.cancel.bind(this._delegate);
    this.catch = this._delegate.catch.bind(this._delegate);
    this.pause = this._delegate.pause.bind(this._delegate);
    this.resume = this._delegate.resume.bind(this._delegate);
  }
  get snapshot() {
    return new UploadTaskSnapshotCompat(this._delegate.snapshot, this, this._ref);
  }
  then(onFulfilled, onRejected) {
    return this._delegate.then((snapshot) => {
      if (onFulfilled) {
        return onFulfilled(new UploadTaskSnapshotCompat(snapshot, this, this._ref));
      }
    }, onRejected);
  }
  on(type, nextOrObserver, error, completed) {
    let wrappedNextOrObserver = void 0;
    if (!!nextOrObserver) {
      if (typeof nextOrObserver === "function") {
        wrappedNextOrObserver = (taskSnapshot) => nextOrObserver(new UploadTaskSnapshotCompat(taskSnapshot, this, this._ref));
      } else {
        wrappedNextOrObserver = {
          next: !!nextOrObserver.next ? (taskSnapshot) => nextOrObserver.next(new UploadTaskSnapshotCompat(taskSnapshot, this, this._ref)) : void 0,
          complete: nextOrObserver.complete || void 0,
          error: nextOrObserver.error || void 0
        };
      }
    }
    return this._delegate.on(type, wrappedNextOrObserver, error || void 0, completed || void 0);
  }
};
var ListResultCompat = class {
  constructor(_delegate, _service) {
    this._delegate = _delegate;
    this._service = _service;
  }
  get prefixes() {
    return this._delegate.prefixes.map((ref3) => new ReferenceCompat(ref3, this._service));
  }
  get items() {
    return this._delegate.items.map((ref3) => new ReferenceCompat(ref3, this._service));
  }
  get nextPageToken() {
    return this._delegate.nextPageToken || null;
  }
};
var ReferenceCompat = class {
  constructor(_delegate, storage2) {
    this._delegate = _delegate;
    this.storage = storage2;
  }
  get name() {
    return this._delegate.name;
  }
  get bucket() {
    return this._delegate.bucket;
  }
  get fullPath() {
    return this._delegate.fullPath;
  }
  toString() {
    return this._delegate.toString();
  }
  child(childPath) {
    const reference = _getChild(this._delegate, childPath);
    return new ReferenceCompat(reference, this.storage);
  }
  get root() {
    return new ReferenceCompat(this._delegate.root, this.storage);
  }
  get parent() {
    const reference = this._delegate.parent;
    if (reference == null) {
      return null;
    }
    return new ReferenceCompat(reference, this.storage);
  }
  put(data, metadata) {
    this._throwIfRoot("put");
    return new UploadTaskCompat(uploadBytesResumable(this._delegate, data, metadata), this);
  }
  putString(value, format = StringFormat.RAW, metadata) {
    this._throwIfRoot("putString");
    const data = dataFromString(format, value);
    const metadataClone = Object.assign({}, metadata);
    if (metadataClone["contentType"] == null && data.contentType != null) {
      metadataClone["contentType"] = data.contentType;
    }
    return new UploadTaskCompat(new UploadTask(this._delegate, new FbsBlob(data.data, true), metadataClone), this);
  }
  listAll() {
    return listAll(this._delegate).then((r) => new ListResultCompat(r, this.storage));
  }
  list(options) {
    return list(this._delegate, options || void 0).then((r) => new ListResultCompat(r, this.storage));
  }
  getMetadata() {
    return getMetadata(this._delegate);
  }
  updateMetadata(metadata) {
    return updateMetadata(this._delegate, metadata);
  }
  getDownloadURL() {
    return getDownloadURL(this._delegate);
  }
  delete() {
    this._throwIfRoot("delete");
    return deleteObject(this._delegate);
  }
  _throwIfRoot(name19) {
    if (this._delegate._location.path === "") {
      throw invalidRootOperation(name19);
    }
  }
};
var StorageServiceCompat = class {
  constructor(app, _delegate) {
    this.app = app;
    this._delegate = _delegate;
  }
  get maxOperationRetryTime() {
    return this._delegate.maxOperationRetryTime;
  }
  get maxUploadRetryTime() {
    return this._delegate.maxUploadRetryTime;
  }
  ref(path) {
    if (isUrl2(path)) {
      throw invalidArgument("ref() expected a child path but got a URL, use refFromURL instead.");
    }
    return new ReferenceCompat(ref2(this._delegate, path), this);
  }
  refFromURL(url) {
    if (!isUrl2(url)) {
      throw invalidArgument("refFromURL() expected a full URL but got a child path, use ref() instead.");
    }
    try {
      Location.makeFromUrl(url, this._delegate.host);
    } catch (e) {
      throw invalidArgument("refFromUrl() expected a valid full URL but got an invalid one.");
    }
    return new ReferenceCompat(ref2(this._delegate, url), this);
  }
  setMaxUploadRetryTime(time) {
    this._delegate.maxUploadRetryTime = time;
  }
  setMaxOperationRetryTime(time) {
    this._delegate.maxOperationRetryTime = time;
  }
  useEmulator(host, port, options = {}) {
    connectStorageEmulator(this._delegate, host, port, options);
  }
};
function isUrl2(path) {
  return /^[A-Za-z]+:\/\//.test(path);
}
var name13 = "@firebase/storage-compat";
var version13 = "0.1.15";
var STORAGE_TYPE2 = "storage-compat";
function factory6(container, { instanceIdentifier: url }) {
  const app = container.getProvider("app-compat").getImmediate();
  const storageExp = container.getProvider("storage").getImmediate({ identifier: url });
  const storageServiceCompat = new StorageServiceCompat(app, storageExp);
  return storageServiceCompat;
}
function registerStorage2(instance) {
  const namespaceExports = {
    TaskState,
    TaskEvent,
    StringFormat,
    Storage: StorageServiceCompat,
    Reference: ReferenceCompat
  };
  instance.INTERNAL.registerComponent(new Component(STORAGE_TYPE2, factory6, "PUBLIC").setServiceProps(namespaceExports).setMultipleInstances(true));
  instance.registerVersion(name13, version13);
}
registerStorage2(firebase);

// node_modules/@firebase/performance/dist/esm/index.esm2017.js
var name14 = "@firebase/performance";
var version14 = "0.5.10";
var SDK_VERSION2 = version14;
var TRACE_START_MARK_PREFIX = "FB-PERF-TRACE-START";
var TRACE_STOP_MARK_PREFIX = "FB-PERF-TRACE-STOP";
var TRACE_MEASURE_PREFIX = "FB-PERF-TRACE-MEASURE";
var OOB_TRACE_PAGE_LOAD_PREFIX = "_wt_";
var FIRST_PAINT_COUNTER_NAME = "_fp";
var FIRST_CONTENTFUL_PAINT_COUNTER_NAME = "_fcp";
var FIRST_INPUT_DELAY_COUNTER_NAME = "_fid";
var CONFIG_LOCAL_STORAGE_KEY = "@firebase/performance/config";
var CONFIG_EXPIRY_LOCAL_STORAGE_KEY = "@firebase/performance/configexpire";
var SERVICE = "performance";
var SERVICE_NAME = "Performance";
var ERROR_DESCRIPTION_MAP = {
  ["trace started"]: "Trace {$traceName} was started before.",
  ["trace stopped"]: "Trace {$traceName} is not running.",
  ["nonpositive trace startTime"]: "Trace {$traceName} startTime should be positive.",
  ["nonpositive trace duration"]: "Trace {$traceName} duration should be positive.",
  ["no window"]: "Window is not available.",
  ["no app id"]: "App id is not available.",
  ["no project id"]: "Project id is not available.",
  ["no api key"]: "Api key is not available.",
  ["invalid cc log"]: "Attempted to queue invalid cc event",
  ["FB not default"]: "Performance can only start when Firebase app instance is the default one.",
  ["RC response not ok"]: "RC response is not ok",
  ["invalid attribute name"]: "Attribute name {$attributeName} is invalid.",
  ["invalid attribute value"]: "Attribute value {$attributeValue} is invalid.",
  ["invalid custom metric name"]: "Custom metric name {$customMetricName} is invalid",
  ["invalid String merger input"]: "Input for String merger is invalid, contact support team to resolve.",
  ["already initialized"]: "initializePerformance() has already been called with different options. To avoid this error, call initializePerformance() with the same options as when it was originally called, or call getPerformance() to return the already initialized instance."
};
var ERROR_FACTORY6 = new ErrorFactory(SERVICE, SERVICE_NAME, ERROR_DESCRIPTION_MAP);
var consoleLogger = new Logger(SERVICE_NAME);
consoleLogger.logLevel = LogLevel.INFO;
var apiInstance;
var windowInstance;
var Api = class {
  constructor(window2) {
    this.window = window2;
    if (!window2) {
      throw ERROR_FACTORY6.create("no window");
    }
    this.performance = window2.performance;
    this.PerformanceObserver = window2.PerformanceObserver;
    this.windowLocation = window2.location;
    this.navigator = window2.navigator;
    this.document = window2.document;
    if (this.navigator && this.navigator.cookieEnabled) {
      this.localStorage = window2.localStorage;
    }
    if (window2.perfMetrics && window2.perfMetrics.onFirstInputDelay) {
      this.onFirstInputDelay = window2.perfMetrics.onFirstInputDelay;
    }
  }
  getUrl() {
    return this.windowLocation.href.split("?")[0];
  }
  mark(name19) {
    if (!this.performance || !this.performance.mark) {
      return;
    }
    this.performance.mark(name19);
  }
  measure(measureName, mark1, mark2) {
    if (!this.performance || !this.performance.measure) {
      return;
    }
    this.performance.measure(measureName, mark1, mark2);
  }
  getEntriesByType(type) {
    if (!this.performance || !this.performance.getEntriesByType) {
      return [];
    }
    return this.performance.getEntriesByType(type);
  }
  getEntriesByName(name19) {
    if (!this.performance || !this.performance.getEntriesByName) {
      return [];
    }
    return this.performance.getEntriesByName(name19);
  }
  getTimeOrigin() {
    return this.performance && (this.performance.timeOrigin || this.performance.timing.navigationStart);
  }
  requiredApisAvailable() {
    if (!fetch || !Promise || !areCookiesEnabled()) {
      consoleLogger.info("Firebase Performance cannot start if browser does not support fetch and Promise or cookie is disabled.");
      return false;
    }
    if (!isIndexedDBAvailable()) {
      consoleLogger.info("IndexedDB is not supported by current browswer");
      return false;
    }
    return true;
  }
  setupObserver(entryType, callback) {
    if (!this.PerformanceObserver) {
      return;
    }
    const observer = new this.PerformanceObserver((list2) => {
      for (const entry of list2.getEntries()) {
        callback(entry);
      }
    });
    observer.observe({ entryTypes: [entryType] });
  }
  static getInstance() {
    if (apiInstance === void 0) {
      apiInstance = new Api(windowInstance);
    }
    return apiInstance;
  }
};
function setupApi(window2) {
  windowInstance = window2;
}
var iid;
function getIidPromise(installationsService) {
  const iidPromise = installationsService.getId();
  iidPromise.then((iidVal) => {
    iid = iidVal;
  });
  return iidPromise;
}
function getIid() {
  return iid;
}
function getAuthTokenPromise(installationsService) {
  const authTokenPromise = installationsService.getToken();
  authTokenPromise.then((authTokenVal) => {
  });
  return authTokenPromise;
}
function mergeStrings(part1, part2) {
  const sizeDiff = part1.length - part2.length;
  if (sizeDiff < 0 || sizeDiff > 1) {
    throw ERROR_FACTORY6.create("invalid String merger input");
  }
  const resultArray = [];
  for (let i = 0; i < part1.length; i++) {
    resultArray.push(part1.charAt(i));
    if (part2.length > i) {
      resultArray.push(part2.charAt(i));
    }
  }
  return resultArray.join("");
}
var settingsServiceInstance;
var SettingsService = class {
  constructor() {
    this.instrumentationEnabled = true;
    this.dataCollectionEnabled = true;
    this.loggingEnabled = false;
    this.tracesSamplingRate = 1;
    this.networkRequestsSamplingRate = 1;
    this.logEndPointUrl = "https://firebaselogging.googleapis.com/v0cc/log?format=json_proto";
    this.flTransportEndpointUrl = mergeStrings("hts/frbslgigp.ogepscmv/ieo/eaylg", "tp:/ieaeogn-agolai.o/1frlglgc/o");
    this.transportKey = mergeStrings("AzSC8r6ReiGqFMyfvgow", "Iayx0u-XT3vksVM-pIV");
    this.logSource = 462;
    this.logTraceAfterSampling = false;
    this.logNetworkAfterSampling = false;
    this.configTimeToLive = 12;
  }
  getFlTransportFullUrl() {
    return this.flTransportEndpointUrl.concat("?key=", this.transportKey);
  }
  static getInstance() {
    if (settingsServiceInstance === void 0) {
      settingsServiceInstance = new SettingsService();
    }
    return settingsServiceInstance;
  }
};
var VisibilityState;
(function(VisibilityState2) {
  VisibilityState2[VisibilityState2["UNKNOWN"] = 0] = "UNKNOWN";
  VisibilityState2[VisibilityState2["VISIBLE"] = 1] = "VISIBLE";
  VisibilityState2[VisibilityState2["HIDDEN"] = 2] = "HIDDEN";
})(VisibilityState || (VisibilityState = {}));
var RESERVED_ATTRIBUTE_PREFIXES = ["firebase_", "google_", "ga_"];
var ATTRIBUTE_FORMAT_REGEX = new RegExp("^[a-zA-Z]\\w*$");
var MAX_ATTRIBUTE_NAME_LENGTH = 40;
var MAX_ATTRIBUTE_VALUE_LENGTH = 100;
function getServiceWorkerStatus() {
  const navigator2 = Api.getInstance().navigator;
  if ("serviceWorker" in navigator2) {
    if (navigator2.serviceWorker.controller) {
      return 2;
    } else {
      return 3;
    }
  } else {
    return 1;
  }
}
function getVisibilityState() {
  const document2 = Api.getInstance().document;
  const visibilityState = document2.visibilityState;
  switch (visibilityState) {
    case "visible":
      return VisibilityState.VISIBLE;
    case "hidden":
      return VisibilityState.HIDDEN;
    default:
      return VisibilityState.UNKNOWN;
  }
}
function getEffectiveConnectionType() {
  const navigator2 = Api.getInstance().navigator;
  const navigatorConnection = navigator2.connection;
  const effectiveType = navigatorConnection && navigatorConnection.effectiveType;
  switch (effectiveType) {
    case "slow-2g":
      return 1;
    case "2g":
      return 2;
    case "3g":
      return 3;
    case "4g":
      return 4;
    default:
      return 0;
  }
}
function isValidCustomAttributeName(name19) {
  if (name19.length === 0 || name19.length > MAX_ATTRIBUTE_NAME_LENGTH) {
    return false;
  }
  const matchesReservedPrefix = RESERVED_ATTRIBUTE_PREFIXES.some((prefix) => name19.startsWith(prefix));
  return !matchesReservedPrefix && !!name19.match(ATTRIBUTE_FORMAT_REGEX);
}
function isValidCustomAttributeValue(value) {
  return value.length !== 0 && value.length <= MAX_ATTRIBUTE_VALUE_LENGTH;
}
function getAppId(firebaseApp) {
  var _a2;
  const appId = (_a2 = firebaseApp.options) === null || _a2 === void 0 ? void 0 : _a2.appId;
  if (!appId) {
    throw ERROR_FACTORY6.create("no app id");
  }
  return appId;
}
function getProjectId(firebaseApp) {
  var _a2;
  const projectId = (_a2 = firebaseApp.options) === null || _a2 === void 0 ? void 0 : _a2.projectId;
  if (!projectId) {
    throw ERROR_FACTORY6.create("no project id");
  }
  return projectId;
}
function getApiKey(firebaseApp) {
  var _a2;
  const apiKey = (_a2 = firebaseApp.options) === null || _a2 === void 0 ? void 0 : _a2.apiKey;
  if (!apiKey) {
    throw ERROR_FACTORY6.create("no api key");
  }
  return apiKey;
}
var REMOTE_CONFIG_SDK_VERSION = "0.0.1";
var DEFAULT_CONFIGS = {
  loggingEnabled: true
};
var FIS_AUTH_PREFIX = "FIREBASE_INSTALLATIONS_AUTH";
function getConfig(performanceController, iid2) {
  const config = getStoredConfig();
  if (config) {
    processConfig(config);
    return Promise.resolve();
  }
  return getRemoteConfig(performanceController, iid2).then(processConfig).then((config2) => storeConfig(config2), () => {
  });
}
function getStoredConfig() {
  const localStorage = Api.getInstance().localStorage;
  if (!localStorage) {
    return;
  }
  const expiryString = localStorage.getItem(CONFIG_EXPIRY_LOCAL_STORAGE_KEY);
  if (!expiryString || !configValid(expiryString)) {
    return;
  }
  const configStringified = localStorage.getItem(CONFIG_LOCAL_STORAGE_KEY);
  if (!configStringified) {
    return;
  }
  try {
    const configResponse = JSON.parse(configStringified);
    return configResponse;
  } catch (_a2) {
    return;
  }
}
function storeConfig(config) {
  const localStorage = Api.getInstance().localStorage;
  if (!config || !localStorage) {
    return;
  }
  localStorage.setItem(CONFIG_LOCAL_STORAGE_KEY, JSON.stringify(config));
  localStorage.setItem(CONFIG_EXPIRY_LOCAL_STORAGE_KEY, String(Date.now() + SettingsService.getInstance().configTimeToLive * 60 * 60 * 1e3));
}
var COULD_NOT_GET_CONFIG_MSG = "Could not fetch config, will use default configs";
function getRemoteConfig(performanceController, iid2) {
  return getAuthTokenPromise(performanceController.installations).then((authToken) => {
    const projectId = getProjectId(performanceController.app);
    const apiKey = getApiKey(performanceController.app);
    const configEndPoint = `https://firebaseremoteconfig.googleapis.com/v1/projects/${projectId}/namespaces/fireperf:fetch?key=${apiKey}`;
    const request = new Request(configEndPoint, {
      method: "POST",
      headers: { Authorization: `${FIS_AUTH_PREFIX} ${authToken}` },
      body: JSON.stringify({
        app_instance_id: iid2,
        app_instance_id_token: authToken,
        app_id: getAppId(performanceController.app),
        app_version: SDK_VERSION2,
        sdk_version: REMOTE_CONFIG_SDK_VERSION
      })
    });
    return fetch(request).then((response) => {
      if (response.ok) {
        return response.json();
      }
      throw ERROR_FACTORY6.create("RC response not ok");
    });
  }).catch(() => {
    consoleLogger.info(COULD_NOT_GET_CONFIG_MSG);
    return void 0;
  });
}
function processConfig(config) {
  if (!config) {
    return config;
  }
  const settingsServiceInstance2 = SettingsService.getInstance();
  const entries = config.entries || {};
  if (entries.fpr_enabled !== void 0) {
    settingsServiceInstance2.loggingEnabled = String(entries.fpr_enabled) === "true";
  } else {
    settingsServiceInstance2.loggingEnabled = DEFAULT_CONFIGS.loggingEnabled;
  }
  if (entries.fpr_log_source) {
    settingsServiceInstance2.logSource = Number(entries.fpr_log_source);
  } else if (DEFAULT_CONFIGS.logSource) {
    settingsServiceInstance2.logSource = DEFAULT_CONFIGS.logSource;
  }
  if (entries.fpr_log_endpoint_url) {
    settingsServiceInstance2.logEndPointUrl = entries.fpr_log_endpoint_url;
  } else if (DEFAULT_CONFIGS.logEndPointUrl) {
    settingsServiceInstance2.logEndPointUrl = DEFAULT_CONFIGS.logEndPointUrl;
  }
  if (entries.fpr_log_transport_key) {
    settingsServiceInstance2.transportKey = entries.fpr_log_transport_key;
  } else if (DEFAULT_CONFIGS.transportKey) {
    settingsServiceInstance2.transportKey = DEFAULT_CONFIGS.transportKey;
  }
  if (entries.fpr_vc_network_request_sampling_rate !== void 0) {
    settingsServiceInstance2.networkRequestsSamplingRate = Number(entries.fpr_vc_network_request_sampling_rate);
  } else if (DEFAULT_CONFIGS.networkRequestsSamplingRate !== void 0) {
    settingsServiceInstance2.networkRequestsSamplingRate = DEFAULT_CONFIGS.networkRequestsSamplingRate;
  }
  if (entries.fpr_vc_trace_sampling_rate !== void 0) {
    settingsServiceInstance2.tracesSamplingRate = Number(entries.fpr_vc_trace_sampling_rate);
  } else if (DEFAULT_CONFIGS.tracesSamplingRate !== void 0) {
    settingsServiceInstance2.tracesSamplingRate = DEFAULT_CONFIGS.tracesSamplingRate;
  }
  settingsServiceInstance2.logTraceAfterSampling = shouldLogAfterSampling(settingsServiceInstance2.tracesSamplingRate);
  settingsServiceInstance2.logNetworkAfterSampling = shouldLogAfterSampling(settingsServiceInstance2.networkRequestsSamplingRate);
  return config;
}
function configValid(expiry) {
  return Number(expiry) > Date.now();
}
function shouldLogAfterSampling(samplingRate) {
  return Math.random() <= samplingRate;
}
var initializationStatus = 1;
var initializationPromise;
function getInitializationPromise(performanceController) {
  initializationStatus = 2;
  initializationPromise = initializationPromise || initializePerf(performanceController);
  return initializationPromise;
}
function isPerfInitialized() {
  return initializationStatus === 3;
}
function initializePerf(performanceController) {
  return getDocumentReadyComplete().then(() => getIidPromise(performanceController.installations)).then((iid2) => getConfig(performanceController, iid2)).then(() => changeInitializationStatus(), () => changeInitializationStatus());
}
function getDocumentReadyComplete() {
  const document2 = Api.getInstance().document;
  return new Promise((resolve) => {
    if (document2 && document2.readyState !== "complete") {
      const handler = () => {
        if (document2.readyState === "complete") {
          document2.removeEventListener("readystatechange", handler);
          resolve();
        }
      };
      document2.addEventListener("readystatechange", handler);
    } else {
      resolve();
    }
  });
}
function changeInitializationStatus() {
  initializationStatus = 3;
}
var DEFAULT_SEND_INTERVAL_MS = 10 * 1e3;
var INITIAL_SEND_TIME_DELAY_MS = 5.5 * 1e3;
var DEFAULT_REMAINING_TRIES = 3;
var MAX_EVENT_COUNT_PER_REQUEST = 1e3;
var remainingTries = DEFAULT_REMAINING_TRIES;
var queue = [];
var isTransportSetup = false;
function setupTransportService() {
  if (!isTransportSetup) {
    processQueue(INITIAL_SEND_TIME_DELAY_MS);
    isTransportSetup = true;
  }
}
function processQueue(timeOffset) {
  setTimeout(() => {
    if (remainingTries === 0) {
      return;
    }
    if (!queue.length) {
      return processQueue(DEFAULT_SEND_INTERVAL_MS);
    }
    dispatchQueueEvents();
  }, timeOffset);
}
function dispatchQueueEvents() {
  const staged = queue.splice(0, MAX_EVENT_COUNT_PER_REQUEST);
  const log_event = staged.map((evt) => ({
    source_extension_json_proto3: evt.message,
    event_time_ms: String(evt.eventTime)
  }));
  const data = {
    request_time_ms: String(Date.now()),
    client_info: {
      client_type: 1,
      js_client_info: {}
    },
    log_source: SettingsService.getInstance().logSource,
    log_event
  };
  sendEventsToFl(data, staged).catch(() => {
    queue = [...staged, ...queue];
    remainingTries--;
    consoleLogger.info(`Tries left: ${remainingTries}.`);
    processQueue(DEFAULT_SEND_INTERVAL_MS);
  });
}
function sendEventsToFl(data, staged) {
  return postToFlEndpoint(data).then((res) => {
    if (!res.ok) {
      consoleLogger.info("Call to Firebase backend failed.");
    }
    return res.json();
  }).then((res) => {
    const transportWait = Number(res.nextRequestWaitMillis);
    let requestOffset = DEFAULT_SEND_INTERVAL_MS;
    if (!isNaN(transportWait)) {
      requestOffset = Math.max(transportWait, requestOffset);
    }
    const logResponseDetails = res.logResponseDetails;
    if (Array.isArray(logResponseDetails) && logResponseDetails.length > 0 && logResponseDetails[0].responseAction === "RETRY_REQUEST_LATER") {
      queue = [...staged, ...queue];
      consoleLogger.info(`Retry transport request later.`);
    }
    remainingTries = DEFAULT_REMAINING_TRIES;
    processQueue(requestOffset);
  });
}
function postToFlEndpoint(data) {
  const flTransportFullUrl = SettingsService.getInstance().getFlTransportFullUrl();
  return fetch(flTransportFullUrl, {
    method: "POST",
    body: JSON.stringify(data)
  });
}
function addToQueue(evt) {
  if (!evt.eventTime || !evt.message) {
    throw ERROR_FACTORY6.create("invalid cc log");
  }
  queue = [...queue, evt];
}
function transportHandler(serializer2) {
  return (...args) => {
    const message = serializer2(...args);
    addToQueue({
      message,
      eventTime: Date.now()
    });
  };
}
var logger3;
function sendLog(resource, resourceType) {
  if (!logger3) {
    logger3 = transportHandler(serializer);
  }
  logger3(resource, resourceType);
}
function logTrace(trace2) {
  const settingsService = SettingsService.getInstance();
  if (!settingsService.instrumentationEnabled && trace2.isAuto) {
    return;
  }
  if (!settingsService.dataCollectionEnabled && !trace2.isAuto) {
    return;
  }
  if (!Api.getInstance().requiredApisAvailable()) {
    return;
  }
  if (trace2.isAuto && getVisibilityState() !== VisibilityState.VISIBLE) {
    return;
  }
  if (isPerfInitialized()) {
    sendTraceLog(trace2);
  } else {
    getInitializationPromise(trace2.performanceController).then(() => sendTraceLog(trace2), () => sendTraceLog(trace2));
  }
}
function sendTraceLog(trace2) {
  if (!getIid()) {
    return;
  }
  const settingsService = SettingsService.getInstance();
  if (!settingsService.loggingEnabled || !settingsService.logTraceAfterSampling) {
    return;
  }
  setTimeout(() => sendLog(trace2, 1), 0);
}
function logNetworkRequest(networkRequest) {
  const settingsService = SettingsService.getInstance();
  if (!settingsService.instrumentationEnabled) {
    return;
  }
  const networkRequestUrl = networkRequest.url;
  const logEndpointUrl = settingsService.logEndPointUrl.split("?")[0];
  const flEndpointUrl = settingsService.flTransportEndpointUrl.split("?")[0];
  if (networkRequestUrl === logEndpointUrl || networkRequestUrl === flEndpointUrl) {
    return;
  }
  if (!settingsService.loggingEnabled || !settingsService.logNetworkAfterSampling) {
    return;
  }
  setTimeout(() => sendLog(networkRequest, 0), 0);
}
function serializer(resource, resourceType) {
  if (resourceType === 0) {
    return serializeNetworkRequest(resource);
  }
  return serializeTrace(resource);
}
function serializeNetworkRequest(networkRequest) {
  const networkRequestMetric = {
    url: networkRequest.url,
    http_method: networkRequest.httpMethod || 0,
    http_response_code: 200,
    response_payload_bytes: networkRequest.responsePayloadBytes,
    client_start_time_us: networkRequest.startTimeUs,
    time_to_response_initiated_us: networkRequest.timeToResponseInitiatedUs,
    time_to_response_completed_us: networkRequest.timeToResponseCompletedUs
  };
  const perfMetric = {
    application_info: getApplicationInfo(networkRequest.performanceController.app),
    network_request_metric: networkRequestMetric
  };
  return JSON.stringify(perfMetric);
}
function serializeTrace(trace2) {
  const traceMetric = {
    name: trace2.name,
    is_auto: trace2.isAuto,
    client_start_time_us: trace2.startTimeUs,
    duration_us: trace2.durationUs
  };
  if (Object.keys(trace2.counters).length !== 0) {
    traceMetric.counters = trace2.counters;
  }
  const customAttributes = trace2.getAttributes();
  if (Object.keys(customAttributes).length !== 0) {
    traceMetric.custom_attributes = customAttributes;
  }
  const perfMetric = {
    application_info: getApplicationInfo(trace2.performanceController.app),
    trace_metric: traceMetric
  };
  return JSON.stringify(perfMetric);
}
function getApplicationInfo(firebaseApp) {
  return {
    google_app_id: getAppId(firebaseApp),
    app_instance_id: getIid(),
    web_app_info: {
      sdk_version: SDK_VERSION2,
      page_url: Api.getInstance().getUrl(),
      service_worker_status: getServiceWorkerStatus(),
      visibility_state: getVisibilityState(),
      effective_connection_type: getEffectiveConnectionType()
    },
    application_process_state: 0
  };
}
var MAX_METRIC_NAME_LENGTH = 100;
var RESERVED_AUTO_PREFIX = "_";
var oobMetrics = [
  FIRST_PAINT_COUNTER_NAME,
  FIRST_CONTENTFUL_PAINT_COUNTER_NAME,
  FIRST_INPUT_DELAY_COUNTER_NAME
];
function isValidMetricName(name19, traceName) {
  if (name19.length === 0 || name19.length > MAX_METRIC_NAME_LENGTH) {
    return false;
  }
  return traceName && traceName.startsWith(OOB_TRACE_PAGE_LOAD_PREFIX) && oobMetrics.indexOf(name19) > -1 || !name19.startsWith(RESERVED_AUTO_PREFIX);
}
function convertMetricValueToInteger(providedValue) {
  const valueAsInteger = Math.floor(providedValue);
  if (valueAsInteger < providedValue) {
    consoleLogger.info(`Metric value should be an Integer, setting the value as : ${valueAsInteger}.`);
  }
  return valueAsInteger;
}
var Trace = class {
  constructor(performanceController, name19, isAuto = false, traceMeasureName) {
    this.performanceController = performanceController;
    this.name = name19;
    this.isAuto = isAuto;
    this.state = 1;
    this.customAttributes = {};
    this.counters = {};
    this.api = Api.getInstance();
    this.randomId = Math.floor(Math.random() * 1e6);
    if (!this.isAuto) {
      this.traceStartMark = `${TRACE_START_MARK_PREFIX}-${this.randomId}-${this.name}`;
      this.traceStopMark = `${TRACE_STOP_MARK_PREFIX}-${this.randomId}-${this.name}`;
      this.traceMeasure = traceMeasureName || `${TRACE_MEASURE_PREFIX}-${this.randomId}-${this.name}`;
      if (traceMeasureName) {
        this.calculateTraceMetrics();
      }
    }
  }
  start() {
    if (this.state !== 1) {
      throw ERROR_FACTORY6.create("trace started", {
        traceName: this.name
      });
    }
    this.api.mark(this.traceStartMark);
    this.state = 2;
  }
  stop() {
    if (this.state !== 2) {
      throw ERROR_FACTORY6.create("trace stopped", {
        traceName: this.name
      });
    }
    this.state = 3;
    this.api.mark(this.traceStopMark);
    this.api.measure(this.traceMeasure, this.traceStartMark, this.traceStopMark);
    this.calculateTraceMetrics();
    logTrace(this);
  }
  record(startTime, duration, options) {
    if (startTime <= 0) {
      throw ERROR_FACTORY6.create("nonpositive trace startTime", {
        traceName: this.name
      });
    }
    if (duration <= 0) {
      throw ERROR_FACTORY6.create("nonpositive trace duration", {
        traceName: this.name
      });
    }
    this.durationUs = Math.floor(duration * 1e3);
    this.startTimeUs = Math.floor(startTime * 1e3);
    if (options && options.attributes) {
      this.customAttributes = Object.assign({}, options.attributes);
    }
    if (options && options.metrics) {
      for (const metricName of Object.keys(options.metrics)) {
        if (!isNaN(Number(options.metrics[metricName]))) {
          this.counters[metricName] = Math.floor(Number(options.metrics[metricName]));
        }
      }
    }
    logTrace(this);
  }
  incrementMetric(counter, numAsInteger = 1) {
    if (this.counters[counter] === void 0) {
      this.putMetric(counter, numAsInteger);
    } else {
      this.putMetric(counter, this.counters[counter] + numAsInteger);
    }
  }
  putMetric(counter, numAsInteger) {
    if (isValidMetricName(counter, this.name)) {
      this.counters[counter] = convertMetricValueToInteger(numAsInteger !== null && numAsInteger !== void 0 ? numAsInteger : 0);
    } else {
      throw ERROR_FACTORY6.create("invalid custom metric name", {
        customMetricName: counter
      });
    }
  }
  getMetric(counter) {
    return this.counters[counter] || 0;
  }
  putAttribute(attr, value) {
    const isValidName = isValidCustomAttributeName(attr);
    const isValidValue = isValidCustomAttributeValue(value);
    if (isValidName && isValidValue) {
      this.customAttributes[attr] = value;
      return;
    }
    if (!isValidName) {
      throw ERROR_FACTORY6.create("invalid attribute name", {
        attributeName: attr
      });
    }
    if (!isValidValue) {
      throw ERROR_FACTORY6.create("invalid attribute value", {
        attributeValue: value
      });
    }
  }
  getAttribute(attr) {
    return this.customAttributes[attr];
  }
  removeAttribute(attr) {
    if (this.customAttributes[attr] === void 0) {
      return;
    }
    delete this.customAttributes[attr];
  }
  getAttributes() {
    return Object.assign({}, this.customAttributes);
  }
  setStartTime(startTime) {
    this.startTimeUs = startTime;
  }
  setDuration(duration) {
    this.durationUs = duration;
  }
  calculateTraceMetrics() {
    const perfMeasureEntries = this.api.getEntriesByName(this.traceMeasure);
    const perfMeasureEntry = perfMeasureEntries && perfMeasureEntries[0];
    if (perfMeasureEntry) {
      this.durationUs = Math.floor(perfMeasureEntry.duration * 1e3);
      this.startTimeUs = Math.floor((perfMeasureEntry.startTime + this.api.getTimeOrigin()) * 1e3);
    }
  }
  static createOobTrace(performanceController, navigationTimings, paintTimings, firstInputDelay) {
    const route = Api.getInstance().getUrl();
    if (!route) {
      return;
    }
    const trace2 = new Trace(performanceController, OOB_TRACE_PAGE_LOAD_PREFIX + route, true);
    const timeOriginUs = Math.floor(Api.getInstance().getTimeOrigin() * 1e3);
    trace2.setStartTime(timeOriginUs);
    if (navigationTimings && navigationTimings[0]) {
      trace2.setDuration(Math.floor(navigationTimings[0].duration * 1e3));
      trace2.putMetric("domInteractive", Math.floor(navigationTimings[0].domInteractive * 1e3));
      trace2.putMetric("domContentLoadedEventEnd", Math.floor(navigationTimings[0].domContentLoadedEventEnd * 1e3));
      trace2.putMetric("loadEventEnd", Math.floor(navigationTimings[0].loadEventEnd * 1e3));
    }
    const FIRST_PAINT = "first-paint";
    const FIRST_CONTENTFUL_PAINT = "first-contentful-paint";
    if (paintTimings) {
      const firstPaint = paintTimings.find((paintObject) => paintObject.name === FIRST_PAINT);
      if (firstPaint && firstPaint.startTime) {
        trace2.putMetric(FIRST_PAINT_COUNTER_NAME, Math.floor(firstPaint.startTime * 1e3));
      }
      const firstContentfulPaint = paintTimings.find((paintObject) => paintObject.name === FIRST_CONTENTFUL_PAINT);
      if (firstContentfulPaint && firstContentfulPaint.startTime) {
        trace2.putMetric(FIRST_CONTENTFUL_PAINT_COUNTER_NAME, Math.floor(firstContentfulPaint.startTime * 1e3));
      }
      if (firstInputDelay) {
        trace2.putMetric(FIRST_INPUT_DELAY_COUNTER_NAME, Math.floor(firstInputDelay * 1e3));
      }
    }
    logTrace(trace2);
  }
  static createUserTimingTrace(performanceController, measureName) {
    const trace2 = new Trace(performanceController, measureName, false, measureName);
    logTrace(trace2);
  }
};
function createNetworkRequestEntry(performanceController, entry) {
  const performanceEntry = entry;
  if (!performanceEntry || performanceEntry.responseStart === void 0) {
    return;
  }
  const timeOrigin = Api.getInstance().getTimeOrigin();
  const startTimeUs = Math.floor((performanceEntry.startTime + timeOrigin) * 1e3);
  const timeToResponseInitiatedUs = performanceEntry.responseStart ? Math.floor((performanceEntry.responseStart - performanceEntry.startTime) * 1e3) : void 0;
  const timeToResponseCompletedUs = Math.floor((performanceEntry.responseEnd - performanceEntry.startTime) * 1e3);
  const url = performanceEntry.name && performanceEntry.name.split("?")[0];
  const networkRequest = {
    performanceController,
    url,
    responsePayloadBytes: performanceEntry.transferSize,
    startTimeUs,
    timeToResponseInitiatedUs,
    timeToResponseCompletedUs
  };
  logNetworkRequest(networkRequest);
}
var FID_WAIT_TIME_MS = 5e3;
function setupOobResources(performanceController) {
  if (!getIid()) {
    return;
  }
  setTimeout(() => setupOobTraces(performanceController), 0);
  setTimeout(() => setupNetworkRequests(performanceController), 0);
  setTimeout(() => setupUserTimingTraces(performanceController), 0);
}
function setupNetworkRequests(performanceController) {
  const api = Api.getInstance();
  const resources = api.getEntriesByType("resource");
  for (const resource of resources) {
    createNetworkRequestEntry(performanceController, resource);
  }
  api.setupObserver("resource", (entry) => createNetworkRequestEntry(performanceController, entry));
}
function setupOobTraces(performanceController) {
  const api = Api.getInstance();
  const navigationTimings = api.getEntriesByType("navigation");
  const paintTimings = api.getEntriesByType("paint");
  if (api.onFirstInputDelay) {
    let timeoutId = setTimeout(() => {
      Trace.createOobTrace(performanceController, navigationTimings, paintTimings);
      timeoutId = void 0;
    }, FID_WAIT_TIME_MS);
    api.onFirstInputDelay((fid) => {
      if (timeoutId) {
        clearTimeout(timeoutId);
        Trace.createOobTrace(performanceController, navigationTimings, paintTimings, fid);
      }
    });
  } else {
    Trace.createOobTrace(performanceController, navigationTimings, paintTimings);
  }
}
function setupUserTimingTraces(performanceController) {
  const api = Api.getInstance();
  const measures = api.getEntriesByType("measure");
  for (const measure of measures) {
    createUserTimingTrace(performanceController, measure);
  }
  api.setupObserver("measure", (entry) => createUserTimingTrace(performanceController, entry));
}
function createUserTimingTrace(performanceController, measure) {
  const measureName = measure.name;
  if (measureName.substring(0, TRACE_MEASURE_PREFIX.length) === TRACE_MEASURE_PREFIX) {
    return;
  }
  Trace.createUserTimingTrace(performanceController, measureName);
}
var PerformanceController = class {
  constructor(app, installations) {
    this.app = app;
    this.installations = installations;
    this.initialized = false;
  }
  _init(settings2) {
    if (this.initialized) {
      return;
    }
    if ((settings2 === null || settings2 === void 0 ? void 0 : settings2.dataCollectionEnabled) !== void 0) {
      this.dataCollectionEnabled = settings2.dataCollectionEnabled;
    }
    if ((settings2 === null || settings2 === void 0 ? void 0 : settings2.instrumentationEnabled) !== void 0) {
      this.instrumentationEnabled = settings2.instrumentationEnabled;
    }
    if (Api.getInstance().requiredApisAvailable()) {
      validateIndexedDBOpenable().then((isAvailable) => {
        if (isAvailable) {
          setupTransportService();
          getInitializationPromise(this).then(() => setupOobResources(this), () => setupOobResources(this));
          this.initialized = true;
        }
      }).catch((error) => {
        consoleLogger.info(`Environment doesn't support IndexedDB: ${error}`);
      });
    } else {
      consoleLogger.info('Firebase Performance cannot start if the browser does not support "Fetch" and "Promise", or cookies are disabled.');
    }
  }
  set instrumentationEnabled(val) {
    SettingsService.getInstance().instrumentationEnabled = val;
  }
  get instrumentationEnabled() {
    return SettingsService.getInstance().instrumentationEnabled;
  }
  set dataCollectionEnabled(val) {
    SettingsService.getInstance().dataCollectionEnabled = val;
  }
  get dataCollectionEnabled() {
    return SettingsService.getInstance().dataCollectionEnabled;
  }
};
var DEFAULT_ENTRY_NAME2 = "[DEFAULT]";
function trace(performance, name19) {
  performance = getModularInstance(performance);
  return new Trace(performance, name19);
}
var factory7 = (container, { options: settings2 }) => {
  const app = container.getProvider("app").getImmediate();
  const installations = container.getProvider("installations-internal").getImmediate();
  if (app.name !== DEFAULT_ENTRY_NAME2) {
    throw ERROR_FACTORY6.create("FB not default");
  }
  if (typeof window === "undefined") {
    throw ERROR_FACTORY6.create("no window");
  }
  setupApi(window);
  const perfInstance = new PerformanceController(app, installations);
  perfInstance._init(settings2);
  return perfInstance;
};
function registerPerformance() {
  _registerComponent(new Component("performance", factory7, "PUBLIC"));
  registerVersion(name14, version14);
  registerVersion(name14, version14, "esm2017");
}
registerPerformance();

// node_modules/@firebase/performance-compat/dist/esm/index.esm2017.js
var PerformanceCompatImpl = class {
  constructor(app, _delegate) {
    this.app = app;
    this._delegate = _delegate;
  }
  get instrumentationEnabled() {
    return this._delegate.instrumentationEnabled;
  }
  set instrumentationEnabled(val) {
    this._delegate.instrumentationEnabled = val;
  }
  get dataCollectionEnabled() {
    return this._delegate.dataCollectionEnabled;
  }
  set dataCollectionEnabled(val) {
    this._delegate.dataCollectionEnabled = val;
  }
  trace(traceName) {
    return trace(this._delegate, traceName);
  }
};
var name15 = "@firebase/performance-compat";
var version15 = "0.1.10";
function registerPerformanceCompat(firebaseInstance) {
  firebaseInstance.INTERNAL.registerComponent(new Component("performance-compat", performanceFactory, "PUBLIC"));
  firebaseInstance.registerVersion(name15, version15);
}
function performanceFactory(container) {
  const app = container.getProvider("app-compat").getImmediate();
  const performance = container.getProvider("performance").getImmediate();
  return new PerformanceCompatImpl(app, performance);
}
registerPerformanceCompat(firebase);

// node_modules/@firebase/remote-config/dist/esm/index.esm2017.js
var name16 = "@firebase/remote-config";
var version16 = "0.3.9";
var RemoteConfigAbortSignal = class {
  constructor() {
    this.listeners = [];
  }
  addEventListener(listener) {
    this.listeners.push(listener);
  }
  abort() {
    this.listeners.forEach((listener) => listener());
  }
};
var RC_COMPONENT_NAME = "remote-config";
var ERROR_DESCRIPTION_MAP2 = {
  ["registration-window"]: "Undefined window object. This SDK only supports usage in a browser environment.",
  ["registration-project-id"]: "Undefined project identifier. Check Firebase app initialization.",
  ["registration-api-key"]: "Undefined API key. Check Firebase app initialization.",
  ["registration-app-id"]: "Undefined app identifier. Check Firebase app initialization.",
  ["storage-open"]: "Error thrown when opening storage. Original error: {$originalErrorMessage}.",
  ["storage-get"]: "Error thrown when reading from storage. Original error: {$originalErrorMessage}.",
  ["storage-set"]: "Error thrown when writing to storage. Original error: {$originalErrorMessage}.",
  ["storage-delete"]: "Error thrown when deleting from storage. Original error: {$originalErrorMessage}.",
  ["fetch-client-network"]: "Fetch client failed to connect to a network. Check Internet connection. Original error: {$originalErrorMessage}.",
  ["fetch-timeout"]: 'The config fetch request timed out.  Configure timeout using "fetchTimeoutMillis" SDK setting.',
  ["fetch-throttle"]: 'The config fetch request timed out while in an exponential backoff state. Configure timeout using "fetchTimeoutMillis" SDK setting. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.',
  ["fetch-client-parse"]: "Fetch client could not parse response. Original error: {$originalErrorMessage}.",
  ["fetch-status"]: "Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.",
  ["indexed-db-unavailable"]: "Indexed DB is not supported by current browser"
};
var ERROR_FACTORY7 = new ErrorFactory("remoteconfig", "Remote Config", ERROR_DESCRIPTION_MAP2);
function hasErrorCode(e, errorCode) {
  return e instanceof FirebaseError && e.code.indexOf(errorCode) !== -1;
}
var DEFAULT_VALUE_FOR_BOOLEAN = false;
var DEFAULT_VALUE_FOR_STRING = "";
var DEFAULT_VALUE_FOR_NUMBER = 0;
var BOOLEAN_TRUTHY_VALUES = ["1", "true", "t", "yes", "y", "on"];
var Value = class {
  constructor(_source, _value = DEFAULT_VALUE_FOR_STRING) {
    this._source = _source;
    this._value = _value;
  }
  asString() {
    return this._value;
  }
  asBoolean() {
    if (this._source === "static") {
      return DEFAULT_VALUE_FOR_BOOLEAN;
    }
    return BOOLEAN_TRUTHY_VALUES.indexOf(this._value.toLowerCase()) >= 0;
  }
  asNumber() {
    if (this._source === "static") {
      return DEFAULT_VALUE_FOR_NUMBER;
    }
    let num = Number(this._value);
    if (isNaN(num)) {
      num = DEFAULT_VALUE_FOR_NUMBER;
    }
    return num;
  }
  getSource() {
    return this._source;
  }
};
async function activate(remoteConfig) {
  const rc3 = getModularInstance(remoteConfig);
  const [lastSuccessfulFetchResponse, activeConfigEtag] = await Promise.all([
    rc3._storage.getLastSuccessfulFetchResponse(),
    rc3._storage.getActiveConfigEtag()
  ]);
  if (!lastSuccessfulFetchResponse || !lastSuccessfulFetchResponse.config || !lastSuccessfulFetchResponse.eTag || lastSuccessfulFetchResponse.eTag === activeConfigEtag) {
    return false;
  }
  await Promise.all([
    rc3._storageCache.setActiveConfig(lastSuccessfulFetchResponse.config),
    rc3._storage.setActiveConfigEtag(lastSuccessfulFetchResponse.eTag)
  ]);
  return true;
}
function ensureInitialized(remoteConfig) {
  const rc3 = getModularInstance(remoteConfig);
  if (!rc3._initializePromise) {
    rc3._initializePromise = rc3._storageCache.loadFromStorage().then(() => {
      rc3._isInitializationComplete = true;
    });
  }
  return rc3._initializePromise;
}
async function fetchConfig(remoteConfig) {
  const rc3 = getModularInstance(remoteConfig);
  const abortSignal = new RemoteConfigAbortSignal();
  setTimeout(async () => {
    abortSignal.abort();
  }, rc3.settings.fetchTimeoutMillis);
  try {
    await rc3._client.fetch({
      cacheMaxAgeMillis: rc3.settings.minimumFetchIntervalMillis,
      signal: abortSignal
    });
    await rc3._storageCache.setLastFetchStatus("success");
  } catch (e) {
    const lastFetchStatus = hasErrorCode(e, "fetch-throttle") ? "throttle" : "failure";
    await rc3._storageCache.setLastFetchStatus(lastFetchStatus);
    throw e;
  }
}
function getAll(remoteConfig) {
  const rc3 = getModularInstance(remoteConfig);
  return getAllKeys(rc3._storageCache.getActiveConfig(), rc3.defaultConfig).reduce((allConfigs, key) => {
    allConfigs[key] = getValue(remoteConfig, key);
    return allConfigs;
  }, {});
}
function getBoolean(remoteConfig, key) {
  return getValue(getModularInstance(remoteConfig), key).asBoolean();
}
function getNumber(remoteConfig, key) {
  return getValue(getModularInstance(remoteConfig), key).asNumber();
}
function getString(remoteConfig, key) {
  return getValue(getModularInstance(remoteConfig), key).asString();
}
function getValue(remoteConfig, key) {
  const rc3 = getModularInstance(remoteConfig);
  if (!rc3._isInitializationComplete) {
    rc3._logger.debug(`A value was requested for key "${key}" before SDK initialization completed. Await on ensureInitialized if the intent was to get a previously activated value.`);
  }
  const activeConfig = rc3._storageCache.getActiveConfig();
  if (activeConfig && activeConfig[key] !== void 0) {
    return new Value("remote", activeConfig[key]);
  } else if (rc3.defaultConfig && rc3.defaultConfig[key] !== void 0) {
    return new Value("default", String(rc3.defaultConfig[key]));
  }
  rc3._logger.debug(`Returning static value for key "${key}". Define a default or remote value if this is unintentional.`);
  return new Value("static");
}
function setLogLevel3(remoteConfig, logLevel) {
  const rc3 = getModularInstance(remoteConfig);
  switch (logLevel) {
    case "debug":
      rc3._logger.logLevel = LogLevel.DEBUG;
      break;
    case "silent":
      rc3._logger.logLevel = LogLevel.SILENT;
      break;
    default:
      rc3._logger.logLevel = LogLevel.ERROR;
  }
}
function getAllKeys(obj1 = {}, obj2 = {}) {
  return Object.keys(Object.assign(Object.assign({}, obj1), obj2));
}
var CachingClient = class {
  constructor(client, storage2, storageCache, logger4) {
    this.client = client;
    this.storage = storage2;
    this.storageCache = storageCache;
    this.logger = logger4;
  }
  isCachedDataFresh(cacheMaxAgeMillis, lastSuccessfulFetchTimestampMillis) {
    if (!lastSuccessfulFetchTimestampMillis) {
      this.logger.debug("Config fetch cache check. Cache unpopulated.");
      return false;
    }
    const cacheAgeMillis = Date.now() - lastSuccessfulFetchTimestampMillis;
    const isCachedDataFresh = cacheAgeMillis <= cacheMaxAgeMillis;
    this.logger.debug(`Config fetch cache check. Cache age millis: ${cacheAgeMillis}. Cache max age millis (minimumFetchIntervalMillis setting): ${cacheMaxAgeMillis}. Is cache hit: ${isCachedDataFresh}.`);
    return isCachedDataFresh;
  }
  async fetch(request) {
    const [lastSuccessfulFetchTimestampMillis, lastSuccessfulFetchResponse] = await Promise.all([
      this.storage.getLastSuccessfulFetchTimestampMillis(),
      this.storage.getLastSuccessfulFetchResponse()
    ]);
    if (lastSuccessfulFetchResponse && this.isCachedDataFresh(request.cacheMaxAgeMillis, lastSuccessfulFetchTimestampMillis)) {
      return lastSuccessfulFetchResponse;
    }
    request.eTag = lastSuccessfulFetchResponse && lastSuccessfulFetchResponse.eTag;
    const response = await this.client.fetch(request);
    const storageOperations = [
      this.storageCache.setLastSuccessfulFetchTimestampMillis(Date.now())
    ];
    if (response.status === 200) {
      storageOperations.push(this.storage.setLastSuccessfulFetchResponse(response));
    }
    await Promise.all(storageOperations);
    return response;
  }
};
function getUserLanguage(navigatorLanguage = navigator) {
  return navigatorLanguage.languages && navigatorLanguage.languages[0] || navigatorLanguage.language;
}
var RestClient = class {
  constructor(firebaseInstallations, sdkVersion, namespace, projectId, apiKey, appId) {
    this.firebaseInstallations = firebaseInstallations;
    this.sdkVersion = sdkVersion;
    this.namespace = namespace;
    this.projectId = projectId;
    this.apiKey = apiKey;
    this.appId = appId;
  }
  async fetch(request) {
    var _a2, _b, _c2;
    const [installationId, installationToken] = await Promise.all([
      this.firebaseInstallations.getId(),
      this.firebaseInstallations.getToken()
    ]);
    const urlBase = window.FIREBASE_REMOTE_CONFIG_URL_BASE || "https://firebaseremoteconfig.googleapis.com";
    const url = `${urlBase}/v1/projects/${this.projectId}/namespaces/${this.namespace}:fetch?key=${this.apiKey}`;
    const headers = {
      "Content-Type": "application/json",
      "Content-Encoding": "gzip",
      "If-None-Match": request.eTag || "*"
    };
    const requestBody = {
      sdk_version: this.sdkVersion,
      app_instance_id: installationId,
      app_instance_id_token: installationToken,
      app_id: this.appId,
      language_code: getUserLanguage()
    };
    const options = {
      method: "POST",
      headers,
      body: JSON.stringify(requestBody)
    };
    const fetchPromise = fetch(url, options);
    const timeoutPromise = new Promise((_resolve, reject) => {
      request.signal.addEventListener(() => {
        const error = new Error("The operation was aborted.");
        error.name = "AbortError";
        reject(error);
      });
    });
    let response;
    try {
      await Promise.race([fetchPromise, timeoutPromise]);
      response = await fetchPromise;
    } catch (originalError) {
      let errorCode = "fetch-client-network";
      if (((_a2 = originalError) === null || _a2 === void 0 ? void 0 : _a2.name) === "AbortError") {
        errorCode = "fetch-timeout";
      }
      throw ERROR_FACTORY7.create(errorCode, {
        originalErrorMessage: (_b = originalError) === null || _b === void 0 ? void 0 : _b.message
      });
    }
    let status = response.status;
    const responseEtag = response.headers.get("ETag") || void 0;
    let config;
    let state;
    if (response.status === 200) {
      let responseBody;
      try {
        responseBody = await response.json();
      } catch (originalError) {
        throw ERROR_FACTORY7.create("fetch-client-parse", {
          originalErrorMessage: (_c2 = originalError) === null || _c2 === void 0 ? void 0 : _c2.message
        });
      }
      config = responseBody["entries"];
      state = responseBody["state"];
    }
    if (state === "INSTANCE_STATE_UNSPECIFIED") {
      status = 500;
    } else if (state === "NO_CHANGE") {
      status = 304;
    } else if (state === "NO_TEMPLATE" || state === "EMPTY_CONFIG") {
      config = {};
    }
    if (status !== 304 && status !== 200) {
      throw ERROR_FACTORY7.create("fetch-status", {
        httpStatus: status
      });
    }
    return { status, eTag: responseEtag, config };
  }
};
function setAbortableTimeout(signal, throttleEndTimeMillis) {
  return new Promise((resolve, reject) => {
    const backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);
    const timeout = setTimeout(resolve, backoffMillis);
    signal.addEventListener(() => {
      clearTimeout(timeout);
      reject(ERROR_FACTORY7.create("fetch-throttle", {
        throttleEndTimeMillis
      }));
    });
  });
}
function isRetriableError(e) {
  if (!(e instanceof FirebaseError) || !e.customData) {
    return false;
  }
  const httpStatus = Number(e.customData["httpStatus"]);
  return httpStatus === 429 || httpStatus === 500 || httpStatus === 503 || httpStatus === 504;
}
var RetryingClient = class {
  constructor(client, storage2) {
    this.client = client;
    this.storage = storage2;
  }
  async fetch(request) {
    const throttleMetadata = await this.storage.getThrottleMetadata() || {
      backoffCount: 0,
      throttleEndTimeMillis: Date.now()
    };
    return this.attemptFetch(request, throttleMetadata);
  }
  async attemptFetch(request, { throttleEndTimeMillis, backoffCount }) {
    await setAbortableTimeout(request.signal, throttleEndTimeMillis);
    try {
      const response = await this.client.fetch(request);
      await this.storage.deleteThrottleMetadata();
      return response;
    } catch (e) {
      if (!isRetriableError(e)) {
        throw e;
      }
      const throttleMetadata = {
        throttleEndTimeMillis: Date.now() + calculateBackoffMillis(backoffCount),
        backoffCount: backoffCount + 1
      };
      await this.storage.setThrottleMetadata(throttleMetadata);
      return this.attemptFetch(request, throttleMetadata);
    }
  }
};
var DEFAULT_FETCH_TIMEOUT_MILLIS = 60 * 1e3;
var DEFAULT_CACHE_MAX_AGE_MILLIS = 12 * 60 * 60 * 1e3;
var RemoteConfig = class {
  constructor(app, _client, _storageCache, _storage, _logger) {
    this.app = app;
    this._client = _client;
    this._storageCache = _storageCache;
    this._storage = _storage;
    this._logger = _logger;
    this._isInitializationComplete = false;
    this.settings = {
      fetchTimeoutMillis: DEFAULT_FETCH_TIMEOUT_MILLIS,
      minimumFetchIntervalMillis: DEFAULT_CACHE_MAX_AGE_MILLIS
    };
    this.defaultConfig = {};
  }
  get fetchTimeMillis() {
    return this._storageCache.getLastSuccessfulFetchTimestampMillis() || -1;
  }
  get lastFetchStatus() {
    return this._storageCache.getLastFetchStatus() || "no-fetch-yet";
  }
};
function toFirebaseError(event, errorCode) {
  var _a2;
  const originalError = event.target.error || void 0;
  return ERROR_FACTORY7.create(errorCode, {
    originalErrorMessage: originalError && ((_a2 = originalError) === null || _a2 === void 0 ? void 0 : _a2.message)
  });
}
var APP_NAMESPACE_STORE = "app_namespace_store";
var DB_NAME2 = "firebase_remote_config";
var DB_VERSION2 = 1;
function openDatabase() {
  return new Promise((resolve, reject) => {
    var _a2;
    try {
      const request = indexedDB.open(DB_NAME2, DB_VERSION2);
      request.onerror = (event) => {
        reject(toFirebaseError(event, "storage-open"));
      };
      request.onsuccess = (event) => {
        resolve(event.target.result);
      };
      request.onupgradeneeded = (event) => {
        const db2 = event.target.result;
        switch (event.oldVersion) {
          case 0:
            db2.createObjectStore(APP_NAMESPACE_STORE, {
              keyPath: "compositeKey"
            });
        }
      };
    } catch (error) {
      reject(ERROR_FACTORY7.create("storage-open", {
        originalErrorMessage: (_a2 = error) === null || _a2 === void 0 ? void 0 : _a2.message
      }));
    }
  });
}
var Storage = class {
  constructor(appId, appName, namespace, openDbPromise = openDatabase()) {
    this.appId = appId;
    this.appName = appName;
    this.namespace = namespace;
    this.openDbPromise = openDbPromise;
  }
  getLastFetchStatus() {
    return this.get("last_fetch_status");
  }
  setLastFetchStatus(status) {
    return this.set("last_fetch_status", status);
  }
  getLastSuccessfulFetchTimestampMillis() {
    return this.get("last_successful_fetch_timestamp_millis");
  }
  setLastSuccessfulFetchTimestampMillis(timestamp) {
    return this.set("last_successful_fetch_timestamp_millis", timestamp);
  }
  getLastSuccessfulFetchResponse() {
    return this.get("last_successful_fetch_response");
  }
  setLastSuccessfulFetchResponse(response) {
    return this.set("last_successful_fetch_response", response);
  }
  getActiveConfig() {
    return this.get("active_config");
  }
  setActiveConfig(config) {
    return this.set("active_config", config);
  }
  getActiveConfigEtag() {
    return this.get("active_config_etag");
  }
  setActiveConfigEtag(etag) {
    return this.set("active_config_etag", etag);
  }
  getThrottleMetadata() {
    return this.get("throttle_metadata");
  }
  setThrottleMetadata(metadata) {
    return this.set("throttle_metadata", metadata);
  }
  deleteThrottleMetadata() {
    return this.delete("throttle_metadata");
  }
  async get(key) {
    const db2 = await this.openDbPromise;
    return new Promise((resolve, reject) => {
      var _a2;
      const transaction = db2.transaction([APP_NAMESPACE_STORE], "readonly");
      const objectStore = transaction.objectStore(APP_NAMESPACE_STORE);
      const compositeKey = this.createCompositeKey(key);
      try {
        const request = objectStore.get(compositeKey);
        request.onerror = (event) => {
          reject(toFirebaseError(event, "storage-get"));
        };
        request.onsuccess = (event) => {
          const result = event.target.result;
          if (result) {
            resolve(result.value);
          } else {
            resolve(void 0);
          }
        };
      } catch (e) {
        reject(ERROR_FACTORY7.create("storage-get", {
          originalErrorMessage: (_a2 = e) === null || _a2 === void 0 ? void 0 : _a2.message
        }));
      }
    });
  }
  async set(key, value) {
    const db2 = await this.openDbPromise;
    return new Promise((resolve, reject) => {
      var _a2;
      const transaction = db2.transaction([APP_NAMESPACE_STORE], "readwrite");
      const objectStore = transaction.objectStore(APP_NAMESPACE_STORE);
      const compositeKey = this.createCompositeKey(key);
      try {
        const request = objectStore.put({
          compositeKey,
          value
        });
        request.onerror = (event) => {
          reject(toFirebaseError(event, "storage-set"));
        };
        request.onsuccess = () => {
          resolve();
        };
      } catch (e) {
        reject(ERROR_FACTORY7.create("storage-set", {
          originalErrorMessage: (_a2 = e) === null || _a2 === void 0 ? void 0 : _a2.message
        }));
      }
    });
  }
  async delete(key) {
    const db2 = await this.openDbPromise;
    return new Promise((resolve, reject) => {
      var _a2;
      const transaction = db2.transaction([APP_NAMESPACE_STORE], "readwrite");
      const objectStore = transaction.objectStore(APP_NAMESPACE_STORE);
      const compositeKey = this.createCompositeKey(key);
      try {
        const request = objectStore.delete(compositeKey);
        request.onerror = (event) => {
          reject(toFirebaseError(event, "storage-delete"));
        };
        request.onsuccess = () => {
          resolve();
        };
      } catch (e) {
        reject(ERROR_FACTORY7.create("storage-delete", {
          originalErrorMessage: (_a2 = e) === null || _a2 === void 0 ? void 0 : _a2.message
        }));
      }
    });
  }
  createCompositeKey(key) {
    return [this.appId, this.appName, this.namespace, key].join();
  }
};
var StorageCache = class {
  constructor(storage2) {
    this.storage = storage2;
  }
  getLastFetchStatus() {
    return this.lastFetchStatus;
  }
  getLastSuccessfulFetchTimestampMillis() {
    return this.lastSuccessfulFetchTimestampMillis;
  }
  getActiveConfig() {
    return this.activeConfig;
  }
  async loadFromStorage() {
    const lastFetchStatusPromise = this.storage.getLastFetchStatus();
    const lastSuccessfulFetchTimestampMillisPromise = this.storage.getLastSuccessfulFetchTimestampMillis();
    const activeConfigPromise = this.storage.getActiveConfig();
    const lastFetchStatus = await lastFetchStatusPromise;
    if (lastFetchStatus) {
      this.lastFetchStatus = lastFetchStatus;
    }
    const lastSuccessfulFetchTimestampMillis = await lastSuccessfulFetchTimestampMillisPromise;
    if (lastSuccessfulFetchTimestampMillis) {
      this.lastSuccessfulFetchTimestampMillis = lastSuccessfulFetchTimestampMillis;
    }
    const activeConfig = await activeConfigPromise;
    if (activeConfig) {
      this.activeConfig = activeConfig;
    }
  }
  setLastFetchStatus(status) {
    this.lastFetchStatus = status;
    return this.storage.setLastFetchStatus(status);
  }
  setLastSuccessfulFetchTimestampMillis(timestampMillis) {
    this.lastSuccessfulFetchTimestampMillis = timestampMillis;
    return this.storage.setLastSuccessfulFetchTimestampMillis(timestampMillis);
  }
  setActiveConfig(activeConfig) {
    this.activeConfig = activeConfig;
    return this.storage.setActiveConfig(activeConfig);
  }
};
function registerRemoteConfig() {
  _registerComponent(new Component(RC_COMPONENT_NAME, remoteConfigFactory2, "PUBLIC").setMultipleInstances(true));
  registerVersion(name16, version16);
  registerVersion(name16, version16, "esm2017");
  function remoteConfigFactory2(container, { instanceIdentifier: namespace }) {
    const app = container.getProvider("app").getImmediate();
    const installations = container.getProvider("installations-internal").getImmediate();
    if (typeof window === "undefined") {
      throw ERROR_FACTORY7.create("registration-window");
    }
    if (!isIndexedDBAvailable()) {
      throw ERROR_FACTORY7.create("indexed-db-unavailable");
    }
    const { projectId, apiKey, appId } = app.options;
    if (!projectId) {
      throw ERROR_FACTORY7.create("registration-project-id");
    }
    if (!apiKey) {
      throw ERROR_FACTORY7.create("registration-api-key");
    }
    if (!appId) {
      throw ERROR_FACTORY7.create("registration-app-id");
    }
    namespace = namespace || "firebase";
    const storage2 = new Storage(appId, app.name, namespace);
    const storageCache = new StorageCache(storage2);
    const logger4 = new Logger(name16);
    logger4.logLevel = LogLevel.ERROR;
    const restClient = new RestClient(installations, SDK_VERSION, namespace, projectId, apiKey, appId);
    const retryingClient = new RetryingClient(restClient, storage2);
    const cachingClient = new CachingClient(retryingClient, storage2, storageCache, logger4);
    const remoteConfigInstance = new RemoteConfig(app, cachingClient, storageCache, storage2, logger4);
    ensureInitialized(remoteConfigInstance);
    return remoteConfigInstance;
  }
}
async function fetchAndActivate(remoteConfig) {
  remoteConfig = getModularInstance(remoteConfig);
  await fetchConfig(remoteConfig);
  return activate(remoteConfig);
}
async function isSupported3() {
  if (!isIndexedDBAvailable()) {
    return false;
  }
  try {
    const isDBOpenable = await validateIndexedDBOpenable();
    return isDBOpenable;
  } catch (error) {
    return false;
  }
}
registerRemoteConfig();

// node_modules/@firebase/remote-config-compat/dist/esm/index.esm2017.js
var RemoteConfigCompatImpl = class {
  constructor(app, _delegate) {
    this.app = app;
    this._delegate = _delegate;
  }
  get defaultConfig() {
    return this._delegate.defaultConfig;
  }
  set defaultConfig(value) {
    this._delegate.defaultConfig = value;
  }
  get fetchTimeMillis() {
    return this._delegate.fetchTimeMillis;
  }
  get lastFetchStatus() {
    return this._delegate.lastFetchStatus;
  }
  get settings() {
    return this._delegate.settings;
  }
  set settings(value) {
    this._delegate.settings = value;
  }
  activate() {
    return activate(this._delegate);
  }
  ensureInitialized() {
    return ensureInitialized(this._delegate);
  }
  fetch() {
    return fetchConfig(this._delegate);
  }
  fetchAndActivate() {
    return fetchAndActivate(this._delegate);
  }
  getAll() {
    return getAll(this._delegate);
  }
  getBoolean(key) {
    return getBoolean(this._delegate, key);
  }
  getNumber(key) {
    return getNumber(this._delegate, key);
  }
  getString(key) {
    return getString(this._delegate, key);
  }
  getValue(key) {
    return getValue(this._delegate, key);
  }
  setLogLevel(logLevel) {
    setLogLevel3(this._delegate, logLevel);
  }
};
var name17 = "@firebase/remote-config-compat";
var version17 = "0.1.10";
function registerRemoteConfigCompat(firebaseInstance) {
  firebaseInstance.INTERNAL.registerComponent(new Component("remoteConfig-compat", remoteConfigFactory, "PUBLIC").setMultipleInstances(true).setServiceProps({ isSupported: isSupported3 }));
  firebaseInstance.registerVersion(name17, version17);
}
function remoteConfigFactory(container, { instanceIdentifier: namespace }) {
  const app = container.getProvider("app-compat").getImmediate();
  const remoteConfig = container.getProvider("remote-config").getImmediate({
    identifier: namespace
  });
  return new RemoteConfigCompatImpl(app, remoteConfig);
}
registerRemoteConfigCompat(firebase);

// node_modules/firebase/compat/dist/index.esm.js
var name$1 = "firebase";
var version$1 = "9.8.3";
firebase.registerVersion(name$1, version$1, "app-compat");
var name18 = "firebase";
var version18 = "9.8.3";
console.warn("\nIt looks like you're using the development build of the Firebase JS SDK.\nWhen deploying Firebase apps to production, it is advisable to only import\nthe individual SDK components you intend to use.\n\nFor the module builds, these are available in the following manner\n(replace <PACKAGE> with the name of a component - i.e. auth, database, etc):\n\nCommonJS Modules:\nconst firebase = require('firebase/app');\nrequire('firebase/<PACKAGE>');\n\nES Modules:\nimport firebase from 'firebase/app';\nimport 'firebase/<PACKAGE>';\n\nTypescript:\nimport firebase from 'firebase/app';\nimport 'firebase/<PACKAGE>';\n");
firebase.registerVersion(name18, version18, "compat");

// dep:firebase_compat
var firebase_compat_default = firebase;
export {
  firebase_compat_default as default
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* @license
* Copyright 2020 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
//# sourceMappingURL=firebase_compat.js.map
